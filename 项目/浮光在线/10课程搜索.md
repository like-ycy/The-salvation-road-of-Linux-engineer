# 课程搜索

## elasticsearch

Elasticsearch是一个基于[Lucene](https://baike.baidu.com/item/Lucene/6753302)的搜索服务器，也是属于NoSQL阵营的数据库。它提供了一个分布式多用户能力的[全文搜索引擎](https://baike.baidu.com/item/全文搜索引擎/7847410)，基于RESTful web接口。Elasticsearch是用Java语言开发的，并作为Apache许可条款下的开放源码发布，是一种流行的企业级搜索引擎。除了es以外， Sphinx 、迅搜、Zebra、Solr 、Whoosh。 

官网：https://www.elastic.co/cn/elasticsearch/

中文文档：https://www.elastic.co/guide/cn/index.html

## podman安装elasticsearch

支持单点部署和集群部署。

```bash
 # 从课件的素材中找到es的镜像压缩包，复制到ubuntu桌面下，执行以下命令
 # sudo docker load -i ~/Desktop/elasticsearch.7.13.4.tar.gz
 podman load -i ~/Desktop/elasticsearch.7.13.4.tar.gz
 # 也可以不执行上面的操作，直接run可以让docker从官网拉取es镜像。
 
 # sudo docker run --name elasticsearch --restart=always -d -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS="-Xms256m -Xmx256m" -e "discovery.type=single-node" elasticsearch:7.13.4
 
 podman run --name elasticsearch -d -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS="-Xms512m -Xmx512m" -e "discovery.type=single-node" elasticsearch:7.13.4
```

参数说明

```
 --name elasticsearch  
        设置当前容器的容器名称为elasticsearch
 --restart=always
        设置容器开机自启，即便物理机关机重启了，docker在启动以后也会自动帮我们把当前容器启动起来。
 -d     设置当前容器为守护式容器，在后台运行
 -p 9200:9200
        设置端口影射，<物理机端口>:<容器端口>
        表示访问了当前物理机的9200，相当于访问了当前容器的9200端口
 -p 9300:9300
        设置端口影射，<物理机端口>:<容器端口>
        表示访问了当前物理机的9300，相当于访问了当前容器的9300端口
 -e ES_JAVA_OPTS="-Xms256m -Xmx256m"
        设置环境变量，变量名为ES_JAVA_OPTS,这个变量是启动elasticsearch的关键。
        表示设置java环境的最小和最大使用内存，内存不足，elasticsearch是无法启动的，所以此处设置为最大内存256M
 -e "discovery.type=single-node"
        设置环境变量，变量名discovery.type
        discovery.type 表示当前elasticsearch的运作模式为single-node，表示单机部署/单点部署
 elasticsearch:7.13.4
        设置当前容器的镜像名和版本号
```

浏览器访问：http://127.0.0.1:9200

要基于es实现全文搜索，可以参考以下文档了解关于全文搜索的内容，。

https://www.elastic.co/guide/cn/elasticsearch/guide/current/full-text-search.html

全文搜索的实现，必须依靠es内部调用分词器对语句进行词性分析，拆词，给每一个单词构建一个索引。

所以默认情况下，es只提供了标准分析器，和简单分析器，这几块分词器都是只能针对英文进行分词。



### IK中文分词器

默认情况下，elasticsearch是外国开发的，所以本身对于中文分词构建分词索引的支持是不行的。所以我们需要在elasticsearch软件中新增一个支持中文索引和中文分词的插件，叫ik分词器。

注意：IK分词器插件的版本必须与elasticsearch的版本号同步。否则安装失败！

文档：https://github.com/medcl/elasticsearch-analysis-ik/releases

把IK分词器解压并复制到elasticsearch容器的/usr/share/elasticsearch/plugins目录下

```bash
 unzip ~/Desktop/elasticsearch-analysis-ik-7.13.4.zip -d ~/Desktop/ik-7.13.4
 podman cp ~/Desktop/ik-7.13.4 elasticsearch:/usr/share/elasticsearch/plugins
 podman stop elasticsearch
 podman start elasticsearch
```

注意：elasticsearch内部极其复杂，所以启动容器以后需要等待1分钟左右才对外提供搜索服务。

接下来，我们就可以通过postman测试

post http://localhost:9200/_analyze?pretty

基于智能分词模式来查询分析词性，json数据

```json
 {
    "analyzer":"ik_smart",
    "text":"我是中国人"    
 }
```

基于最大分词模式来查询分析词性，json数据

```json
 {
    "analyzer":"ik_max_word",
    "text":"我是中国人"  
 }
```



## 安装haystack

haystack是django的开源搜索框架，能够结合目前市面上大部分的搜索引擎用于实现自定义搜索功能，特别是全文搜索。

haystack支持多种搜索引擎，不仅仅是 jieba ，whoosh，使用solr、elasticsearch等搜索，也可通过haystack，而且直接切换引擎即可，甚至无需修改搜索代码。中文分词最好的就是jieba和elasticsearch+ik。

github： https://github.com/rhblind/drf-haystack

```bash
 # python操作elasticsearch的模块，注意对应版本
 pip install -U elasticsearch==7.13.4
 # django开发的haystack的模块，务必先安装drf-haystack，接着才安装django-haystack。因为drf-haystack不支持es7
 pip install -U drf-haystack
 pip install -U django-haystack
```



## 基本使用

### 安装配置

文档：https://drf-haystack.readthedocs.io/en/latest/01_intro.html#examples

```python
 INSTALLED_APPS = [
     # 必须在自己创建的子应用前面
     'haystack',
 
     # 自己创建的子应用
 ]
 
 # haystack连接elasticsearch的配置信息
 HAYSTACK_CONNECTIONS = {
     'default': {
         # haystack操作es的核心模块
         'ENGINE': 'haystack.backends.elasticsearch7_backend.Elasticsearch7SearchEngine',
         # es服务端地址
         'URL': 'http://127.0.0.1:9200/',
         # es索引仓库
         'INDEX_NAME': 'haystack',
     },
 }
 
 # 当ORM操作数据库改变时，自动更新es的索引，否则es的索引会找不到新增的数据
 HAYSTACK_SIGNAL_PROCESSOR = 'haystack.signals.RealtimeSignalProcessor'
```



### 索引模型

在courses子应用下创建search_indexes.py，用于设置es的索引模型。注意，索引模型的文件名必须是search_indexes。

```python
 from haystack import indexes
 from .models import Course
 
 class CourseIndex(indexes.SearchIndex, indexes.Indexable):
     # 全文索引[可以根据配置，可以包括多个字段索引]
     # document=True 表示当前字段为全文索引
     # use_template=True 表示接下来haystack需要加载一个固定路径的html模板文件，让text与其他索引字段绑定映射关系
     text = indexes.CharField(document=True, use_template=True)
     # 普通索引[单字段，只能提供单个字段值的搜索，所以此处的声明更主要是为了提供给上面的text全文索引使用的]
     # es索引名 = indexes.索引数据类型(model_attr="ORM中的字段名")
     id = indexes.IntegerField(model_attr="id")
     name = indexes.CharField(model_attr="name")
     description = indexes.CharField(model_attr="description")
     teacher = indexes.CharField(model_attr="teacher__name")
     course_cover = indexes.CharField(model_attr="course_cover")
     get_level_display=indexes.CharField(model_attr="get_level_display")
     students=indexes.IntegerField(model_attr="students")
     get_status_display=indexes.CharField(model_attr="get_status_display")
     lessons=indexes.IntegerField(model_attr="lessons")
     pub_lessons=indexes.IntegerField(model_attr="pub_lessons")
     price=indexes.DecimalField(model_attr="price")
     discount=indexes.CharField(model_attr="discount_json")
     orders=indexes.IntegerField(model_attr="orders")
 
     # 指定与当前es索引模型对接的mysql的ORM模型
     def get_model(self):
         return Course
 
     # 当用户搜索es索引时，对应的提供的mysql数据集有哪些？
     def index_queryset(self, using=None):
         return self.get_model().objects.filter(is_delete=False,is_show=True)
 
 
```



#### 模型中新增discount_json字段方法

courses.models，代码：

```python
 import json
 
 class Course(BaseModel):
     course_type = (
         (0, '付费购买'),
         (1, '会员专享'),
         (2, '学位课程'),
     )
     level_choices = (
         (0, '初级'),
         (1, '中级'),
         (2, '高级'),
     )
     status_choices = (
         (0, '上线'),
         (1, '下线'),
         (2, '预上线'),
     )
     # course_cover = models.ImageField(upload_to="course/cover", max_length=255, verbose_name="封面图片", blank=True, null=True)
     course_cover = StdImageField(variations={
         'thumb_1080x608': (1080, 608),   # 高清图
         'thumb_540x304': (540, 304),    # 中等比例,
         'thumb_108x61': (108, 61, True),  # 小图(第三个参数表示保持图片质量),
     }, max_length=255, delete_orphans=True, upload_to="course/cover", null=True, verbose_name="封面图片",blank=True)
     course_video = models.FileField(upload_to="course/video", max_length=255, verbose_name="封面视频", blank=True, null=True)
     course_type = models.SmallIntegerField(choices=course_type,default=0, verbose_name="付费类型")
     level = models.SmallIntegerField(choices=level_choices, default=1, verbose_name="难度等级")
     description = RichTextUploadingField(null=True, blank=True, verbose_name="详情介绍")
     pub_date = models.DateField(auto_now_add=True, verbose_name="发布日期")
     period = models.IntegerField(default=7, verbose_name="建议学习周期(day)")
     attachment_path = models.FileField(max_length=1000, blank=True, null=True, verbose_name="课件路径")
     attachment_link = models.CharField(max_length=1000, blank=True, null=True, verbose_name="课件链接")
     status = models.SmallIntegerField(choices=status_choices, default=0, verbose_name="课程状态")
     students = models.IntegerField(default=0, verbose_name="学习人数")
     lessons = models.IntegerField(default=0, verbose_name="总课时数量")
     pub_lessons = models.IntegerField(default=0, verbose_name="已更新课时数量")
     price = models.DecimalField(max_digits=10,decimal_places=2, verbose_name="课程原价",default=0)
     recomment_home_hot = models.BooleanField(default=False, verbose_name="是否推荐到首页新课栏目")
     recomment_home_top = models.BooleanField(default=False, verbose_name="是否推荐到首页必学栏目")
     direction = models.ForeignKey("CourseDirection", related_name="course_list", on_delete=models.DO_NOTHING, null=True, blank=True, db_constraint=False, verbose_name="学习方向")
     category = models.ForeignKey("CourseCategory", related_name="course_list", on_delete=models.DO_NOTHING, null=True, blank=True, db_constraint=False, verbose_name="课程分类")
     teacher = models.ForeignKey("Teacher", related_name="course_list", on_delete=models.DO_NOTHING, null=True, blank=True, db_constraint=False, verbose_name="授课老师")
 
     class Meta:
         db_table = "fg_course_info"
         verbose_name = "课程信息"
         verbose_name_plural = verbose_name
 
     def course_cover_small(self):
         if self.course_cover:
             return mark_safe(f'<img style="border-radius: 0%;" src="{self.course_cover.thumb_108x61.url}">')
         return ""
 
     course_cover_small.short_description = "封面图片(108x61)"
     course_cover_small.allow_tags = True
     course_cover_small.admin_order_field = "course_cover"
 
     def course_cover_medium(self):
         if self.course_cover:
             return mark_safe(f'<img style="border-radius: 0%;" src="{self.course_cover.thumb_540x304.url}">')
         return ""
 
     course_cover_medium.short_description = "封面图片(540x304)"
     course_cover_medium.allow_tags = True
     course_cover_medium.admin_order_field = "course_cover"
 
     def course_cover_large(self):
         if self.course_cover:
             return mark_safe(f'<img style="border-radius: 0%;" src="{self.course_cover.thumb_1080x608.url}">')
         return ""
 
     course_cover_large.short_description = "封面图片(1080x608)"
     course_cover_large.allow_tags = True
     course_cover_large.admin_order_field = "course_cover"
 
     @property
     def discount(self):
         # todo 将来通过计算获取当前课程的折扣优惠相关的信息
         return {
             "type": ["限时优惠","限时减免"].pop(random.randint(0,1)), # 优惠类型
             "expire": random.randint(100000, 1200000),  #  优惠倒计时
             "price": float(self.price) - random.randint(1,10) * 10,  # 优惠价格
         }
 
 
     def discount_json(self):
         # 必须转成字符串才能保存到es中。所以该方法提供给es使用的。
         return json.dumps(self.discount)
```



#### 全文索引字段模板

全文索引模板必须先配置django项目中的TEMPLATES模板引擎，而且全文索引模板的路径必须是模板目录下的`search/indexes/子应用目录名/模型类名_text.txt`。否则报错。settings.dev，代码：

```python
 TEMPLATES = [
     {
         'BACKEND': 'django.template.backends.django.DjangoTemplates',
         'DIRS': [
             BASE_DIR / "templates",  # BASE_DIR 是apps的父级目录，是主应用目录，templates需要手动创建
         ],
         'APP_DIRS': True,
         'OPTIONS': {
             'context_processors': [
                 'django.template.context_processors.debug',
                 'django.template.context_processors.request',
                 'django.contrib.auth.context_processors.auth',
                 'django.contrib.messages.context_processors.messages',
             ],
         },
     },
 ]
```

创建全文索引字段的html模板，在HTML模板中采用django的模板语法，绑定text与其他es单字段索引的映射关系。

注意：course_text.txt 中course就是ORM模型类名小写，text就是es索引模型类中的全文索引字段名。

templates/search/indexes/courses/course_text.txt。代码：

```django
 {{ object.name }}
 {{ object.description }}
 {{ object.teacher.name }}
 {{ object.category.name }}
 {{ object.direction.name }}
```

object表示当前orm的模型对应。

### 索引序列化器

courses/serializers.py，代码：

```python
 from drf_haystack.serializers import HaystackSerializer
 from .search_indexes import CourseIndex
 
 class  CourseIndexHaystackSerializer(HaystackSerializer):
     """课程搜索的序列化器"""
     class Meta:
         index_classes = [CourseIndex]
         fields = ["text", "id", "name", "course_cover", "get_level_display", "students", "get_status_display", "pub_lessons", "price", "discount", "orders"]
 
     def to_representation(self, instance):
         """用于指定返回数据的字段的"""
         # 课程的图片，在这里通过elasticsearch提供的，所以不会提供图片地址左边的域名的。因此在这里手动拼接
         instance.course_cover = f'https://{settings.OSS_BUCKET_NAME}.{settings.OSS_ENDPOINT}/uploads/{instance.course_cover}'
        return super().to_representation(instance)
```



### 全文搜索的索引视图

```python
 from drf_haystack.viewsets import HaystackViewSet
 from drf_haystack.filters import HaystackFilter
 from .serializers import CourseIndexHaystackSerializer
 from .models import Course
 
 class CourseSearchViewSet(HaystackViewSet):
     # 指定本次搜索的最终真实数据的保存模型
     index_models = [Course]
     serializer_class = CourseIndexHaystackSerializer
     filter_backends = [OrderingFilter, HaystackFilter]
     ordering_fields = ('id', 'students', 'orders')
     pagination_class = CourseListPageNumberPagination
```

### 路由

```python
 from django.urls import path,re_path
 from . import views
 
 from rest_framework import routers

 router = routers.DefaultRouter()

 router.register("search", views.CourseSearchViewSet, basename="course-search")
 
 urlpatterns = [
     path("directions/", views.CourseDirectionListAPIView.as_view()),
     re_path("^categories/(?P<direction>\d+)/$", views.CourseCategoryListAPIView.as_view()),
     re_path("^(?P<direction>\d+)/(?P<category>\d+)/$", views.CourseListAPIView.as_view()),
 ] + router.urls
```

### es构建索引

因为此前mysql中已经有了部分的数据，而这部分数据在es中是没有创建索引。所以需要先把之前的数据同步生成全文索引。在终端下执行以下命令

```bash
 # 重建索引
 python manage.py rebuild_index
 
 # 更新索引
 python manage.py update_index --age=<num_hours>
 
 # 删除索引
 python manage.py clear_index
```

访问

http://api.fuguang.cn:8000/courses/search/?text=入门

http://api.fuguang.cn:8000/courses/search/?text=李老师

## 客户端实现课程搜索

api/course.js，代码：

```javascript
import http from "../utils/http";
import {reactive, ref} from "vue";

const course = reactive({
    // 其他代码省略....
    text: "",         // 搜索文本框内容
    // 中间代码省略....
    search_course() {
        // 课程搜索
        let params = {
            page: this.page,
            size: this.size,
            text: this.text,
        }
        if (this.ordering) {
            params['ordering'] = this.ordering
        }
        return http.get(`/courses/search`, {
            params,
        })
    }
});

export default course;
```

views/Course.vue，代码：

```vue
                <div class="actual-header-search">
                    <div class="search-inner">
                        <input class="actual-search-input" v-model="course.text" placeholder="搜索感兴趣的实战课程内容" type="text" autocomplete="off">
                        <img class="actual-search-button" src="../assets/search.svg" @click.prevent.stop="get_course_list" />
                    </div>
                    <div class="actual-searchtags">
                    </div>
                    <div class="search-hot">
                        <span>热搜：</span>
                        <a href="">Java工程师</a>
                        <a href="">Vue</a>
                    </div>
                </div>
```

```vue
<script setup>
import {watch} from "vue";
import Header from "../components/Header.vue"
import Footer from "../components/Footer.vue"
import course from "../api/course";
import {fill0} from "../utils/func";
course.get_course_direction().then(response=>{
  // 获取学习方向
  course.direction_list = response.data;
})


const get_category = ()=>{
  // 获取课程分类

  // 重置当前选中的课程分类
  course.current_category=0;

  course.get_course_category().then(response=>{
    course.category_list = response.data;
  })
}

get_category();

const get_course_list = ()=>{
  // 获取课程列表
  let ret  = null // 预设一个用于保存服务端返回的数据
  if(course.text) {
    ret = course.search_course()
  }else{
    ret = course.get_course_list()
  }
  ret.then(response=>{
    course.course_list = response.data.results;
    // 总数据量
    course.count = response.data.count;
    course.has_perv = !!response.data.previous; // !!2个非表示把数据转换成布尔值
    course.has_next = !!response.data.next;

    // 优惠活动的倒计时
    course.start_timer();
  })
}

get_course_list();

watch(
    // 监听切换不同的学习方向
    ()=> course.current_direction,
    ()=>{
        // 重置搜索文本框
        course.text = "";
        // 重置页码
        course.page = 1;
        // 重置排序条件
        course.ordering = "-id";

        get_category();
        get_course_list();
    }
)

watch(
    // 监听切换不同的课程分类
    ()=> course.current_category,
    ()=>{
        // 重置搜索文本框
        course.text = "";
        // 重置页码
        course.page = 1;
        // 重置排序条件
        course.ordering = "-id";
        get_course_list();
    }
)

watch(
    // 监听课程切换不同的排序条件
    ()=>course.ordering,
    ()=>{
        // 重置页码
        course.page = 1;
        get_course_list();
    }
)

// 监听页码
watch(
    ()=>course.page,
    ()=>{
        // 重新获取课程信息
        get_course_list();
    }
)

</script>
```



## 热门搜索关键字

### 服务端实现搜索关键字的api接口

在用户搜索课程内容时，提供一个单独的redis仓库使用zset有序集合进行存储热门关键字.

settings/dev.py，代码：

```python
# redis configration
# https://django-redis-chs.readthedocs.io/zh_CN/latest/#
# 设置redis缓存
CACHES = {
    # 默认缓存
    "default": {
        "BACKEND": "django_redis.cache.RedisCache",
        # 项目上线时,需要调整这里的路径
        "LOCATION": "redis://:123456@127.0.0.1:6379/0",
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        }
    },
    # 提供给admin站点的session存储
    "session": {
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": "redis://:123456@127.0.0.1:6379/1",
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        }
    },
    # 提供存储短信验证码
    "sms_code":{
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": "redis://:123456@127.0.0.1:6379/2",
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        }
    },
    # 提供存储搜索热门关键字
    "hot_word": {
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": "redis://:123456@127.0.0.1:6379/3",
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        }
    },
}
```

settings/constants.py中，配置有序集合中代表了课程搜索的key值。settings/constants.py，代码：

```python
# 设置热门搜索关键字在redis中的key前缀名称
DEFAULT_HOT_WORD = "hot_word"
# 设置返回的热门搜索关键字的数量
HOT_WORD_LENGTH = 5
# 设置热门搜索关键字的有效期时间[单位：天]
HOT_WORD_EXPIRE = 7
```

视图代码中，在用户每次搜索内容时给对应的搜索关键字增加搜索权重[score]，`courses/views.py`，代码：

```python

from drf_haystack.viewsets import HaystackViewSet
from drf_haystack.filters import HaystackFilter
from .serializers import CourseIndexHaystackSerializer
from .models import Course
from django_redis import get_redis_connection
from datetime import datetime
import constants


class CourseSearchViewSet(HaystackViewSet):
    # 指定本次搜索的最终真实数据的ORM模型
    index_models = [Course]
    serializer_class = CourseIndexHaystackSerializer
    filter_backends = [OrderingFilter, HaystackFilter]
    ordering_fields = ('id', 'students', 'orders')
    pagination_class = CourseListPageNumberPagination

    def list(self, request, *args, **kwargs):
        redis = get_redis_connection("hot_word")
        text = request.query_params.get("text")
        if text:
            key = f"{constants.DEFAULT_HOT_WORD}:{datetime.now().strftime('%Y:%m:%d')}"
            is_exists = redis.exists(key)
            # zincrby course 1 mongodb
            redis.zincrby(key, 1, text)
            if not is_exists:
                redis.expire(key, constants.HOT_WORD_EXPIRE  * 24 * 3600)

        return super().list(request, *args, **kwargs)

```

视图提供热门搜索关键字列表的api接口，`courses/views.py`，代码：

```python

from rest_framework.views import APIView
from rest_framework.response import Response
from datetime import datetime, timedelta


class HotWordAPIView(APIView):
    """搜索热词"""
    def get(self, request):
        redis = get_redis_connection("hot_word")
        # 获取最近指定天数的热词的key
        date_list = []
        for i in range(0, constants.HOT_WORD_EXPIRE):
            day = datetime.now() - timedelta(days=i)
            key = f"{constants.DEFAULT_HOT_WORD}:{day.year}:{day.month}:{day.day}"
            date_list.append(key)

        # 先删除原有的统计最近几天的热搜词的有序统计集合
        redis.delete(constants.DEFAULT_HOT_WORD)
        # ZUNIONSTORE hot_word 7 "hot_word:2021:11:22" "hot_word:2021:11:21"  "hot_word:2021:11:20" "hot_word:2021:11:19" "hot_word:2021:11:18" "hot_word:2021:11:17" "hot_word:2021:11:16"
        # 根据date_list找到最近指定天数的所有集合，并完成并集计算，产生新的有序统计集合constants.DEFAULT_HOT_WORD
        redis.zunionstore(constants.DEFAULT_HOT_WORD, date_list, aggregate="sum")
        # 按分数store进行倒序显示排名靠前的指定数量的热词
        word_list = redis.zrevrange(constants.DEFAULT_HOT_WORD, 0, constants.HOT_WORD_LENGTH-1)
        return Response(word_list)

```

路由，`course.views`，代码：

```python
from django.urls import path,re_path
from . import views

from rest_framework import routers
router = routers.DefaultRouter()
# 注册全文搜索到视图集中生成url路由信息
router.register("search", views.CourseSearchViewSet, basename="course-search")

urlpatterns = [
    path("directions/", views.CourseDirectionListAPIView.as_view()),
    re_path("^categories/(?P<direction>\d+)/$", views.CourseCategoryListAPIView.as_view()),
    re_path("^(?P<direction>\d+)/(?P<category>\d+)/$", views.CourseListAPIView.as_view()),
    path("hot_word/", views.HotWordAPIView.as_view()),
] + router.urls

```

> 这里可以修改下系统的时间，修改为前一天通过后端搜索视图造一些数据在redis中，然后改回今天，在造一些数据，然后通过热词视图验证代码

客户端在用户进入页面时，直接显示当前的热门搜索关键字。

`api/course.js`，代码：

```javascript
import http from "../utils/http";
import {reactive, ref} from "vue";

const course = reactive({
    // .... 中间代码省略
    hot_word_list: [],// 热搜词列表
    // .... 中间代码省略
    get_hot_word(){
        // 课程热搜关键字
        return http.get("/courses/hot_word")
    }
});

export default course;
```

`views/Course.vue`，代码：

```vue
                <div class="actual-header-search">
                    <div class="search-inner">
                        <input class="actual-search-input" v-model="course.text" placeholder="搜索感兴趣的实战课程内容" type="text" autocomplete="off">
                        <img class="actual-search-button" src="../assets/search.svg" @click.prevent.stop="get_course_list" />
                    </div>
                    <div class="actual-searchtags">
                    </div>
                    <div class="search-hot">
                        <span>热搜：</span>
                        <a href="" @click.stop.prevent="course.text=hot_word" v-for="hot_word in course.hot_word_list">{{hot_word}}</a>
                    </div>
                </div>
```

```vue
<script setup>
import {watch} from "vue";
import Header from "../components/Header.vue"
import Footer from "../components/Footer.vue"
import course from "../api/course";
import {fill0} from "../utils/func";
course.get_course_direction().then(response=>{
  // 获取学习方向
  course.direction_list = response.data;
})


const get_category = ()=>{
  // 获取课程分类

  // 重置当前选中的课程分类
  course.current_category=0;

  course.get_course_category().then(response=>{
    course.category_list = response.data;
  })
}

get_category();

const get_hot_word = ()=>{
  // 搜索热门关键字列表
  course.get_hot_word().then(response=>{
    course.hot_word_list = response.data
  })
}

const get_course_list = ()=>{
  // 获取课程列表
  let ret  = null // 预设一个用于保存服务端返回的数据
  if(course.text) {
    ret = course.search_course()
  }else{
    ret = course.get_course_list()
  }
  ret.then(response=>{
    course.course_list = response.data.results;
    // 总数据量
    course.count = response.data.count;
    course.has_perv = !!response.data.previous; // !!2个非表示把数据转换成布尔值
    course.has_next = !!response.data.next;

    // 优惠活动的倒计时
    course.start_timer();
  })

  // 获取热手词列表
  get_hot_word();
}

get_course_list();

get_hot_word();

watch(
    // 监听切换不同的学习方向
    ()=> course.current_direction,
    ()=>{
        // 重置搜索文本框
        course.text = "";
        // 重置页码
        course.page = 1;
        // 重置排序条件
        course.ordering = "-id";

        get_category();
        get_course_list();
    }
)

watch(
    // 监听切换不同的课程分类
    ()=> course.current_category,
    ()=>{
        // 重置搜索文本框
        course.text = "";
        // 重置页码
        course.page = 1;
        // 重置排序条件
        course.ordering = "-id";
        get_course_list();
    }
)

watch(
    // 监听课程切换不同的排序条件
    ()=>course.ordering,
    ()=>{
        // 重置页码
        course.page = 1;
        get_course_list();
    }
)

// 监听页码
watch(
    ()=>course.page,
    ()=>{
        // 重新获取课程信息
        get_course_list();
    }
)

</script>
```



关于头部的搜索框，可以采用父子组件传递参数的方式来实现。

如果没有父组件不是Course.vue，则通过vue-router进行页面跳转，跳转之前，把用户搜索的参数保存在地址栏，当页面跳转完成以后，可以在script标签中，vue-router提供的route对象获取地址栏参数，进行赋值course.text=地址栏参数，还接着客户端发送请求即可。

