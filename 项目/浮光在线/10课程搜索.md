# 课程搜索

## elasticsearch

Elasticsearch是一个基于[Lucene](https://baike.baidu.com/item/Lucene/6753302)的搜索服务器，也是属于NoSQL阵营的数据库。它提供了一个分布式多用户能力的[全文搜索引擎](https://baike.baidu.com/item/全文搜索引擎/7847410)，基于RESTful web接口。Elasticsearch是用Java语言开发的，并作为Apache许可条款下的开放源码发布，是一种流行的企业级搜索引擎。除了es以外， Sphinx 、迅搜、Zebra、Solr 、Whoosh。 

官网：https://www.elastic.co/cn/elasticsearch/

中文文档：https://www.elastic.co/guide/cn/index.html

## podman安装elasticsearch

支持单点部署和集群部署。

```bash
 # 从课件的素材中找到es的镜像压缩包，复制到ubuntu桌面下，执行以下命令
 # sudo docker load -i ~/Desktop/elasticsearch.7.13.4.tar.gz
 podman load -i ~/Desktop/elasticsearch.7.13.4.tar.gz
 # 也可以不执行上面的操作，直接run可以让docker从官网拉取es镜像。
 
 # sudo docker run --name elasticsearch --restart=always -d -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS="-Xms256m -Xmx256m" -e "discovery.type=single-node" elasticsearch:7.13.4
 
 podman run --name elasticsearch -d -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS="-Xms512m -Xmx512m" -e "discovery.type=single-node" elasticsearch:7.13.4
```

参数说明

```
 --name elasticsearch  
        设置当前容器的容器名称为elasticsearch
 --restart=always
        设置容器开机自启，即便物理机关机重启了，docker在启动以后也会自动帮我们把当前容器启动起来。
 -d     设置当前容器为守护式容器，在后台运行
 -p 9200:9200
        设置端口影射，<物理机端口>:<容器端口>
        表示访问了当前物理机的9200，相当于访问了当前容器的9200端口
 -p 9300:9300
        设置端口影射，<物理机端口>:<容器端口>
        表示访问了当前物理机的9300，相当于访问了当前容器的9300端口
 -e ES_JAVA_OPTS="-Xms256m -Xmx256m"
        设置环境变量，变量名为ES_JAVA_OPTS,这个变量是启动elasticsearch的关键。
        表示设置java环境的最小和最大使用内存，内存不足，elasticsearch是无法启动的，所以此处设置为最大内存256M
 -e "discovery.type=single-node"
        设置环境变量，变量名discovery.type
        discovery.type 表示当前elasticsearch的运作模式为single-node，表示单机部署/单点部署
 elasticsearch:7.13.4
        设置当前容器的镜像名和版本号
```

浏览器访问：http://127.0.0.1:9200

要基于es实现全文搜索，可以参考以下文档了解关于全文搜索的内容，。

https://www.elastic.co/guide/cn/elasticsearch/guide/current/full-text-search.html

全文搜索的实现，必须依靠es内部调用分词器对语句进行词性分析，拆词，给每一个单词构建一个索引。

所以默认情况下，es只提供了标准分析器，和简单分析器，这几块分词器都是只能针对英文进行分词。



### IK中文分词器

默认情况下，elasticsearch是外国开发的，所以本身对于中文分词构建分词索引的支持是不行的。所以我们需要在elasticsearch软件中新增一个支持中文索引和中文分词的插件，叫ik分词器。

注意：IK分词器插件的版本必须与elasticsearch的版本号同步。否则安装失败！

文档：https://github.com/medcl/elasticsearch-analysis-ik/releases

把IK分词器解压并复制到elasticsearch容器的/usr/share/elasticsearch/plugins目录下

```bash
 unzip ~/Desktop/elasticsearch-analysis-ik-7.13.4.zip -d ~/Desktop/ik-7.13.4
 podman cp ~/Desktop/ik-7.13.4 elasticsearch:/usr/share/elasticsearch/plugins
 podman stop elasticsearch
 podman start elasticsearch
```

注意：elasticsearch内部极其复杂，所以启动容器以后需要等待1分钟左右才对外提供搜索服务。

接下来，我们就可以通过postman测试

post http://localhost:9200/_analyze?pretty

基于智能分词模式来查询分析词性，json数据

```json
 {
    "analyzer":"ik_smart",
    "text":"我是中国人"    
 }
```

基于最大分词模式来查询分析词性，json数据

```json
 {
    "analyzer":"ik_max_word",
    "text":"我是中国人"  
 }
```



## 安装haystack

haystack是django的开源搜索框架，能够结合目前市面上大部分的搜索引擎用于实现自定义搜索功能，特别是全文搜索。

haystack支持多种搜索引擎，不仅仅是 jieba ，whoosh，使用solr、elasticsearch等搜索，也可通过haystack，而且直接切换引擎即可，甚至无需修改搜索代码。中文分词最好的就是jieba和elasticsearch+ik。

github： https://github.com/rhblind/drf-haystack

```bash
 # python操作elasticsearch的模块，注意对应版本
 pip install -U elasticsearch==7.13.4
 # django开发的haystack的模块，务必先安装drf-haystack，接着才安装django-haystack。因为drf-haystack不支持es7
 pip install -U drf-haystack
 pip install -U django-haystack
```



## 基本使用

### 安装配置

文档：https://drf-haystack.readthedocs.io/en/latest/01_intro.html#examples

```python
 INSTALLED_APPS = [
     # 必须在自己创建的子应用前面
     'haystack',
 
     # 自己创建的子应用
 ]
 
 # haystack连接elasticsearch的配置信息
 HAYSTACK_CONNECTIONS = {
     'default': {
         # haystack操作es的核心模块
         'ENGINE': 'haystack.backends.elasticsearch7_backend.Elasticsearch7SearchEngine',
         # es服务端地址
         'URL': 'http://127.0.0.1:9200/',
         # es索引仓库
         'INDEX_NAME': 'haystack',
     },
 }
 
 # 当ORM操作数据库改变时，自动更新es的索引，否则es的索引会找不到新增的数据
 HAYSTACK_SIGNAL_PROCESSOR = 'haystack.signals.RealtimeSignalProcessor'
```



### 索引模型

在courses子应用下创建search_indexes.py，用于设置es的索引模型。注意，索引模型的文件名必须是search_indexes。

```python
 from haystack import indexes
 from .models import Course
 
 class CourseIndex(indexes.SearchIndex, indexes.Indexable):
     # 全文索引[可以根据配置，可以包括多个字段索引]
     # document=True 表示当前字段为全文索引
     # use_template=True 表示接下来haystack需要加载一个固定路径的html模板文件，让text与其他索引字段绑定映射关系
     text = indexes.CharField(document=True, use_template=True)
     # 普通索引[单字段，只能提供单个字段值的搜索，所以此处的声明更主要是为了提供给上面的text全文索引使用的]
     # es索引名 = indexes.索引数据类型(model_attr="ORM中的字段名")
     id = indexes.IntegerField(model_attr="id")
     name = indexes.CharField(model_attr="name")
     description = indexes.CharField(model_attr="description")
     teacher = indexes.CharField(model_attr="teacher__name")
     course_cover = indexes.CharField(model_attr="course_cover")
     get_level_display=indexes.CharField(model_attr="get_level_display")
     students=indexes.IntegerField(model_attr="students")
     get_status_display=indexes.CharField(model_attr="get_status_display")
     lessons=indexes.IntegerField(model_attr="lessons")
     pub_lessons=indexes.IntegerField(model_attr="pub_lessons")
     price=indexes.DecimalField(model_attr="price")
     discount=indexes.CharField(model_attr="discount_json")
     orders=indexes.IntegerField(model_attr="orders")
 
     # 指定与当前es索引模型对接的mysql的ORM模型
     def get_model(self):
         return Course
 
     # 当用户搜索es索引时，对应的提供的mysql数据集有哪些？
     def index_queryset(self, using=None):
         return self.get_model().objects.filter(is_delete=False,is_show=True)
 
 
```



#### 模型中新增discount_json字段方法

courses.models，代码：

```python
 import json
 
 class Course(BaseModel):
     course_type = (
         (0, '付费购买'),
         (1, '会员专享'),
         (2, '学位课程'),
     )
     level_choices = (
         (0, '初级'),
         (1, '中级'),
         (2, '高级'),
     )
     status_choices = (
         (0, '上线'),
         (1, '下线'),
         (2, '预上线'),
     )
     # course_cover = models.ImageField(upload_to="course/cover", max_length=255, verbose_name="封面图片", blank=True, null=True)
     course_cover = StdImageField(variations={
         'thumb_1080x608': (1080, 608),   # 高清图
         'thumb_540x304': (540, 304),    # 中等比例,
         'thumb_108x61': (108, 61, True),  # 小图(第三个参数表示保持图片质量),
     }, max_length=255, delete_orphans=True, upload_to="course/cover", null=True, verbose_name="封面图片",blank=True)
     course_video = models.FileField(upload_to="course/video", max_length=255, verbose_name="封面视频", blank=True, null=True)
     course_type = models.SmallIntegerField(choices=course_type,default=0, verbose_name="付费类型")
     level = models.SmallIntegerField(choices=level_choices, default=1, verbose_name="难度等级")
     description = RichTextUploadingField(null=True, blank=True, verbose_name="详情介绍")
     pub_date = models.DateField(auto_now_add=True, verbose_name="发布日期")
     period = models.IntegerField(default=7, verbose_name="建议学习周期(day)")
     attachment_path = models.FileField(max_length=1000, blank=True, null=True, verbose_name="课件路径")
     attachment_link = models.CharField(max_length=1000, blank=True, null=True, verbose_name="课件链接")
     status = models.SmallIntegerField(choices=status_choices, default=0, verbose_name="课程状态")
     students = models.IntegerField(default=0, verbose_name="学习人数")
     lessons = models.IntegerField(default=0, verbose_name="总课时数量")
     pub_lessons = models.IntegerField(default=0, verbose_name="已更新课时数量")
     price = models.DecimalField(max_digits=10,decimal_places=2, verbose_name="课程原价",default=0)
     recomment_home_hot = models.BooleanField(default=False, verbose_name="是否推荐到首页新课栏目")
     recomment_home_top = models.BooleanField(default=False, verbose_name="是否推荐到首页必学栏目")
     direction = models.ForeignKey("CourseDirection", related_name="course_list", on_delete=models.DO_NOTHING, null=True, blank=True, db_constraint=False, verbose_name="学习方向")
     category = models.ForeignKey("CourseCategory", related_name="course_list", on_delete=models.DO_NOTHING, null=True, blank=True, db_constraint=False, verbose_name="课程分类")
     teacher = models.ForeignKey("Teacher", related_name="course_list", on_delete=models.DO_NOTHING, null=True, blank=True, db_constraint=False, verbose_name="授课老师")
 
     class Meta:
         db_table = "fg_course_info"
         verbose_name = "课程信息"
         verbose_name_plural = verbose_name
 
     def course_cover_small(self):
         if self.course_cover:
             return mark_safe(f'<img style="border-radius: 0%;" src="{self.course_cover.thumb_108x61.url}">')
         return ""
 
     course_cover_small.short_description = "封面图片(108x61)"
     course_cover_small.allow_tags = True
     course_cover_small.admin_order_field = "course_cover"
 
     def course_cover_medium(self):
         if self.course_cover:
             return mark_safe(f'<img style="border-radius: 0%;" src="{self.course_cover.thumb_540x304.url}">')
         return ""
 
     course_cover_medium.short_description = "封面图片(540x304)"
     course_cover_medium.allow_tags = True
     course_cover_medium.admin_order_field = "course_cover"
 
     def course_cover_large(self):
         if self.course_cover:
             return mark_safe(f'<img style="border-radius: 0%;" src="{self.course_cover.thumb_1080x608.url}">')
         return ""
 
     course_cover_large.short_description = "封面图片(1080x608)"
     course_cover_large.allow_tags = True
     course_cover_large.admin_order_field = "course_cover"
 
     @property
     def discount(self):
         # todo 将来通过计算获取当前课程的折扣优惠相关的信息
         return {
             "type": ["限时优惠","限时减免"].pop(random.randint(0,1)), # 优惠类型
             "expire": random.randint(100000, 1200000),  #  优惠倒计时
             "price": float(self.price) - random.randint(1,10) * 10,  # 优惠价格
         }
 
 
     def discount_json(self):
         # 必须转成字符串才能保存到es中。所以该方法提供给es使用的。
         return json.dumps(self.discount)
```



#### 全文索引字段模板

全文索引模板必须先配置django项目中的TEMPLATES模板引擎，而且全文索引模板的路径必须是模板目录下的`search/indexes/子应用目录名/模型类名_text.txt`。否则报错。settings.dev，代码：

```python
 TEMPLATES = [
     {
         'BACKEND': 'django.template.backends.django.DjangoTemplates',
         'DIRS': [
             BASE_DIR / "templates",  # BASE_DIR 是apps的父级目录，是主应用目录，templates需要手动创建
         ],
         'APP_DIRS': True,
         'OPTIONS': {
             'context_processors': [
                 'django.template.context_processors.debug',
                 'django.template.context_processors.request',
                 'django.contrib.auth.context_processors.auth',
                 'django.contrib.messages.context_processors.messages',
             ],
         },
     },
 ]
```

创建全文索引字段的html模板，在HTML模板中采用django的模板语法，绑定text与其他es单字段索引的映射关系。

注意：course_text.txt 中course就是ORM模型类名小写，text就是es索引模型类中的全文索引字段名。

templates/search/indexes/courses/course_text.txt。代码：

```django
 {{ object.name }}
 {{ object.description }}
 {{ object.teacher.name }}
 {{ object.category.name }}
 {{ object.diretion.name }}
```

object表示当前orm的模型对应。

### 索引序列化器

courses/serializers.py，代码：

```python
 from drf_haystack.serializers import HaystackSerializer
 from .search_indexes import CourseIndex
 
 class  CourseIndexHaystackSerializer(HaystackSerializer):
     """课程搜索的序列化器"""
     class Meta:
         index_classes = [CourseIndex]
         fields = ["text", "id", "name", "course_cover", "get_level_display", "students", "get_status_display", "pub_lessons", "price", "discount", "orders"]
 
     def to_representation(self, instance):
         """用于指定返回数据的字段的"""
         # 课程的图片，在这里通过elasticsearch提供的，所以不会提供图片地址左边的域名的。因此在这里手动拼接
         instance.course_cover = f'//{self.context["request"]._request.META["HTTP_HOST"]}/uploads/{instance.course_cover}'
         return super().to_representation(instance)
```



### 全文搜索的索引视图

```python
 from drf_haystack.viewsets import HaystackViewSet
 from drf_haystack.filters import HaystackFilter
 from .serializers import CourseIndexHaystackSerializer
 from .models import Course
 
 class CourseSearchViewSet(HaystackViewSet):
     # 指定本次搜索的最终真实数据的保存模型
     index_models = [Course]
     serializer_class = CourseIndexHaystackSerializer
     filter_backends = [OrderingFilter, HaystackFilter]
     ordering_fields = ('id', 'students', 'orders')
     pagination_class = CourseListPageNumberPagination
```

### 路由

```python
 from django.urls import path,re_path
 from . import views
 
 from rest_framework import routers

 router = routers.DefaultRouter()

 router.register("search", views.CourseSearchViewSet, basename="course-search")
 
 urlpatterns = [
     path("directions/", views.CourseDirectionListAPIView.as_view()),
     re_path("^categories/(?P<direction>\d+)/$", views.CourseCategoryListAPIView.as_view()),
     re_path("^(?P<direction>\d+)/(?P<category>\d+)/$", views.CourseListAPIView.as_view()),
 ] + router.urls
```

### es构建索引

因为此前mysql中已经有了部分的数据，而这部分数据在es中是没有创建索引。所以需要先把之前的数据同步生成全文索引。在终端下执行以下命令

```bash
 # 重建索引
 python manage.py rebuild_index
 
 # 更新索引
 python manage.py update_index --age=<num_hours>
 
 # 删除索引
 python manage.py clear_index
```

访问

http://api.fuguang.cn:8000/courses/search/?text=入门

http://api.fuguang.cn:8000/courses/search/?text=李老师