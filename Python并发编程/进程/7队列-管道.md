# 进程间的通信（管道和队列）

我们知道进程之间数据是相互隔离的，要想实现进程间的通信(IPC机制)，就必须借助于一些技术才可以。比如multiprocessing模块中的：队列和管道，这两种方式都是可以实现进程间数据传输的，由于队列是管道+锁的方式实现，所以我们着重研究队列即可

## 管道

+ 导入

  ```python
  from multiprocessing import Pipe
  ```

+ 创建管道对象

  ```python
  a, b = Pipe()
  ```

  

+ 方法

  + send  发送数据
  + recv    接收数据

+ 实现

```python
from multiprocessing import Pipe, Process


def fun(a):
# 获取管道a
a.send(list(range(10)))
print('我在子进程接收主进程数据', a.recv())



if __name__ == '__main__':
a, b = Pipe()
p = Process(target=fun, args=(a,))
p.start()
b.send(['a', 'b', 'c'])
p.join()
# 接收数据
print('在主进程接收子进程传递数据', b.recv())
```

  


## 队列概念

创建共享的进程队列，Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。

大白话总结一下就是队列支持多个人从队列的一端放入数据，同样支持多个人从队列的另一端取数据

### 基本用法

+ 导入

  ```python
  from multiprocessing import Queue
  ```

+ 参数

  ```
  Queue([maxsize]) # 创建共享的进程队列 队列底层使用管道和锁定实现。
  ```

  maxsize是队列中允许的最大项数。如果省略此参数，则无大小限制。

+ 常用方法

  + put()   压入数据

  + get(block=True, timeout=None)    获取数据

    block 默认阻塞模式  如果当前的队列中没有数据 则阻塞等待 False则直接抛出异常

    timeout  如果没有数据则阻塞  如果给定timeout时间参数  则会等待对应的秒数 若依然没有数据 则抛出异常

+ 特点  先进先出


### 代码实现

```python
from multiprocessing import Queue
q=Queue(3)  # 创建一个最大只能容纳3个数据的队列
"""
常用方法
put ,get ,put_nowait,get_nowait,full,empty
"""
q.put(3)  # 往队列中存放数据
q.put(3)
q.put(3)


q.put(3)  # 如果队列已经满了，程序就会停在这里，等待数据被别人取走，再将数据放入队列。如果队列中的数据一直不被取走，程序就会永远停在这里。
try:
    q.put_nowait(3) # 可以使用put_nowait，如果队列满了不会阻塞，但是会因为队列满了而报错。
except:  # 因此我们可以用一个try语句来处理这个错误。这样程序不会一直阻塞下去，但是会丢掉这个消息。
    print('队列已经满了')
    

# 因此，我们再放入数据之前，可以先看一下队列的状态，如果已经满了，就不继续put了。
print(q.full())  # 判断队列中数据是否已存放满了

print(q.get())  # 从队列中获取数据
print(q.get())
print(q.get())


print(q.get()) # 同put方法一样，如果队列已经空了，那么继续取就会出现阻塞。
try:
    q.get_nowait(3) # 可以使用get_nowait，如果队列满了不会阻塞，但是会因为没取到值而报错。
except: # 因此我们可以用一个try语句来处理这个错误。这样程序不会一直阻塞下去。
    print('队列已经空了')

    
print(q.empty())  # 判断队列中数据是否已经被全部取出
```

### 基于队列实现进程间通信

```python
import time
from multiprocessing import Process, Queue
def f(q):
    q.put('hello')  #调用主函数中p进程传递过来的进程参数 put函数为向队列中添加一条数据。
if __name__ == '__main__':
    q = Queue()  # 创建一个Queue对象
    p = Process(target=f, args=(q,)) #创建一个进程
    p.start()
    print(q.get())  # 从队列中获取数据
    p.join()


from multiprocessing import Queue,Process
def producer(q):
    q.put('hello big baby!')
def consumer(q):
    print(q.get())
if __name__ == '__main__':
    q = Queue()
    p = Process(target=producer,args=(q,))
    p.start()
    p1 = Process(target=consumer,args=(q,))
    p1.start()
```

## 数据共享

+ 字典共享

  + 导入

    import multiprocessing

  + 实例化创建字典

    ```python
    import multiprocessing
    
    if __name__ == '__main__':
        multiprocessing.Manager().dict()
    ```

  + 实例

    ```python
    import multiprocessing
    
    def fun(Dict):
        Dict['x'] = 'x'
        Dict['y'] = 'y'
    
    
    if __name__ == '__main__':
        myDict = multiprocessing.Manager().dict()
        p = multiprocessing.Process(target=fun, args=(myDict,))
        p.start()
        p.join()
        print(myDict)
        print('over')
    ```

+ 列表共享

  + 导入

    import multiprocessing

  + 实例化创建列表

    ```python
    import multiprocessing
    
    if __name__ == '__main__':
        multiprocessing.Manager().list()
    ```

  + 实例

    ```python
    import multiprocessing
    
    
    def fun(my_list):
        my_list.append('x')
        my_list.append('y')
        my_list.append('z')
    
    
    if __name__ == '__main__':
        my_list = multiprocessing.Manager().list()
        p = multiprocessing.Process(target=fun, args=(my_list,))
        p.start()
        p.join()
        print(my_list)
        print('over')
    ```