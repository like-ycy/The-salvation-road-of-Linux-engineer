# 序列化器 - serializer

Django REST framework 是用于构建 Web API 的强大而灵活的工具包。

您可能希望使用 REST framework 的一些原因：

- [Web 可浏览 API](https://restframework.herokuapp.com/) 对于开发人员来说是一个巨大的可用性胜利。
- [身份验证策略](http://www.iamnancy.top/djangorestframework/Authentication/)包括 [OAuth1a](https://www.django-rest-framework.org/api-guide/authentication/#django-rest-framework-oauth) 和 [OAuth2](https://www.django-rest-framework.org/api-guide/authentication/#django-oauth-toolkit) 的程序包。
- 支持 [ORM](https://www.django-rest-framework.org/api-guide/serializers#modelserializer) 和[非 ORM](https://www.django-rest-framework.org/api-guide/serializers#serializers) 数据源的[序列化](https://www.django-rest-framework.org/api-guide/serializers/)。
- 一路可自定义下去 - 如果你不需要[更强大的功能](https://www.django-rest-framework.org/api-guide/viewsets/)，只要使用[正规的基于函数的视图](https://www.django-rest-framework.org/api-guide/views#function-based-views)。
- [丰富的文档](https://www.django-rest-framework.org/)和[良好的社区支持](https://groups.google.com/forum/?fromgroups#!forum/django-rest-framework)。
- 受到国际知名公司的使用和信任，包括 [Mozilla](https://www.mozilla.org/en-US/about/)，[Red Hat](https://www.redhat.com/)，[Heroku](https://www.heroku.com/) 和 [Eventbrite](https://www.eventbrite.co.uk/about/)。

**作用：**

- 序列化,序列化器会把模型对象转换成字典，经过response以后变成json字符串
- 反序列化，把客户端发送过来的数据，经过request以后变成字典，序列化器可以把字典转成模型
- 反序列化，完成数据校验功能

## 序列化器的定义

Django RESTful framework中的Serializer使用类来定义，须继承自rest_framework.serializers.Serializer。

##### 1、创建子应用 sers

```
python manage.py startapp sers
```

在settings.py 中添加应用

```
INSTALLED_APPS = [
  	.........
    'sers',
]
```



##### 2、创建模型类

```python
from django.db import models

class Student(models.Model):
    # 模型字段
    name = models.CharField(max_length=100,verbose_name="姓名",help_text="提示文本:账号不能为空！")
    sex = models.BooleanField(default=True,verbose_name="性别")
    age = models.IntegerField(verbose_name="年龄")
    class_null = models.CharField(max_length=5,verbose_name="班级编号")
    description = models.TextField(verbose_name="个性签名")

    class Meta:
        db_table="tb_student"
        verbose_name = "学生"
        verbose_name_plural = verbose_name
```

##### 3、创建序列化器类

```python
rom rest_framework import serializers
"""
serializers 是drf提供给开发者调用的序列化器模块
里面声明了所有的可用序列化器的基类：
Serializer      序列化器基类，drf中所有的序列化器类都必须继承于 Serializer
ModelSerializer 模型序列化器基类，是序列化器基类的子类，在工作中，除了Serializer基类以外，最常用的序列化器类基类
"""

class StudentSerializer1(serializers.Serializer):
    """学生信息序列化器"""
    # 1. 转换的字段声明
    # 字段 = serializers.字段类型(选项=选项值,)
    id = serializers.IntegerField()
    name = serializers.CharField()
    sex = serializers.BooleanField()
    age = serializers.IntegerField()
    classmate = serializers.CharField()
    description = serializers.CharField()

    # 2. 如果当前序列化器继承的是ModelSerializer，则需要声明调用的模型信息
    # class Meta:
    #     model = 模型
    #     fields = ["字段1","字段2",....]

    # 3. 验证代码的对象方法
    # def validate(self, attrs): # validate是固定的
    #     pass
    #     return attrs

    # def validate_<字段名>(self, data):  # 方法名的格式必须以 validate_<字段名> 为名称，否则序列化器不识别！
    #     pass
    #     return data_

    # 4. 模型操作的方法，
    # def create(self, validated_data):  # 添加数据操作，添加数据以后，就自动实现了从字典变成模型对象的过程
    #     pass
    #
    # def update(self, instance, validated_data): # 更新数据操作，更新数据以后，就自动实现了从字典变成模型对象的过程
    #     pass
```

## serializer 常用字段类型：

| 字段                    | 字段构造方式                                                 |
| ----------------------- | ------------------------------------------------------------ |
| **BooleanField**        | BooleanField()                                               |
| **NullBooleanField**    | NullBooleanField()                                           |
| **CharField**           | CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True) |
| **EmailField**          | EmailField(max_length=None, min_length=None, allow_blank=False) |
| **RegexField**          | RegexField(regex, max_length=None, min_length=None, allow_blank=False) |
| **SlugField**           | SlugField(max*length=50, min_length=None, allow_blank=False) 正则字段，验证正则模式 [a-zA-Z0-9*-]+ |
| **URLField**            | URLField(max_length=200, min_length=None, allow_blank=False) |
| **UUIDField**           | UUIDField(format='hex_verbose')  format:  1) `'hex_verbose'` 如`"5ce0e9a5-5ffa-654b-cee0-1238041fb31a"`  2） `'hex'` 如 `"5ce0e9a55ffa654bcee01238041fb31a"`  3）`'int'` - 如: `"123456789012312313134124512351145145114"`  4）`'urn'` 如: `"urn:uuid:5ce0e9a5-5ffa-654b-cee0-1238041fb31a"` |
| **IPAddressField**      | IPAddressField(protocol='both', unpack_ipv4=False, **options) |
| **IntegerField**        | IntegerField(max_value=None, min_value=None)                 |
| **FloatField**          | FloatField(max_value=None, min_value=None)                   |
| **DecimalField**        | DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None) max_digits: 最多位数 decimal_palces: 小数点位置 |
| **DateTimeField**       | DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None) |
| **DateField**           | DateField(format=api_settings.DATE_FORMAT, input_formats=None) |
| **TimeField**           | TimeField(format=api_settings.TIME_FORMAT, input_formats=None) |
| **DurationField**       | DurationField()                                              |
| **ChoiceField**         | ChoiceField(choices) choices与Django的用法相同               |
| **MultipleChoiceField** | MultipleChoiceField(choices)                                 |
| **FileField**           | FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL) |
| **ImageField**          | ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL) |
| **ListField**           | ListField(child=, min_length=None, max_length=None)          |
| **DictField**           | DictField(child=)                                            |

**选项参数：**

| 参数名称            | 作用             |
| ------------------- | ---------------- |
| **max_length**      | 最大长度         |
| **min_lenght**      | 最小长度         |
| **allow_blank**     | 是否允许为空     |
| **trim_whitespace** | 是否截断空白字符 |
| **max_value**       | 最小值           |
| **min_value**       | 最大值           |

**通用参数：**

| 参数名称           | 说明                                          |
| ------------------ | --------------------------------------------- |
| **read_only**      | 表明该字段仅用于序列化输出，默认False         |
| **write_only**     | 表明该字段仅用于反序列化输入，默认False       |
| **required**       | 表明该字段在反序列化时必须输入，默认True      |
| **default**        | 反序列化时使用的默认值                        |
| **allow_null**     | 表明该字段是否允许传入None，默认False         |
| **validators**     | 该字段使用的验证器                            |
| **error_messages** | 包含错误编号与错误信息的字典                  |
| **label**          | 用于HTML展示API页面时，显示的字段名称         |
| **help_text**      | 用于HTML展示API页面时，显示的字段帮助提示信息 |

## 创建Serializer对象

定义好Serializer类后，就可以创建Serializer对象了。

Serializer的构造方法为：

```python
StudentSerializer1(instance=None, data=empty, **kwargs)
```

说明：

1）用于序列化时，将模型类对象传入**instance**参数

2）用于反序列化时，将要被反序列化的数据传入**data**参数

3）除了instance和data参数外，在构造Serializer对象时，还可通过**context**参数额外添加数据，如

```python
serializer = StudentSerializer1(student) # 序列化单个
serializer = StudentSerializer1(student_list, many=True)  # 序列化多个
serializer = StudentSerializer1(account, context={'request': request})
```

**通过context参数附加的数据，可以通过Serializer对象的context属性获取。**



1. 使用序列化器的时候一定要注意，序列化器声明了以后，不会自动执行，需要我们在视图中进行调用才可以。
2. 序列化器无法直接接收数据，需要我们在视图中实例化序列化器对象时把使用的数据传递过来。
3. 序列化器的字段声明类似于我们前面使用过的模型。
4. 开发restful api时，序列化器会帮我们把模型对象转换成字典



## 序列化器的使用

序列化器的使用分两个阶段：

1. 在客户端请求时，使用序列化器可以完成对数据的反序列化。
2. 在服务器响应时，使用序列化器可以完成对数据的序列化。

### 序列化

接着上面定义的序列化器类，写视图类

1、创建视图类

```python
from django.views import View
from django.http.response import JsonResponse
from .serializers import StudentSerializer1
from .models import Student

class StudentView1(View):
    """序列化器"""
    def get(self,request):
        """序列化一个模型对象"""
        # 1. 获取数据集
        # student = Student.objects.first()
        # 1、获取多个数据集
        instance = Student.objects.all()
        
        # 2. 实例化序列化器，获取序列化对象
        # serializer = StudentSerializer(student)
        # 2. 实例化序列化器，获取序列化多个数据集的时候要设置 many=True
        serializer = StudentSerializer1(instance, many=True)
        
        # 3. 调用序列化对象的data属性方法获取转换后的数据
        data = serializer.data
        # 4. 响应数据
        return JsonResponse(data=data, status=200, safe=False, json_dumps_params={"ensure_ascii": False})
```

如果要被序列化的是包含多条数据的查询集QuerySet，可以通过添加**many=True**参数补充说明

2、绑定路由，子应用students/urls.py

```
from django.urls import path
from . import views

urlpatterns = [
    path('sers1/', views.StudentView1.as_view()),
]
```

主路由 url.py 中

```
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include("sers.urls")),
]
```

3、展示效果如下

![image-20211019202821237](4%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8.assets/image-20211019202821237.png)



### 反序列化

#### 1、数据验证

使用序列化器进行反序列化时，需要对数据进行验证后，才能获取验证成功的数据或保存成模型类对象。

在获取反序列化的数据前，必须调用**is_valid()**方法进行验证，验证成功返回True，否则返回False。

验证失败，可以通过序列化器对象的**errors**属性获取错误信息，返回字典，包含了字段和字段的错误。如果是非字段错误，可以通过修改REST framework配置中的**NON_FIELD_ERRORS_KEY**来控制错误字典中的键名。

验证成功，可以通过序列化器对象的**validated_data**属性获取数据。

在定义序列化器时，指明每个字段的序列化类型和选项参数，本身就是一种验证行为。

#### 2、数据验证的三种类型

下面的代码主要知道怎么定义和使用，具体的使用在下面实例中都有展示

##### 1) validate_字段名

```python
def validate_name(self, data):
        """单个字段进行验证"""
        if data in ["python", "django"]:
            raise serializers.ValidationError(detail='学生名不能为python或者django', code='validate_name')

        return data
```

##### 2) validate

在序列化器中需要同时对多个字段进行比较验证时，可以定义validate方法来验证，如

```python
def validate(self, attrs):
        """多个字段进行验证"""
        if attrs['classmate'] == 123 and attrs['sex']:
            raise serializers.ValidationError(detail='123班级只能是女的', code='validate')

        return attrs
```

##### 3) validators

在字段中添加validators选项参数，也可以补充验证行为，如

```python
# 外部验证函数，为 validators 验证时调用
def check_classmate(data):
    if len(data) != 3:
        raise serializers.ValidationError(detail='班级名称长度不能超过3位', code='check_classmate')

    return data
    
class StudentSerializer2(serializers.Serializer):
	classmate = serializers.CharField(validators=[check_classmate])  # validators=[check_classmate] 调用外部函数进行数据验证
    .......
```

#### 3、保存数据

前面的验证数据成功后，我们可以使用序列化器来完成数据反序列化的过程，这个过程可以把数据转成模型类对象。

可以通过实现create()和update()两个方法来实现。

```python
def create(self, validated_data):
        """
        函数名称 固定不变
        :param validated_data: 验证成功后的数据
        """
        student = Student.objects.create(**validated_data)
        return student

    def update(self, instance, validated_data):
        """
        方法名称固定为 update
        :param instance: 实例化序列化器对象时，必须传入的模型对象
        :param validated_data: 验证成功以后的结果
        更新数据以后，就自动实现了从字典变成模型对象的过程
        """
        instance.name = validated_data["name"]
        instance.age = validated_data["age"]
        instance.sex = validated_data["sex"]
        instance.classmate = validated_data["classmate"]
        instance.description = validated_data["description"]
        instance.save()  # 调用模型对象的save方法，和视图中的serialzier.save()不是同一个类的方法

        return instance
```

实现了上述两个方法后，在反序列化数据的时候，就可以通过save()方法返回一个数据对象实例了

```python
data = serializer.save()
```

如果创建序列化器对象的时候，没有传递instance实例，则调用save()方法的时候，create()被调用，相反，如果传递了instance实例，则调用save()方法的时候，update()被调用。

### 反序列化实例

#### 1、反序列化器类代码

serialziers.py，代码：

```python
from rest_framework import serializers
from .models import Student


# 外部验证函数，为 validators 验证时调用
def check_classmate(data):
    if len(data) != 3:
        raise serializers.ValidationError(detail='班级名称长度不能超过3位', code='check_classmate')

    return data

# 反序列化器类
class StudentSerializer2(serializers.Serializer):
    id = serializers.IntegerField(read_only=True)  # 客户端输入可以不输入id
    name = serializers.CharField(required=True)  # required为True 必填项
    sex = serializers.BooleanField(default=True)
    age = serializers.IntegerField(min_value=0, max_value=100, error_messages={
        "min_value": "年龄必须 >= 0",
        "max_value": "年龄必须 <= 100",
    })  # error_message设置年龄输入错误提示信息
    classmate = serializers.CharField(validators=[check_classmate])  # validators=[check_classmate] 调用外部函数进行数据验证
    description = serializers.CharField(allow_null=True, allow_blank=True)  # 允许为null 并且允许为 “”

    def validate_name(self, data):
        """单个字段进行验证"""
        if data in ["python", "django"]:
            raise serializers.ValidationError(detail='学生名不能为python或者django', code='validate_name')

        return data

    def validate(self, attrs):
        """多个字段进行验证"""
        if attrs['classmate'] == 123 and attrs['sex']:
            raise serializers.ValidationError(detail='123班级只能是女的', code='validate')

        return attrs

    def create(self, validated_data):
        """
        函数名称 固定不变
        :param validated_data: 验证成功后的数据
        """
        student = Student.objects.create(**validated_data)
        return student

    def update(self, instance, validated_data):
        """
        方法名称固定为 update
        :param instance: 实例化序列化器对象时，必须传入的模型对象
        :param validated_data: 验证成功以后的结果
        更新数据以后，就自动实现了从字典变成模型对象的过程
        """
        instance.name = validated_data["name"]
        instance.age = validated_data["age"]
        instance.sex = validated_data["sex"]
        instance.classmate = validated_data["classmate"]
        instance.description = validated_data["description"]
        instance.save()  # 调用模型对象的save方法，和视图中的serialzier.save()不是同一个类的方法

        return instance

```

#### 2、视图类代码

```python
from django.views import View
from django.http.response import JsonResponse
from .serializers import StudentSerializer2
from .models import Student

# 反序列化视图
class StudentView2(View):
    """ todo 反序列化，采用 字段选项 来验证数据"""
    def get(self, request):

        # 1. 根据客户端访问的url地址中，获取pk值
        # sers/students/2/    path("/students/(?P<pk>)\d+/", views.StudentView.as_view()),
        pk = 5
        try:
            student = Student.objects.get(pk=pk)
        except Student.DoesNotExist:
            return JsonResponse({"errors": "当前学生不存在！"}, status=400)

        # 1、接收客户端传入的数据
        # data = json.dumps(request.body)
        # 使用模拟数据
        instance = {
            "name": "xiaohu",
            "age": 18,
            "sex": True,
            "classmate": 123,
            "description": "我是小虎"
        }

        # 实例化对象
        # 添加数据
        # serializer = StudentSerializer2(data=instance)
        #更新数据
        serializer = StudentSerializer2(instance=student, data=instance)
        # 配合下面的保存数据，在不传入 instance 时 为添加数据，往数据库中新增
        # 如果传入 instance 参数，则为更新数据

        # 数据验证
        # ret = serializer.is_valid() # 不会抛出异常，会执行数据不在后的判断代码
        ret = serializer.is_valid(raise_exception=True) # 抛出异常，代码不会往下执行, 不会把JsonResponse中的数据返回

        # 2. 获取验证以后的结果。操作数据库
        serializer.save()  # 会根据实例化序列化器的时候，是否传入instance属性来自动调用create或者update方法。传入instance属性，自动调用update方法;没有传入instance属性，则自动调用create

        if ret:
            return JsonResponse(dict(serializer.validated_data))
        else:
            return JsonResponse(dict(serializer.errors))
```



### 附加说明

1） 在对序列化器进行save()保存时，可以额外传递数据，这些数据可以在create()和update()中的validated_data参数获取到

```python
# request.user 是django中记录当前登录用户的模型对象
serializer.save(owner=request.user) # 可以在save中，传递一些不需要验证的数据到模型里面
```

2）默认序列化器必须传递所有required的字段，否则会抛出验证异常。但是我们可以使用partial参数来允许部分字段更新

```python
# 更新 `name` ，不需要验证其他的字段，可以设置partial=True
serializer = StudentSerializer(student, data={'name': 'xiaohui'}, partial=True)
```

