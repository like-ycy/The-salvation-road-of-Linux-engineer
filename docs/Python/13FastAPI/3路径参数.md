# 路径参数

可以使用与 Python 格式化字符串相同的语法来声明路径 "参数" 或 "变量"：

```python
from fastapi import FastAPI

app = FastAPI()


@app.get("/items/{item_id}")
async def read_item(item_id):
    return {"item_id": item_id}
```

路径参数 `item_id` 的值将作为参数 `item_id` 传递给你的函数。

所以，如果你运行示例并访问 http://127.0.0.1:8000/items/foo，将会看到如下响应：

```json
{"item_id":"foo"}
```



## 1、有类型的路径参数

你可以使用标准的 Python 类型标注为函数中的路径参数声明类型。

```python
from fastapi import FastAPI

app = FastAPI()


@app.get("/items/{item_id}")
async def read_item(item_id: int):
    return {"item_id": item_id}
```

在这个例子中，`item_id` 被声明为 `int` 类型。



## 2、数据转换

如果你运行示例并打开浏览器访问 http://127.0.0.1:8000/items/3，将得到如下响应：

```json
{"item_id":3}
```

!> 注意函数接收（并返回）的值为 3，是一个 Python `int` 值，而不是字符串 `"3"`。

所以，**FastAPI** 通过上面的类型声明提供了对请求的自动 "解析"。



## 3、数据校验

但如果你通过浏览器访问 http://127.0.0.1:8000/items/foo，你会看到一个清晰可读的 HTTP 错误：

```json
{
    "detail": [
        {
            "loc": [
                "path",
                "item_id"
            ],
            "msg": "value is not a valid integer",
            "type": "type_error.integer"
        }
    ]
}
```

因为路径参数 `item_id` 传入的值为 `"foo"`，它不是一个 `int`。

如果你提供的是 `float` 而非整数也会出现同样的错误，比如： http://127.0.0.1:8000/items/4.2

>所以，通过同样的 Python 类型声明，**FastAPI** 提供了数据校验功能。
>
>注意上面的错误同样清楚地指出了校验未通过的具体原因。
>
>在开发和调试与你的 API 进行交互的代码时，这非常有用。



## 4、顺序很重要

在创建**路径操作**时，你会发现有些情况下路径是固定的。

比如 `/users/me`，我们假设它用来获取关于当前用户的数据.

然后，你还可以使用路径 `/users/{user_id}` 来通过用户 ID 获取关于特定用户的数据。

由于**路径操作**是按顺序依次运行的，你需要确保路径 `/users/me` 声明在路径 `/users/{user_id}` 之前：

```python
from fastapi import FastAPI

app = FastAPI()


@app.get("/users/me")
async def read_user_me():
    return {"user_id": "the current user"}


@app.get("/users/{user_id}")
async def read_user(user_id: str):
    return {"user_id": user_id}
```

否则，`/users/{user_id}` 的路径还将与 `/users/me` 相匹配，"认为" 自己正在接收一个值为 `"me"` 的 `user_id` 参数。



## 5、路径参数的预定义值

如果你有一个接收路径参数的操作，但你希望预先定义路径参数，则可以 Python `Enum` 来声明路径参数的预定义值。

!> 注意：预设路径参数后，路径后只能跟指定的预设参数，其他参数则报错

```python
from enum import Enum
from fastapi import FastAPI


# 1、导入 `Enum` 并创建一个继承自 `str` 和 `Enum` 的子类
class ModelName(str, Enum):
    name = "jack"
    sex = "male"
    age = 18

app = FastAPI()


@app.get("/models/{model_name}")  # 2、路径参数必须是一个枚举成员的值
async def get_model(model_name: ModelName):  # 3、声明路径参数
    # 4、将路径参数与枚举成员进行比较
    if model_name == ModelName.name:
        return {"name": model_name, "message": "用户名"}

    if model_name.value == "male":
        return {"sex": model_name, "message": "性别"}

    return {"age": model_name, "message": "年龄"}

```

**获取枚举值**

你可以使用 `model_name.value` 或 `your_enum_member.value` 来获取实际的值

也可以通过 `ModelName.age.value` 来获取值 `18`。

?> [枚举（或 enums）](https://docs.python.org/3/library/enum.html)从 3.4 版本起在 Python 中可用。



## 6、路径参数中包含文件路径

假设你有一个**路径操作**，它的路径为 `/files/{file_path}`。

但是 `file_path` 自身也包含**路径**，比如 `home/johndoe/myfile.txt`。

因此，该文件的 URL 为：`/files/home/johndoe/myfile.txt`。

> OpenAPI 不支持任何方式去声明**路径参数**以在其内部包含**路径**，因为这可能会导致难以测试和定义的情况出现。

不过，你仍然可以通过 Starlette 的一个内部工具在 **FastAPI** 中实现它。

而且文档(/doc)依旧可以使用，但是不会添加任何该参数应包含路径的说明。

### 路径转换器

你可以使用直接来自 Starlette 的选项来声明一个包含*路径*的*路径参数*：

```
/files/{file_path:path}
```

在这种情况下，参数的名称为 `file_path`，结尾部分的 `:path` 说明该参数应匹配任意的*路径*。

因此，你可以这样使用它：

```
from fastapi import FastAPI

app = FastAPI()


@app.get("/files/{file_path:path}")
async def read_file(file_path: str):
    return {"file_path": file_path}
```

> 你可能会需要参数包含 `/home/johndoe/myfile.txt`，以斜杠（`/`）开头。
>
> 在这种情况下，URL 将会是 `/files//home/johndoe/myfile.txt`，在 `files` 和 `home` 之间有一个双斜杠（`//`）。

