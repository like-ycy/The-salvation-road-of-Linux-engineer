## 路由进阶

### 路由语法和参数

在路由列表的路由成员中，我们一共可以设置4个参数

>   url(r"/uri路径", 视图类, {"参数名":"参数值"}, name="路由别名")

server.py

```python
from tornado import web
from tornado import ioloop
settings = {
    'debug': True,
}

class Home(web.RequestHandler):
    def initialize(self,company)-> str:
        # initialize 初始化方法[钩子方法]
        self.company = company

    def get(self):
        print(self.company)
        print("uri路径：%s" % self.reverse_url("home") ) # 对路由别名进行 反解析
        self.write("hello,get")
    def post(self):
        print(self.company)

from tornado.web import url
urls = [
    # (r"/", Home), # 这个格式的路由其实是简写模式， 在tornaodo.web中内部中最终由 _ApplicationRouter 的 Rule来进行封装和匹配路由和视图的关系
    # url(pattern=路由uri地址, handler=视图类,kwargs=提供给视图类的公共参数,name="路由别名，用于反解析"),
    url(pattern=r"/abc", handler=Home,kwargs={"company":"OldBoyEdu"},name="home"),
]

if __name__ == '__main__':
    app = web.Application(urls,**settings)
    app.listen(port=8888)
    ioloop.IOLoop.current().start()
```



## 视图进阶

### 视图中内置的钩子方法

在tornado提供的视图类中，我们除了可以编写客户端http请求对应名称的视图方法和初始化方法**initialize**以外，还提供了一个预处理方法**prepare**和**on_finish**，prepare方法会在http请求方法执行之前先执行,**on_finish**会在http响应完成时进行。

server.py，代码：

```python
from tornado import ioloop
from tornado import web
from tornado.httpserver import HTTPServer
from tornado.options import define, options, parse_command_line
from tornado.web import url
settings = {
    'debug': True,
}

define("port", default=8888, type=int, help="设置监听端口号，默认为8888")

class Home(web.RequestHandler):
    def prepare(self):
        print(self.request.headers.get("Content-Type"))
        if self.request.headers.get("Content-Type","").startswith("application/json"):
            import json
            self.json_data = json.loads(self.request.body)
            self.is_json = True
        else:
            self.is_json = False
            self.json_data = None

    def post(self):
        if self.is_json:
            print(self.json_data)
        self.write("hello,post")

    def on_finish(self):
        print("请求处理结束!可以在此进行收尾工作，例如：记录日志等")

# 设置路由列表
urls = [
    (r"/", Home),
]

if __name__ == "__main__":
    # 创建应用实例对象
    parse_command_line()
    app = web.Application(urls, **settings)
    server = HTTPServer(app)
    # 设置监听的端口和地址
    server.listen(options.port)
    server.start(1)
    ioloop.IOLoop.current().start()
```



### 视图方法调用顺序

```python
from tornado import ioloop
from tornado import web
from tornado.httpserver import HTTPServer
from tornado.options import define, options, parse_command_line
from tornado.web import url
settings = {
    'debug': True,
}

define("port", default=8888, type=int, help="设置监听端口号，默认为8888")

class Home(web.RequestHandler):
    def initialize(self):
        print("initialize执行了")

    def prepare(self):
        print("prepare执行了")


    def set_default_headers(self):
        print("set_default_headers执行了")

    def get(self):
        self.write("hello,get")
        print("视图http方法执行了")
        # self.send_error(200,msg="注意：丢炸弹了")  # 此处抛出错误


    def write_error(self, status_code, **info):
        print("write_error执行了,msg=%s" % info["msg"])

    def on_finish(self):
        print("on_finish执行了")

# 设置路由列表
urls = [
    (r"/", Home),
]

if __name__ == "__main__":
    # 创建应用实例对象
    parse_command_line()
    app = web.Application(urls, **settings)
    server = HTTPServer(app)
    # 设置监听的端口和地址
    server.listen(options.port)
    server.start(1)
    ioloop.IOLoop.current().start()
```

当视图中没有任何异常时，执行顺序：

```
set_defautl_headers()
initialize()
prepare()
视图http方法()
on_finish()
```

当视图中抛出异常错误时，执行顺序：

```
set_default_headers()
initialize()
prepare()
视图http方法()
set_default_headers()
write_error()
on_finish()
```



### 冲刷缓存

在前面的学习中，我们使用了`self.write()`来完成数据的响应。

事实上，在tornado提供的视图操作中，视图中提供了一个 _write_buffer列表用于暂时缓存提供给客户端的数据, 这个 _write_buffer就是输出缓冲区

`self.write()`本质上来说是将chunk数据块写到输出缓冲区中。所以才出现在视图中多次调用`self.write()`输出数据的情况,因为self.write根本没有输出数据,而是把数据写入到了输出缓冲区里面. 如果没有其他操作干预的情况下，则视图方法处理完成以后，会讲输出缓冲区中所有的数据冲刷出来响应给客户端。

除了`self.write()`方法以外，tornado还提供了2个方法用于在视图中冲刷缓存数据到客户端的。

`self.flush()` 立刻把数据从输出缓冲区冲刷出去。

`self.finish()`立刻把数据从输出缓冲区冲刷出去。但是与self.flush()不同的是, self.finish()执行了以后, 后面的所有输出调用都不在支持.也就不能返回给客户端。

server.py，代码：

```python
from tornado import ioloop
from tornado import web
from tornado.httpserver import HTTPServer
from tornado.options import define, options, parse_command_line
settings = {
    'debug': True,
}

define("port", default=8888, type=int, help="设置监听端口号，默认为8888")

class Home(web.RequestHandler):
    def get(self):
        import time
        self.write("hello,get1")
        self.flush()
        time.sleep(3)
        self.write("hello,get2")
        self.flush()
        time.sleep(3)
        self.write("hello,get3")
        self.flush()
        self.finish("这里一般不写任何内容，表示视图处理结束")
        self.write("hello,get4")

# 设置路由列表
urls = [
    (r"/", Home),
]

if __name__ == "__main__":
    # 创建应用实例对象
    parse_command_line()
    app = web.Application(urls, **settings)
    server = HTTPServer(app)
    # 设置监听的端口和地址
    server.listen(options.port)
    server.start(1)
    ioloop.IOLoop.current().start()
```



### 用户认证

tornado提供了装饰器tornado.web.authenticated与视图内置方法`get_current_user`允许我们轻松的实现用户认证功能。

装饰器authenticated依赖于请求处理类中的self.current_user属性来进行判断用户是否通过认证，如果self.current_user值为假（None、False、0、""等），任何GET或HEAD请求都将把访客重定向到settings配置中login_url设置的URL，而非法用户的POST请求将返回HTTPError(403)异常, Forbidden。

server.py，代码：

```python
from tornado import web
from tornado import ioloop
settings = {
    'debug': True,
    # 登录页面的url地址
    "login_url": r"/login"
}

from tornado.web import authenticated

class HttpRequest(web.RequestHandler):
    def get_current_user(self):
        username = self.get_argument("username", "")
        password = self.get_argument("password", "")

        if username == "root" and password == "123":
            return username

class Home(HttpRequest):
    @authenticated
    def get(self):
        self.write("hello,用户个人中心")

    @authenticated
    def post(self):
        self.write("hello,用户中心")

class UserLogin(web.RequestHandler):
    def get(self):
        self.write("登录页面")

urls = [
    (r"/", Home),
    (settings["login_url"], UserLogin),
]

if __name__ == '__main__':
    app = web.Application(urls,**settings)
    app.listen(port=8888)
    ioloop.IOLoop.current().start()
```

>   先访问：http://127.0.0.1:8888/?username=root&password=123
>
>   再访问：http://127.0.0.1:8888/

