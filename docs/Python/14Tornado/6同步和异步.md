# 同步和异步

## 概念

**同步**是指代在程序执行多个任务时，按部就班的依次执行，必须上一个任务执行完有了结果以后，才会执行下一个任务。

**异步**是指代在程序执行多个任务时，没有先后依序，可以同时执行，所以在执行上一个任务时不会等待结果，直接执行下一个任务。一般最终在下一个任务中通过状态的改变或者通知、回调的方式来获取上一个任务的执行结果。

### 同步

server.py，代码：

```python
import time
def client_A():
    """模拟客户端A"""
    print('开始处理请求1-1')
    time.sleep(5)
    print('完成处理请求1-2')


def client_B():
    """模拟客户端B"""
    print('开始处理请求2-1')
    print('完成处理请求2-2')


def tornado():
    """模拟tornado框架"""
    client_A()
    client_B()


if __name__ == "__main__":
    tornado()
```

### 异步

server.py，代码：

```python
from threading import Thread
from time import sleep

def async(func):
    def wrapper(*args, **kwargs):
        thread = Thread(target=func, args=args, kwargs=kwargs)
        thread.start()
    return wrapper

@async
def funcA():
    sleep(5)
    print("funcA执行了")

def funcB():
    print("funcB执行了")

def tornado():
    funcA()
    funcB()

if __name__ == "__main__":
    tornado()
```



### 协程

要理解什么是协程（Coroutine），必须先清晰**迭代器**和**生成器**的概念。

#### 迭代器

迭代器就是一个对象，一个可迭代的对象，是可以被for循环遍历输出的对象。当然专业的说，就是实现了迭代器协议的对象。

任何一个对象，只要类中实现了``__iter__()`就是一个可迭代对象（iterable）。

任何一个对象，只要类中实现了`__iter__()`和`__next__()`就是一个迭代器（iterator）。

迭代器一定是可迭代对象，可迭代对象不一定是迭代器。

要了解迭代器，我们先编写一个代码来看看python提供的可迭代对象。常见的有：str，list ，tuple，dic，set，文件对象。

迭代器是惰性执行的，可以节省内存，不能反复, 只能向下取值。

server.py，代码：

```python
# 可迭代对象
# arr = [4,5,6,7]
# arr = "abcd"
# print(dir(arr))
# for item in arr:
#     print(item)

# 不可迭代对象
# num = 123
# print(dir(num))
# for item in num: # TypeError: 'int' object is not iterable
#     print(item)

# 自定义可迭代对象
class Colors(object):
    def __init__(self):
        self.data = ["红色", "橙色", "紫色", "黄色"]

    def __iter__(self):
        # __iter__ 必须有返回值，并且只能返回迭代器对象
        return self.data.__iter__()

colors = Colors()
print(dir(colors))
for item in colors:
    print(item)
```

查看一个对象是否是可迭代对象或迭代器：

```python
from collections import Iterable, Iterator
data = [1,2,3,4]
print(isinstance(data,Iterable)) # True       # 查看是不是可迭代对象
print(isinstance(data,Iterator)) # False      # 查看是不是迭代器
print(isinstance(data.__iter__(),Iterator))   # True，
# 所有的迭代对象都有一个__iter__方法，该方法的作用就是返回一个迭代器对象
```

接下来，动手编写一个迭代器。

server.py，代码：

```python
class Num(object):
    def __init__(self,max):
        self.max = max
        self.current = 0

    def __next__(self):
        # print("current=",self.current)
        if self.current >= self.max:
            raise StopIteration

        self.current += 1
        return self.current

    def __iter__(self):
        return self

num = Num(3) # 迭代器
# print(dir(num))
# for的内部本质上就是不断调用了迭代器的__next__()，
# 并在遇到StopIteration异常以后，终止程序的执行
# for item in num:
#     print(item)

while True:
    try:
        print(num.__next__())
    except StopIteration:
        break
```

>   `__iter__()` 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 `__next__()` 方法并通过 StopIteration 异常标识迭代的完成。
>
>   `__next__()` 方法返回下一个迭代器对象。
>
>   **StopIteration** 异常用于标识迭代的完成，防止出现无限循环，在 `__next__()` 方法中可以设置在完成**指定循环次数**后触发 **StopIteration** 异常来结束迭代。



#### 生成器

在 Python 中，使用了 **yield** 的函数被称为生成器函数。

生成器函数执行以后的返回结果就是**生成器**（**generator**），是一种特殊的迭代器。生成器只能用于迭代操作。

**yield** 是一个python内置的关键字，它的作用有一部分类似**return**，可以返回函数的执行结果。但是不同的是，return 会终止函数的执行，yield 不会终止生成器函数的执行。两者都会返回一个结果，但return只能一次给函数的调用处返回值，而yield是可以多次给next()方法返回值，而且yield还可以接受外界send()方法的传值。所以，更准确的来说，**yield是暂停程序的执行权并记录了程序当前的运行状态的标记符.同时也是生成器函数外界和内部进行数据传递的通道**。

server.py，代码：

```python
def func():
    for item in [4,5,6]:
        return item

def gen1():
    for item in [4,5,6]:
        yield item

def gen2():
    key = 0
    print(">>>>> 嘟嘟，开车了")
    while True:
        food = yield "第%s次" % key
        print('接收了，%s'% food)
        key +=1

f = func()
print(f)
g1 = gen1()
print(g1)
for item in g1:
    print(item)

g2 = gen1()
print(g2)
print(next(g2))
print(next(g2))
print(g2.__next__())
# print(next(g2))

g3 = gen2()
g3.send(None) # g3.__next__() 预激活生成器,让生成器内部执行到第一个yield位置，否则无法通过send传递数据给内部的yield
for item in ["苹果","芒果"]:
    print(g3.send(item))
```

>   使用生成器可以让代码量更少，内存使用更加高效节约。
>
>   所以在工作中针对海量数据查询，大文件的读取加载，都可以考虑使用生成器来完成。因为一次性读取大文件或海量数据必然需要存放内容，而往往读取的内容大于内存则可能导致内存不足，而使用生成器可以像挤牙膏一样，一次读取一部分数据通过yield返回，每次yield返回的数据都是保存在同一块内存中的，所以比较起来肯定比一次性读取大文件内容来说，内存的占用更少。



##### yield 和 yield from

yield from 也叫委派生成器.委派生成器的作用主要是用于多个生成器之间进行嵌套调用时使用的.

server.py，代码：

```python
def gen1():
    a = 0
    while True:
        # print("+++++++")
        a = yield a**2

def gen2(gen):
    yield from gen
    # a = 0
    # b = 1
    # gen.send(None)
    # while True:
    #     # print("-------")
    #     b = yield a
    #     a = gen.send(b)

if __name__ == '__main__':
    g1 = gen1()
    g2 = gen2(g1)
    g2.send(None)
    for i in range(5):
        # print(">>>> %s" % i)
        print(g2.send(i))
```



##### 基于生成器来实现协程异步

这也是协程的实现原理，任务交替切换执行（遇到IO操作时进行判断任务切换才有使用价值, 当前此处我们使用的生成器实现的协程,是无法判断当前任务是否是遇到IO的,我们通过第三方模块: geventlet来实现判断是否遇到IO操作.）。

server.py，代码：

```python
import time
def gen1():
    while True:
        print("--1")
        yield
        print("--2")
        time.sleep(1)

def gen2():
    while True:
        print("--3")
        yield
        print("--4")
        time.sleep(1)

if __name__ == "__main__":
    g1 = gen1()
    g2 = gen2()
    for i in range(3):
        next(g1)
        print("主程序!")
        next(g2)
```

