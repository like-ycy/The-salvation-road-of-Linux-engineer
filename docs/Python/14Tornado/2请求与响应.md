## 请求与响应

### 请求

`tornado.httputil.HTTPServerRequest`

server.py，代码：

```python
from tornado import ioloop
from tornado import web

# 项目配置
settings = {
    "debug": True, # 开启debug模式
}

# 视图类必须要直接或者间接继承于 web.RequestHandler
class Home(web.RequestHandler):
    def get(self): # http请求方法
        # 响应数据
        # print(self.settings) # 配置信息
        # print(self.request)  # 获取http请求处理的实例对象
        # # HTTPServerRequest(protocol='http', host='127.0.0.1:8000', method='GET', uri='/', version='HTTP/1.1', remote_ip='127.0.0.1')

        print("通信协议: ",self.request.protocol) # 协议
        print("请求方法: ",self.request.method) # Http请求方法
        print("uri地址: ",self.request.uri)    # uri地址
        print("url地址: ",self.request.full_url())    # 完整url地址
        print("协议版本: ",self.request.version) # 协议版本
        print("请求头: ")
        print(self.request.headers) # 请求头 HTTPHeaders
        print("地址端口: ", self.request.host)  # 地址端口

        self.write("hello!get") # 这里也是可以被执行的
    def post(self):
        # print("请求体: ", self.request.body) # 请求体[原始数据]
        # import json
        # body = json.loads(self.request.body.decode())
        # print(body) # {'jsonrpc': '2.0', 'id': 1, 'method': 'Live.stream.list', 'params': {}}

        # print("上传文件: ",self.request.files)# 上传文件
        # print("cookie信息: ")
        # print(self.request.cookies) # cookie信息
        # print("当前客户端的IP地址: ", self.request.remote_ip) # 客户端IP地址
        print(self.request.request_time())  # 请求处理的花费时间

        self.write("hello!post")

    def put(self):
        # 开发中很少使用
        print("查询字符串参数列表: ",self.request.query_arguments) # 查询字符串参数列表
        print("请求体参数列表: ",self.request.body_arguments) # 请求体参数列表
        self.write("hello!put")

# 路由列表
urls = [
    # (r"uri路径", 视图类),
    (r"/", Home),
]

if __name__ == "__main__":
    # Application是tornado web框架的核心应用类，是与服务器对应的接口，里面保存了路由映射表
    app = web.Application(
        urls,
        **settings,
    )
    # 设置监听的端口和地址
    # 启动http多进程服务
    app.listen(port=8000,address="0.0.0.0")
    # ioloop，全局的tornado事件循环，是服务器的引擎核心，start表示创建IO事件循环,等待客户端连接
    ioloop.IOLoop.current().start()
```



#### 接收查询字符串

server.py，代码：

```python
from tornado import ioloop
from tornado import web
from tornado import autoreload
from tornado.options import define,options,parse_command_line

settings = {
    'debug' : True,
}

define("port", default=8888, type=int,help="设置监听端口号，默认为8888")
class Home(web.RequestHandler):
    def get(self):
        # print(self.request.arguments["name"][0].decode())
        # name = self.get_argument("name") # self.get_query_argument("name")
        # print(name) # xiaoming
        names = self.get_arguments("name") # # self.get_query_arguments("name")
        print(names) # ['xiaoming', '123']
        self.write("hello world")

# 设置路由列表
urls = [
    (r"/", Home),
]

if __name__ == "__main__":
    # 创建应用实例对象
    parse_command_line()
    app = web.Application(urls,**settings)
    # 设置监听的端口和地址
    app.listen(options.port)
    # ioloop，全局的tornado事件循环，是服务器的引擎核心，start表示创建IO事件循环
    ioloop.IOLoop.current().start()
```

浏览器：`http://127.0.0.1:8888/?name=xiaoming&name=xiaohong`

#### 接收请求体

```python
from tornado import ioloop
from tornado import web
from tornado import autoreload
from tornado.options import define,options,parse_command_line

settings = {
    'debug' : True,
}

define("port", default=8888, type=int,help="设置监听端口号，默认为8888")
class Home(web.RequestHandler):
    def get(self):
        # print(self.request.arguments["name"][0].decode())
        # name = self.get_argument("name") # self.get_query_argument("name")
        # print(name) # xiaoming
        names = self.get_arguments("name") # # self.get_query_arguments("name")
        print(names) # ['xiaoming', '123']
        self.write("hello!get")

    def post(self):
        print(self.request.arguments) # {'name': [b'xiaoming', b'xiaohong']}
        print(self.request.body_arguments) # {'name': [b'xiaohong']}
        print(self.get_argument("name")) # xiaohong
        print(self.get_body_argument("name")) # xiaohong
        print(self.get_arguments("name")) # ['xiaoming', 'xiaohong']
        print(self.get_body_arguments("name")) # ['xiaohong']
        self.write("hello!post")
        
# 设置路由列表
urls = [
    (r"/", Home),
]

if __name__ == "__main__":
    # 创建应用实例对象
    parse_command_line()
    app = web.Application(urls,**settings)
    # 设置监听的端口和地址
    app.listen(options.port)
    # ioloop，全局的tornado事件循环，是服务器的引擎核心，start表示创建IO事件循环
    ioloop.IOLoop.current().start()
```



#### 接收路由参数

```python
from tornado import ioloop
from tornado import web

# 项目配置
settings = {
    "debug": True, # 开启debug模式
}

# 视图类必须要直接或者间接继承于 web.RequestHandler
class Home(web.RequestHandler):
    def get(self,cat,id): # 路由参数的形参，分别匹配路由中对应小括号中的url地址内容
        self.write("hello!cat=%s,id=%s" % (cat,id))

class Index(web.RequestHandler):
    def get(self,cat,id):
        self.write("hello!cat=%s,id=%s" % (cat, id))

# 路由列表
urls = [
    # (r"uri路径", 视图类),
    # (r"/(参数1的正则)/(参数2的正则).html", Home), # 位置参数
    (r"/([0-9]+)-([0-9]+).html", Home), # 位置参数
    # (r"/index/(?P<参数名>正则).html", Index), # 命名参数
    (r"/index/(?P<id>[0-9]+)-(?P<cat>[0-9]+).html", Index), # 命名参数
]

if __name__ == "__main__":
    # Application是tornado web框架的核心应用类，是与服务器对应的接口，里面保存了路由映射表
    app = web.Application(
        urls,
        **settings,
    )
    # 设置监听的端口和地址
    # 启动http多进程服务
    app.listen(port=8000,address="0.0.0.0")
    # ioloop，全局的tornado事件循环，是服务器的引擎核心，start表示创建IO事件循环,等待客户端连接
    ioloop.IOLoop.current().start()
```



### 响应

```python
from tornado import ioloop
from tornado import web
from tornado import autoreload
from tornado.options import define, options, parse_command_line

settings = {
    'debug': True,
}

define("port", default=8888, type=int, help="设置监听端口号，默认为8888")

from datetime import datetime
class Home(web.RequestHandler):
    def set_default_headers(self):
        self.set_header("time", int(datetime.now().timestamp()))
    def get(self):
    def get(self):
        # write 会自动识别
        # self.write("<h1>hello world</h1>") # 响应html文档
        # self.write({"msg":"ok"}) # 响应json数据

        # 注意，json的数据格式也可以是列表,tornado中默认不支持返回list，所以如果返回list，则需要重写write
        # self.write([1,2,3])
        
        # 重新设置响应头的内容 set_header[修改]
        self.set_header("Content-Type","text/json; charset=gbk")
        # 自定义响应头 add_header[添加]
        self.add_header("Company","OldBoyEdu")
        self.add_header("Server","OldBoyEduServer/1.0")
        # self.clear_header("Server")  # 从响应头中删除指定名称的响应头信息

    def post(self):
        # self.set_status(404,"No User") # 第二个参数表示响应描述，如果不设置，则显示原来对应的
        # self.send_error(500,reason="服务器炸了！")
        self.send_error(404, msg="服务器炸了！", info="快报警") # 要使用send_error必须先声明send_error方法

    def write_error(self, status_code, **kwargs):
        self.write("<h1>完蛋啦...</h1>")
        self.write("<p>错误信息:%s</p>" % kwargs["msg"])
        self.write("<p>错误描述:%s</p>" % kwargs["info"])

    def put(self):
        # 页面响应
        self.redirect("http://www.oldboyedu.com")

# 设置路由列表
urls = [
    (r"/", Home),
]

if __name__ == "__main__":
    # 创建应用实例对象
    parse_command_line()
    app = web.Application(urls, **settings)
    # 设置监听的端口和地址
    app.listen(options.port)
    # ioloop，全局的tornado事件循环，是服务器的引擎核心，start表示创建IO事件循环
    ioloop.IOLoop.current().start()
```



### cookie

```python
# 获取和设置cookie
self.set_cookie(name, value)
self.get_cookie(name)


# 获取和设置cookie[加密]
settings = {cookie_secret:"u3h7AQnM2WdTL1o"}

self.set_secure_cookie(name, value)
self.get_secure_cookie(name)

# 删除cookie
self.clear_cookie(name)

# 清空cookie
self.clear_all_cookie()
```

>   tornado没有提供session操作，如果需要使用到session可以自己实现或者引入第三方模块。



### 静态文件

```python
import os
settings = {
    'debug': True,
    # 静态文件保存路径
    "static_path": os.path.join(os.path.dirname(__file__), 'static'),
    # 静态文件url地址前缀
    "static_url_prefix":"/static/", # 必须前后有斜杠
}
```



### 页面响应

```python
from tornado import ioloop
from tornado import web
from tornado.options import define, options, parse_command_line
import os
settings = {
    'debug': True,
    # 静态文件保存路径
    "static_path": os.path.join(os.path.dirname(__file__), 'static'),
    # 静态文件url地址前缀
    "static_url_prefix":"/static/", # 必须前后有斜杠
    "template_path": os.path.join(os.path.dirname(__file__), 'templates'),
}

define("port", default=8888, type=int, help="设置监听端口号，默认为8888")

class Home(web.RequestHandler):
    def get(self):
        self.render("index.html")

# 设置路由列表
urls = [
    (r"/", Home),
]

if __name__ == "__main__":
    # 创建应用实例对象
    parse_command_line()
    app = web.Application(urls, **settings)

    # 设置监听的端口和地址
    app.listen(options.port)
    # ioloop，全局的tornado事件循环，是服务器的引擎核心，start表示创建IO事件循环
    ioloop.IOLoop.current().start()
```



templates/index.html，代码：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    tornado默认内置了一套非常强大的模板引擎<br>
    这套模板引擎是基于jinja2模板引擎的基础上进行了改造而成的。<br>
    当然jinja2是基于django的DTL模板引擎基础上改造而成的。<br>
    所以flask和tornado进行比较的时候，从来不提tornado抄袭模板引擎这个事，反而会和django去比较模板引擎的问题。
</body>
</html>
```

