# 单元测试

所谓的单元测试（unit testing），在开发中是指对软件中的最小可测试单元进行检查和验证的过程。

单元的含义，一般来说，是指项目的最小的代码块，一般就是一个函数、或者一个类，或者一个类下面的方法。

测试的含义，一般来说，就是对函数/类方法/接口方法，进行参数的判断、返回值的判断，判断这个代码块的执行流程是否符合我们的开发预期，所以单元测试是很多的开发框架都内置的功能。其中，python解析器中默认安装了以后，就内置了单元测试的模块unittest。

而django作为重量级的web开发框架，默认也在子应用目录下默认允许我们编写测试代码的，这些测试代码，一般我们也称之为“测试用例”。

基于不同的条件，编写多个不同的测试用例，可以对代码块在各种情况下的运行状态、运行结果进行代码审查，已达到让开发者编写出更加安全、更加可靠的程序。

!> 以下代码皆在浮光在线的基础上进行编写及测试

## 编写测试用例

在django中，开发者可以直接在子应用下的tests.py中编写测试用例。例如，我们现在已经开发了用户的注册和登录功能，那么作为后端人员/测试人员，我们就针对这些接口，要编写测试用例。



使用django提供的单元测试时，必须注意以下：

+ django提供的单元测试是不会使用原来数据库的，django在进行测试的过程中，自动根据settings配置中的DATABASE数据库连接配置项的default选项的账号，会为测试单独生成一个独立数据库。数据库的名字一般就是"`test_<NAME>`"，例如我们当前项目的数据库名称NAME = "fuguang"，则测试数据库名字则自动创建为"test_fuguang"。

+ django在每次测试时都会自动创建和删除测试数据，不管测试过程中成功了还是失败。

  当然，也可以基于终端命令把测试数据库保留下来的。

+ 因为django在测试过程中，需要创建测试数据库，所以settings中配置的数据库账号必须拥有创建数据库的权限和创建数据表的权限。

users/tests.py，代码：

```python
from django.contrib.auth import get_user_model  # 获取当前测试需要使用到的模型类

from django.test import TestCase  # 测试基类，基于这个类，可以编写测试类，用于测试代码的编写

# 因为我们现在是基于drf框架编写的restfulAPI接口，所以drf默认提供了一个发送http的客户端工具类，很方便的请求视图接口
from rest_framework.test import APIClient

# 因为接口在执行以后，很多都是通过http状态码来表达接口的操作结果是成功还是失败，所以为了方便判断，我们引入drf提供的状态码文件
from rest_framework import status

# Create your tests here.

# 编写测试的接口地址
TOKEN_URL = "/users/login/"
MOBILE_URL = "/users/mobile/"
REGISTER_URL = "/users/register/"
SMS_URL = "/users/sms/"


# 测试是不会使用原来数据库的，django会为测试单独生成数据库。
# 不管你的测试是否通过,当所有的测试都执行过后,这个测试数据库就会被销毁。
def create_user(**params):
    return get_user_model().objects.create_user(**params)

# 编写测试用例的类，测试类必须直接或间接继承于django.test.TestCase测试基类
# 这种测试类一般在测试中，也叫 "测试集"
class MobileTestCase(TestCase):
    """手机号验证相关的接口的测试集"""

    def setUp(self):
        # 相当于 __init__，setUp会在测试开始的时候，自动执行这里的代码
        self.client = APIClient()

    def test_mobile_by_unregister_mobile(self):
        """Test that a mobile phone number is pass if the mobile phone number unregister"""
        mobile = "13334500000"
        res = self.client.get(f"{MOBILE_URL}{mobile}/")
        # self.assertXX 断言，期望，相当于程序中的if。
        # self.assertXX 如果断言中的参数条件成立了，则测试通过了，如果条件不成立，则测试失败！测试失败，则证明程序编写有问题！
        # 常用断言[属于pathon默认内置的unittest测试模块内部提供的方法, unittest.case.py]
        # self.assertIn(A,B)  期望A作为B的成员存在，如果存在则断言通过，测试通过，否则失败
        # self.assertNotIn(A,B)  期望B的成员中没有A的存在，如果A不存在则断言通过，测试通过，否则失败
        # self.assertEqual(A,B) 期望A的值和B相等，如果相等则断言通过，测试通过，否则失败
        # self.assertIs(A,B) 期望A是否就是B，如果是则断言通过，测试通过，否则失败
        self.assertIn("errmsg", res.data)
        self.assertEqual("OK", res.data["errmsg"])
        self.assertEqual(res.status_code, status.HTTP_200_OK)

    def test_mobile_by_registered_mobile(self):
        """Test that a mobile phone number is pass if the mobile phone number is registered"""
        # 先注册拥有当前手机号码的用户信息
        data = {"username":"xiaoming", "password": "123456", "mobile": "13334500000"}
        create_user(**data)
        # 基于已经注册的手机号码进行单元测试
        mobile = "13334500000"
        res = self.client.get(f"{MOBILE_URL}{mobile}/")
        self.assertIn("errmsg", res.data)
        self.assertEqual("当前手机号已注册", res.data["errmsg"])
        self.assertEqual(res.status_code, status.HTTP_400_BAD_REQUEST)

    def test_mobile_by_invalid_mobile(self):
        """Test that a mobile phone number is pass if the mobile phone number is invalid"""

        # 基于已经注册的手机号码进行单元测试
        mobile = "133345000"
        res = self.client.get(f"{MOBILE_URL}{mobile}/")

        self.assertEqual(res.status_code, status.HTTP_404_NOT_FOUND)


class UserTestCase(TestCase):
    """用户相关接口的测试集"""
    def setUp(self):
        self.client = APIClient()

    def test_create_token_for_user_login_by_username(self):
        """Test that a token is created if the user login by username"""
        data = {'username': 'xiaoming', 'password': 'xiaoming123456..'}
        create_user(**data)
        res = self.client.post(TOKEN_URL, data)
        self.assertIn('token', res.data)
        self.assertEqual(res.status_code, status.HTTP_200_OK)

    def test_create_token_for_user_login_by_mobile(self):
        """Test that a token is created if the user login by username"""
        data = {'username': 'xiaoming', 'mobile': '13312345677', 'password': 'xiaoming123456..'}
        create_user(**data)
        data = {"username": "13312345677", 'password': 'xiaoming123456..'}
        res = self.client.post(TOKEN_URL, data)
        self.assertIn('token', res.data)
        self.assertEqual(res.status_code, status.HTTP_200_OK)

    def test_create_token_invalid_credentials(self):
        """Test that token is not created if invalid credentials are given"""
        create_user(username='xiaoming', password="xiaoming123456..")
        data = {'username': 'xiaoming', 'password': 'wrong'}
        res = self.client.post(TOKEN_URL, data)

        self.assertNotIn('token', res.data)
        self.assertEqual(res.status_code, status.HTTP_400_BAD_REQUEST)

    def test_create_token_no_user(self):
        """Test that token is not created if user doesn't exist"""
        data = {'username': 'xiaoming', 'password': 'xiaoming123456..'}
        res = self.client.post(TOKEN_URL, data)

        self.assertNotIn('token', res.data)
        self.assertEqual(res.status_code, status.HTTP_400_BAD_REQUEST)

    def test_create_token_missing_field(self):
        """Test that email and password are required"""
        res = self.client.post(TOKEN_URL, {'username': 'xiaoming', 'password': ''})
        self.assertNotIn('token', res.data)
        self.assertEqual(res.status_code, status.HTTP_400_BAD_REQUEST)
```

因为测试过程中， 需要的配置信息中的数据库连接信息不一致，需要拥有创建数据库权限的信息，所以我们单独为测试编写一个test.py配置文件，settings/test.py，代码：

```python
"""
Django settings for fuguangapi project.

Generated by 'django-admin startproject' using Django 3.2.9.

For more information on this file, see
https://docs.djangoproject.com/en/3.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/3.2/ref/settings/
"""
import sys
from pathlib import Path

# __file__  是一个魔术变量，代表的是当前文件的路径
# Build paths inside the project like this: BASE_DIR / 'subdir'.
# 当前项目的主应用开发目录
BASE_DIR = Path(__file__).resolve().parent.parent
# 新增apps作为导包路径，导包路径默认保存sys.path属性中，所有的python的import或者from导包语句默认都是从sys.path中记录的路径下查找模块
sys.path.insert(0, str( BASE_DIR / "apps"))
sys.path.insert(0, str( BASE_DIR / "utils") )
# print(sys.path)

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/3.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure--g(e&jha#ednlr6yppwe(*gk=l3e=7+0m37i!a8^*^6o2epgym'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = ["*"]


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',

    'rest_framework',
    'corsheaders',  # cors跨域子应用

    'home',
    'users',
]

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',  # cors跨域的中间件
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'fuguangapi.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'fuguangapi.wsgi.application'


# Database
# https://docs.djangoproject.com/en/3.2/ref/settings/#databases
# mysql / postgreSQL
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'fuguang',
        'USER': 'root',
        'PASSWORD': '123',
        'HOST': '127.0.0.1',
        'PORT': 3306,
    },
    'POOL_OPTIONS' : {      # 连接池的配置信息
        'POOL_SIZE': 10,    # 连接池默认创建的链接对象的数量
        'MAX_OVERFLOW': 10  # 连接池默认创建的链接对象的最大数量
    }
}

# redis configration
# https://django-redis-chs.readthedocs.io/zh_CN/latest/#
# 设置redis缓存
CACHES = {
    # 默认缓存
    "default": {
        "BACKEND": "django_redis.cache.RedisCache",
        # 项目上线时,需要调整这里的路径
        "LOCATION": "redis://:123456@127.0.0.1:6379/0",
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        }
    },
    # 提供给admin站点的session存储
    "session": {
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": "redis://:123456@127.0.0.1:6379/1",
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        }
    },
    # 提供存储短信验证码
    "sms_code":{
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": "redis://:123456@127.0.0.1:6379/2",
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        }
    }
}

# 设置用户登录admin站点时,记录登录状态的session保存到redis缓存中
SESSION_ENGINE = "django.contrib.sessions.backends.cache"
# 设置session保存的位置对应的缓存配置项
SESSION_CACHE_ALIAS = "session"

# Password validation
# https://docs.djangoproject.com/en/3.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/3.2/topics/i18n/

LANGUAGE_CODE = 'zh-hans'

TIME_ZONE = 'Asia/Shanghai'

USE_I18N = True

USE_L10N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/3.2/howto/static-files/

STATIC_URL = '/static/'

# 设置django的静态文件目录[手动创建]
STATICFILES_DIRS = [
    BASE_DIR / "static",
]

# 项目中存储上传文件的根目录[手动创建]，注意，uploads目录需要手动创建否则上传文件时报错
MEDIA_ROOT = BASE_DIR / "uploads"
# 访问上传文件的url地址前缀
MEDIA_URL = "/uploads/"

# Default primary key field type
# https://docs.djangoproject.com/en/3.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'


# 日志配置
# https://docs.djangoproject.com/zh-hans/3.2/topics/logging/
LOGGING = {
    'version': 1,  # 使用的日志模块的版本，目前官方提供的只有版本1，但是官方有可能会升级，为了避免升级出现的版本问题，所以这里固定为1
    'disable_existing_loggers': False,  # 是否禁用其他的已经存在的日志功能？肯定不能，有可能有些第三方模块在调用，所以禁用了以后，第三方模块无法捕获自身出现的异常了。
    'formatters': {  # 日志格式设置，verbose或者simple都是自定义的
        'verbose': {  # 详细格式，适合用于开发人员不在场的情况下的日志记录。
            # 格式定义：https://docs.python.org/3/library/logging.html#logrecord-attributes
            # levelname 日志等级
            # asctime   发生时间
            # module    文件名
            # process   进程ID
            # thread    线程ID
            # message   异常信息
            'format': '{levelname} {asctime} {module} {funcName} {process:d} {thread:d} {message}',
            'style': '{',  # 变量格式分隔符
        },
        'simple': {  # 简单格式，适合用于开发人员在场的情况下的终端输出
            'format': '{levelname} {module} {funcName} {message}',
            'style': '{',
        },
    },
    'filters': {  # 过滤器
        'require_debug_true': {
            '()': 'django.utils.log.RequireDebugTrue',
        },
    },
    'handlers': { # 日志处理流程，console或者mail_admins都是自定义的。
        'console': {
            'level': 'DEBUG', # 设置当前日志处理流程中的日志最低等级
            'filters': ['require_debug_true'], # 当前日志处理流程的日志过滤
            'class': 'logging.StreamHandler',  # 当前日志处理流程的核心类，StreamHandler可以帮我们把日志信息输出到终端下
            'formatter': 'simple'              # 当前日志处理流程的日志格式
        },
        # 'mail_admins': {
        #     'level': 'ERROR',                  # 设置当前日志处理流程中的日志最低等级
        #     'class': 'django.utils.log.AdminEmailHandler',  # AdminEmailHandler可以帮我们把日志信息输出到管理员邮箱中。
        #     'filters': ['special']             # 当前日志处理流程的日志过滤
        # }
        # 按文件大小来分割日志
        'file': {
            'level': 'DEBUG',
            'class': 'logging.handlers.RotatingFileHandler',
            # 日志位置,日志文件名，日志保存目录logs必须手动创建
            'filename': BASE_DIR.parent / "logs/fuguang.log",
            # 单个日志文件的最大值，这里我们设置300M
            'maxBytes': 300 * 1024 * 1024,
            # 备份日志文件的数量，设置最大日志数量为10
            'backupCount': 20,
            # 日志格式: 详细格式
            'formatter': 'verbose'
        },
    },
    'loggers': {  # 日志处理的命名空间
        'django': {  # 要在django中调用当前配置项的loging写入日志到文件中，名字必须叫"django"
            'handlers': ['console','file'],  # 当基于django命名空间写入日志时，调用那几个日志处理流程
            'propagate': True,   # 是否在django命名空间对应的日志处理流程结束以后，冒泡通知其他的日志功能。True表示允许
        },
    }
}

# django自定义认证
AUTHENTICATION_BACKENDS = ['fuguangapi.utils.authenticate.CustomAuthBackend', ]

# drf配置
REST_FRAMEWORK = {
    # 自定义异常处理
    'EXCEPTION_HANDLER': 'fuguangapi.utils.exceptions.exception_handler',
    # 自定义认证
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_jwt.authentication.JSONWebTokenAuthentication',  # jwt认证
        'rest_framework.authentication.SessionAuthentication',           # session认证
        'rest_framework.authentication.BasicAuthentication',
    ),
}

import datetime
# jwt认证相关配置项
JWT_AUTH = {
    # 设置jwt的有效期
    # 如果内部站点，例如：运维开发系统，OA，往往配置的access_token有效期基本就是15分钟，30分钟，1~2个小时
    # 'JWT_EXPIRATION_DELTA': datetime.timedelta(weeks=1),  # 一周有效，
    'JWT_EXPIRATION_DELTA': datetime.timedelta(minutes=1),  # 一周有效，
    # 自定义载荷
    'JWT_PAYLOAD_HANDLER': 'fuguangapi.utils.authenticate.jwt_payload_handler',
}

# CORS(跨域资源共享)
CORS_ALLOW_ALL_ORIGINS = True

# 自定义认证用户使用的模型
# AUTH_USER_MODEL` 参数的设置以`点.`来分隔，表示`应用名.模型类名`。
AUTH_USER_MODEL = 'users.User'


# 腾讯云API接口配置
TENCENTCLOUD = {
    # 腾讯云访问秘钥ID
    "SecretId": "AKIDSggmeI7z2qSUHoaf18zb4JKdZv61PEZf",
    # 腾讯云访问秘钥key
    "SecretKey": "06xbzB7VabOyY3asztbkdIfqlovtLYXG",
    # 验证码API配置
    "Captcha": {
        "endpoint": "captcha.tencentcloudapi.com", # 验证码校验服务端域名
        "CaptchaType": 9,  # 验证码类型，固定为9
        "CaptchaAppId": 2019894193,  # 验证码应用ID
        "AppSecretKey": "02CU7YteQDtXRb2QgOAwZIg**", # 验证码应用key
    },
}

# 容联云短信
RONGLIANYUN = {
    "accId": '8a216da863f8e6c20164139687e80c1b',
    "accToken": '6dd01b2b60104b3dbc88b2b74158bac6',
    "appId": '8a216da863f8e6c20164139688400c21',
    "reg_tid": 1,        # 注册短信验证码的模板ID
    "sms_expire": 300,   # 短信有效期，单位：秒(s)
    "sms_interval": 60,  # 短信发送的冷却时间，单位：秒(s)
}


# Celery异步任务队列框架的配置项[注意：django的配置项必须大写，所以这里的所有配置项必须全部大写]
# 任务队列
CELERY_BROKER_URL = 'redis://:123456@127.0.0.1:6379/14'
# 结果队列
CELERY_RESULT_BACKEND = 'redis://:123456@127.0.0.1:6379/15'
# 时区，与django的时区同步
CELERY_TIMEZONE = TIME_ZONE
# 防止死锁
CELERY_FORCE_EXECV = True
# 设置并发的worker数量
CELERYD_CONCURRENCY = 200
# 设置失败允许重试[这个慎用，如果失败任务无法再次执行成功，会产生指数级别的失败记录]
CELERY_ACKS_LATE = True
# 每个worker工作进程最多执行500个任务被销毁，可以防止内存泄漏，500是举例，根据自己的服务器的性能可以调整数值
CELERYD_MAX_TASKS_PER_CHILD = 500
# 单个任务的最大运行时间，超时会被杀死[慎用，有大文件操作、长时间上传、下载任务时，需要关闭这个选项，或者设置更长时间]
CELERYD_TIME_LIMIT = 10 * 60
# 任务发出后，经过一段时间还未收到acknowledge, 就将任务重新交给其他worker执行
CELERY_DISABLE_RATE_LIMITS = True
# celery的任务结果内容格式
CELERY_ACCEPT_CONTENT = ['json', 'pickle']

# 之前定时任务（定时一次调用），使用了apply_async({}, countdown=30);
# 设置定时任务（定时多次调用）的调用列表，需要单独运行SCHEDULE命令才能让celery执行定时任务：celery -A mycelery.main beat，当然worker还是要启动的
# https://docs.celeryproject.org/en/stable/userguide/periodic-tasks.html
from celery.schedules import crontab
CELERY_BEAT_SCHEDULE = {
    "user-add": {  # 定时任务的注册标记符[必须唯一的]
        "task": "add",   # 定时任务的任务名称
        "schedule": 10,  # 定时任务的调用时间，10表示每隔10秒调用一次add任务
        # "schedule": crontab(hour=7, minute=30, day_of_week=1),,  # 定时任务的调用时间，每周一早上7点30分调用一次add任务
    }
}
```

因为在前面开发中，基于用户的登录和注册，使用了验证码，但是测试的时候，针对用户接口，我们不需要启动这些验证码功能的代码，所以我们在所有配置文件中，新增一个配置项IS_TEST。True表示在测试环境下，False表示在其他环境下。

settings/dev.py，代码：

```python
# 是否处于测试环境下
IS_TEST = False
```

settings/pro.py，代码：

```python
# 是否处于测试环境下
IS_TEST = False
```

settings/test.py，代码：

```python
# 是否处于测试环境下
IS_TEST = True
```

为了让django启动单元测试时，调用settings/test.py配置信息，所以把manage.py复制一份，test_manage.py，代码：

```python
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'fuguangapi.settings.test')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()

```



## 运行单元测试

在django项目终端根目录下运行

不保留测试数据库

```bash
# 测试整个项目的所有测试集
python manage.py test
# 测试某个应用下的所有测试集
python manage.py test <应用目录名>
# python manage.py test users
```

保留测试数据库[推荐]

```bash
# 测试整个项目的所有测试集
python manage.py test --keepdb
# 测试某个应用下的所有测试集
python manage.py test <应用目录名> --keepdb
# python manage.py test users --keepdb
```


