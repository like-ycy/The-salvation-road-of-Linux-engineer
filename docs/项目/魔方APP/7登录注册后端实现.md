# 用户注册

我们当前开发的项目属于社交类型项目，所以关于用户的信息和功能直接贯穿了整个项目。所以此处实现用户模块功能，我们先把用户基本信息构建起来，并通过基本信息实现用户注册登录相关功能，后面遇到业务再继续扩展。

先删除原来编写在apps/home蓝图下的测试视图home.views和测试模型代码home.models，当然数据库中的测试数据和表结构也要删除。

创建并注册用户蓝图以及路由信息。

```bash
./command.sh blue users
```

application/settings/dev.py，代码：

```python
from typing import List

"""蓝图列表"""
INSTALL_BLUEPRINT: List = [
    "application.apps.home",
    "application.apps.users",
]
```

application/urls.py，代码：

```python
from typing import List
from application import path

urlpatterns: List = [
    path("/home", "home.urls"),
    path("/users", "users.urls"),
]
```

提交版本

```
git add .
git commit -m "delete home any codes and create users's module"
git push
git checkout -b feature/users
```



## 用户相关模型

模型基类

application/utils/models.py，代码：

```python
from application import db
from datetime import datetime
class BaseModel(db.Model):
    """公共模型"""
    __abstract__ = True # 抽象模型
    id = db.Column(db.Integer, primary_key=True, comment="主键ID")
    name = db.Column(db.String(255), default="", comment="名称/标题")
    is_deleted = db.Column(db.Boolean, default=False, comment="逻辑删除")
    orders = db.Column(db.Integer, default=0, comment="排序")
    status = db.Column(db.Boolean, default=True, comment="状态(是否显示,是否激活)")
    created_time = db.Column(db.DateTime, default=datetime.now, comment="创建时间")
    updated_time = db.Column(db.DateTime, default=datetime.now, onupdate=datetime.now, comment="更新时间")

    def __repr__(self):
        return "<%s: %s>" % (self.__class__.__name__, self.name)
```



application/apps/users/models.py，代码：

```python
from application.utils.models import BaseModel, db
from werkzeug.security import generate_password_hash, check_password_hash


class User(BaseModel):
    """用户基本信息表"""
    __tablename__ = "mf_user"
    name = db.Column(db.String(255), index=True, comment="用户账户")
    nickname = db.Column(db.String(255), comment="用户昵称")
    _password = db.Column(db.String(255), comment="登录密码")
    age = db.Column(db.SmallInteger, comment="年龄")
    money = db.Column(db.Numeric(10, 2), default=0.0, comment="账户余额")
    credit = db.Column(db.Numeric(10, 2), default=0.0, comment="积分余额")
    ip_address = db.Column(db.String(255), default="", index=True, comment="登录IP")
    intro = db.Column(db.String(500), default="", comment="个性签名")
    avatar = db.Column(db.String(255), default="", comment="头像url地址")
    sex = db.Column(db.SmallInteger, default=0, comment="性别")  # 0表示未设置,保密, 1表示男,2表示女
    email = db.Column(db.String(32), index=True, default="", nullable=False, comment="邮箱地址")
    mobile = db.Column(db.String(32), index=True, nullable=False, comment="手机号码")
    unique_id = db.Column(db.String(255), index=True, default="", comment="客户端唯一标记符")
    province = db.Column(db.String(255), default="", comment="省份")
    city = db.Column(db.String(255), default="", comment="城市")
    area = db.Column(db.String(255), default="", comment="地区")
    info = db.relationship("UserProfile", uselist=False, backref="user", primaryjoin="User.id==UserProfile.user_id", foreign_keys="UserProfile.user_id")

    @property
    def password(self):  # user.password
        return self._password

    @password.setter
    def password(self, rawpwd):  # user.password = '123456'
        """密码加密"""
        self._password = generate_password_hash(rawpwd)

    def check_password(self, rawpwd):
        """验证密码"""
        return check_password_hash(self.password, rawpwd)


class UserProfile(BaseModel):
    """用户详情信息表"""
    __tablename__ = "mf_user_profile"
    user_id = db.Column(db.Integer, index=True, comment="用户ID")
    education = db.Column(db.Integer, comment="学历教育")
    middle_school = db.Column(db.String(255), default="", comment="初中/中专")
    high_school = db.Column(db.String(255), default="", comment="高中/高职")
    college_school = db.Column(db.String(255), default="", comment="大学/大专")
    profession_cate = db.Column(db.String(255), default="", comment="职业类型")
    profession_info = db.Column(db.String(255), default="", comment="职业名称")
    position = db.Column(db.SmallInteger, default=0, comment="职位/职称")
    emotion_status = db.Column(db.SmallInteger, default=0, comment="情感状态")
    birthday = db.Column(db.DateTime, default="", comment="生日")
    hometown_province = db.Column(db.String(255), default="", comment="家乡省份")
    hometown_city = db.Column(db.String(255), default="", comment="家乡城市")
    hometown_area = db.Column(db.String(255), default="", comment="家乡地区")
    hometown_address = db.Column(db.String(255), default="", comment="家乡地址")
    living_province = db.Column(db.String(255), default="", comment="现居住省份")
    living_city = db.Column(db.String(255), default="", comment="现居住城市")
    living_area = db.Column(db.String(255), default="", comment="现居住地区")
    living_address = db.Column(db.String(255), default="", comment="现居住地址")


"""
 外界开发中，不过是SQLAlachemy或者django的ORM，大部分的公司都会放弃使用外键约束来关联查询数据库表。
 因为外键约束，在数据库操作过程中，需要消耗额外的维护成本来管理这个外键关系。因此在大数据的查询中，一般都会设置成逻辑外键[虚拟外键]。数据库本身维护的外键一般我们称之为 "物理外键".
"""
```

删除原来数据表，让flask重新运行项目即可创建上面模型对应的数据表了，初始化主程序中已经自动建表，`application.__init__`：

```python
# db创建数据表
with app.app_context():
    db.create_all()
```

提交版本

```bash
git add .
git commit -m "fix: add user's model"
git push --set-upstream origin feature/users
```



## 注册功能实现

#### 注册功能基本实现

##### 手机号码唯一验证接口

在开发中，针对客户端提交的数据进行验证或提供模型数据转换格式成字典给客户端。可以使用Marshmallow模块来进行。

application/apps/users/serializers.py,代码:

```python
from marshmallow import Schema, fields, validate, validates, ValidationError
from application import message
from .models import User


class MobileSchema(Schema):
    """手机号验证"""
    mobile: fields.String = fields.String(required=True, validate=validate.Regexp(
        regex=r"^1[3-9]\d{9}$",
        error=message.mobile_format_error
    ))

    @validates("mobile")
    def validates_mobile(self, mobile: str) -> str:
        # 验证手机是否已经被注册
        user: User = User.query.filter(User.mobile == mobile).first()
        if user:	
            raise ValidationError(message=message.mobile_is_used, field_name="mobile")

        return mobile

```

application/utils/message.py，服务端错误提示，代码：

```python
ok: str = "success"
mobile_format_error: str = "手机号格式有误！"
mobile_is_empty: str = "手机号不能为空！"
mobile_is_used: str = "手机号已经被注册！"

```

服务端接口操作返回状态码，application/utils/code.py，代码:

```python
CODE_OK: int = 0  # 接口操作成功
CODE_VALIDATE_ERROR: int = 1001  # 验证有误！
```

`application.__init__`，引入message，方便其他地方导报，代码：

```python
from application.utils import message, code
```

application/apps/users/api.py，视图调用序列化构造器，实现手机号验证接口，代码:

```python
from typing import Dict, Union
from application import message, code
from .serializers import MobileSchema, ValidationError


def check_mobile(mobile: str) -> Dict[str, Union[str, int]]:
    """
    验证手机号码是否已经注册
    :param mobile: 手机号码
    :return:
    """
    # 调用构造器反序列化验证
    ms: MobileSchema = MobileSchema()
    try:
        ms.load({"mobile": mobile})
        result: Dict[str, Union[str, int]] = {"errno": code.CODE_OK, "errmsg": message.ok}
    except ValidationError as e:
        result: Dict[str, Union[str, int]] = {"errno": code.CODE_VALIDATE_ERROR, "errmsg": e.messages["mobile"][0]}

    return result

```

users/urls.py，代码：

```python
from typing import List
from application import path
from . import api

apipatterns: List = [
    path("mobile", api.check_mobile),
]
```

提交版本

```bash
git add .
git commit -m "api: check mobile"
git push
```



##### 客户端进行手机号验证

main.js中对axios进行初始化，并声明一个创建UUID的方法

```javascript
class Game{
	// 主程序
	constructor(bg_music){
		// 构造函数，类似于python的 __init__()
		this.init();
    	this.play_music(bg_music);
		this.quit();
	}
	init(){
		// 初始化
		console.log("系统初始化");
    	this.rem();
		this.init_config();
		this.init_axios();
	}
	init_config(){
		// 初始化配置
		this.config = {
			"server_api": "http://192.168.19.251:5000/api", // api服务端的网关地址
		}
	}
	init_axios(){
		// 初始化axios http请求工具包
        if(window.axios && window.Vue){
			console.log("初始化axios");
			axios.defaults.baseURL = this.config.server_api    // 服务端api接口网关地址
			axios.defaults.withCredentials = false; // 跨域请求资源的情况下,忽略cookie的发送
			Vue.prototype.axios = axios;            // 给vue对象增加一个全局的属性，this.axios
		}
	}
	quit(){
		// 监听设备中的keyback按钮是否被按了
		api.addEventListener({
			name: 'keyback'
		}, (ret, err) => {
			// 弹出一个确认框
			var windows = api.windows()
			if(windows.length>1){
				// 如果当前APP打开了多个窗口，则直接关闭窗口
				this.outWin();
			}else{
				// 如果当前APP只打开了一个窗口，则弹窗确认用户是否退出当前APP
				api.confirm({
					title: '系统提示',
					msg: '您确认退出魔方APP吗？',
					buttons: ['退出', '取消']
				}, (ret, err) => {
					var index = ret.buttonIndex;
					if(index === 1) {
						this.outWin();
					}
				});
			}
		});
	}
	print(data,show=false){
		// 打印数据
		if(show){
			// 以弹窗的方式打印数据
			api.alert({"msg": JSON.stringify(data)});
		}else{
			// 以终端的方式打印数据
			console.log(JSON.stringify(data));
		}
	}
	rem(){
		// 页面自适配方法
		if(window.innerWidth<1200){
			this.UIWidth = document.documentElement.clientWidth;
			this.UIHeight = document.documentElement.clientHeight;
			document.documentElement.style.fontSize = (0.01*this.UIWidth*3)+"px";
			document.querySelector("#app").style.height=this.UIHeight+"px"
		}
		window.onresize = ()=>{
			if(window.innerWidth<1200){
				this.UIWidth = document.documentElement.clientWidth;
				this.UIHeight = document.documentElement.clientHeight;
				document.documentElement.style.fontSize = (0.01*this.UIWidth*3)+"px";
			}
		}
	}
	stop_music(){
		this.print("停止音乐")
		try {
			document.body.removeChild(this.audio);
		} catch (error) {
			this.print(error)
		}
	}
	play_music(src){
		this.print("播放音乐")
		try {
			this.audio = document.createElement("audio");
			this.source = document.createElement("source");
			this.source.type = "audio/mp3";
			this.audio.autoplay = "autoplay";
			this.source.src=src;
			this.audio.appendChild(this.source);
			document.body.appendChild(this.audio);
			var t = setInterval(()=>{
				if(this.audio.readyState > 0){
					if(this.audio.ended){
						clearInterval(t);
						document.body.removeChild(this.audio);
					}
				}
			},100);
		} catch (error) {
			this.print(error);
		}
	}

	goWin(name, url, pageParam){
		// 打开窗口
		api.openWin({
		    name: name,            // 自定义窗口名称
		    bounces: false,        // 窗口是否上下拉动
		    reload: true,          // 如果页面已经在之前被打开了,是否要重新加载当前窗口中的页面
		    url: url,              // 窗口创建时展示的html页面的本地路径[相对于当前代码所在文件的路径]
		    animation:{            // 打开新建窗口时的过渡动画效果
		    	type: "push",                //动画类型（详见动画类型常量）
		    	subType: "from_right",       //动画子类型（详见动画子类型常量）
		    	duration:300                 //动画过渡时间，默认300毫秒
		    },
		    pageParam: pageParam   // 传递给下一个窗口使用的参数.将来可以在新窗口中通过 api.pageParam.name 获取
		});
	}
	outWin(name){
		// 关闭窗口
		api.closeWin({
			name: name
		});
	}

	goFrame(name, url, pageParam){
		// 打开帧页面
		api.openFrame({
				name: name,
				url: url,
				rect: {
						x: 0,
						y: 0,
						w: 'auto',
						h: 'auto'
				},
				useWKWebView: true,
				historyGestureEnabled: true,
				bounces: false,
				animation:{
							type:"push",
							subType: "from_right",
							duration:300
				},
				pageParam: pageParam
		});
	}

	outFrame(name){
		// 关闭帧页面
		api.closeFrame({
		    name: name,
		});
	}

	uuid(){
		// UUID
		return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c)=>{
			var r = Math.random()*16|0,v=c=='x'?r:r&0x3|0x8;
			return v.toString(16);
		})
	}
}

```

html/register.html，注册页面请求手机验证，代码：

```html
<!DOCTYPE html>
<html>
<head>
	<title>注册</title>
	<meta name="viewport" content="width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
	<meta charset="utf-8">
	<link rel="stylesheet" href="../css/main.css">
	<script src="../script/vue.js"></script>
	<script src="../script/axios.js"></script>
	<script src="../script/main.js"></script>
</head>
<body>
	<div class="app" id="app">
        <img class="music" :class="music_play?'music2':''" @click="music_play=!music_play" src="../image/player.png">
        <div class="bg">
            <img src="../image/bg0.jpg">
        </div>
		<div class="form">
			<div class="form-title">
				<img src="../image/register.png">
				<img class="back" @click="open_login" src="../image/back.png">
			</div>
			<div class="form-data">
				<div class="form-data-bg">
					<img src="../image/bg1.png">
				</div>
				<div class="form-item">
					<label class="text">手机</label>
					<input type="text" v-model="mobile" placeholder="请输入手机号">
				</div>
				<div class="form-item">
					<label class="text">验证码</label>
					<input type="text" class="code" name="code" placeholder="请输入验证码">
					<img class="refresh" src="../image/refresh.png">
				</div>
				<div class="form-item">
					<label class="text">密码</label>
					<input type="password" name="password" placeholder="请输入密码">
				</div>
				<div class="form-item">
					<label class="text">确认密码</label>
					<input type="password" name="password2" placeholder="请再次输入密码">
				</div>
				<div class="form-item">
					<input type="checkbox" class="agree" name="agree" checked>
					<label><span class="agree_text">同意磨方《用户协议》和《隐私协议》</span></label>
				</div>
				<div class="form-item">
					<img class="commit" @click="game.play_music('../mp3/btn1.mp3')" src="../image/commit.png"/>
				</div>
			</div>
		</div>
	</div>
	<script>
    apiready = function(){
        Vue.prototype.game = new Game("../mp3/bg1.mp3");
        new Vue({
            el:"#app",
            data(){
                return {
					mobile: "",
                    music_play: true,
                }
            },
            watch:{
                music_play(){
                    if(this.music_play){
                        this.game.play_music("../mp3/bg1.mp3");
                    }else{
                        this.game.stop_music();
                    }
                },
				mobile(){
					if( /^1[3-9]\d{9}$/.test(this.mobile) ){
						this.check_mobile()
					}
				}
            },
            methods:{
                open_login(){
                    this.game.outFrame();
                },
				check_mobile(){
					let uuid = this.game.uuid();

					this.axios.post("",{
					    "jsonrpc": "2.0",
					    "id": uuid,
					    "method": "Users.mobile",
					    "params": {"mobile": this.mobile}
					}).then(response=>{
						if(response.data.result.errno !== 0){
							api.alert({
							    title: "错误警告",
							    msg: response.data.result.errmsg,
							});
						}
					}).catch(error=>{
						this.game.print(error.response.data.error);
					});
				}
            }
		})
	}
	</script>
</body>
</html>
```



##### 保存用户注册信息接口

创建Marshmallow构造器[暂时不涉及到手机验证码功能]

users/serializers.py，代码：

```python
from typing import List, Dict
from flask_marshmallow.sqla import SQLAlchemyAutoSchema, auto_field
from marshmallow import Schema, fields, validate, validates, ValidationError, decorators
from sqlalchemy.orm import scoped_session
from application import message, db
from .models import User


# ... 中间省略

class UserSchema(SQLAlchemyAutoSchema):
    """用户注册信息验证"""
    mobile: fields.String = auto_field(required=True, load_only=True, validates=validate.Regexp(
        regex="^1[3-9]\d{9}$",
        error=message.mobile_format_error
    ))
    password: fields.String = fields.String(required=True, load_only=True, validate=validate.Length(
        min=6,
        max=16,
        error=message.password_format_error
    ))
    password2: fields.String = fields.String(required=True, load_only=True)
    sms_code: fields.String = fields.String(required=True, load_only=True, validate=validate.Length(
        min=4,
        max=4,
        error=message.sms_code_format_error
    ))

    class Meta:
        model: User = User
        include_fk: bool = True  # 启用外键关系
        include_relationships: bool = True  # 模型关系外部属性
        fields: List[str] = ["id", "name", "mobile", "password", "password2",
                             "sms_code"]  # 如果要全换全部字段，就不要声明fields或exclude字段即可
        sqla_session: scoped_session = db.session

    @decorators.validates_schema
    def validate(self, data, **kwargs) -> Dict[str, str]:
        # 校验密码和确认密码
        if data["password"] != data["password2"]:
            raise ValidationError(message=message.password_not_match, field_name="password")

        # todo 校验短信验证码

        data.pop("password2")
        data.pop("sms_code")
        return data

    @decorators.post_load
    def save_object(self, data, **kwargs) -> User:
        print(data)
        data["name"] = data["mobile"]
        user: User = User(**data)
        self.session.add(user)
        self.session.commit()
        return user

```

users.api，视图代码：

```python
from typing import Dict, Union, Any
from application import message, code
from .serializers import MobileSchema, ValidationError, UserSchema
from .models import User


# ... 中间代码省略


def register(mobile: str, password: str, password2: str, sms_code: str) -> Dict[str, Any]:
    """
    用户信息注册
    :param mobile: 手机号
    :param password: 登录密码
    :param password2: 确认密码
    :param sms_code: 短信验证码
    :return:
    """
    try:
        ms: MobileSchema = MobileSchema()
        ms.load({"mobile": mobile})

        us: UserSchema = UserSchema()
        user: User = us.load({
            "mobile": mobile,
            "password": password,
            "password2": password2,
            "sms_code": sms_code
        })
        result: Dict[str, Union[str, Any]] = {"errno": code.CODE_OK, "errmsg": us.dump(user)}
    except ValidationError as e:
        result: Dict[str, Union[str, Any]] = {"errno": code.CODE_VALIDATE_ERROR, "errmsg": e.messages}
    return result


```

users.urls，代码：

```python
from typing import List
from application import path
from . import api

apipatterns: List = [
    path("mobile", api.check_mobile),
    path("register", api.register),
]
```

utils/message.py,代码:

```python
ok: str = "success"
mobile_format_error: str = "手机号格式有误！"
mobile_is_empty: str = "手机号不能为空！"
mobile_is_used: str = "手机号已经被注册！"
password_not_match: str = "密码和确认不一致！"
password_format_error: str = "密码长度有误，必须在{min}~{max}个字符长度之间"
sms_code_format_error: str = "验证码格式错误，必须是{min}个字符长度"

```

提交版本

```bash
git add .
git commit -m "api: user register"
git push
```



##### 客户端发送用户进行注册

`html/register.html`,代码:

```html
<!DOCTYPE html>
<html>
<head>
	<title>注册</title>
	<meta name="viewport" content="width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
	<meta charset="utf-8">
	<link rel="stylesheet" href="../css/main.css">
	<script src="../script/vue.js"></script>
	<script src="../script/axios.js"></script>
	<script src="../script/main.js"></script>
</head>
<body>
	<div class="app" id="app">
        <img class="music" :class="music_play?'music2':''" @click="music_play=!music_play" src="../image/player.png">
        <div class="bg">
            <img src="../image/bg0.jpg">
        </div>
		<div class="form">
			<div class="form-title">
				<img src="../image/register.png">
				<img class="back" @click="open_login" src="../image/back.png">
			</div>
			<div class="form-data">
				<div class="form-data-bg">
					<img src="../image/bg1.png">
				</div>
				<div class="form-item">
					<label class="text">手机</label>
					<input type="text" v-model="mobile" placeholder="请输入手机号">
				</div>
				<div class="form-item">
					<label class="text">验证码</label>
					<input type="text" class="code" v-model="sms_code" placeholder="请输入验证码">
					<img class="refresh" src="../image/refresh.png">
				</div>
				<div class="form-item">
					<label class="text">密码</label>
					<input type="password" v-model="password" placeholder="请输入密码">
				</div>
				<div class="form-item">
					<label class="text">确认密码</label>
					<input type="password" v-model="password2" placeholder="请再次输入密码">
				</div>
				<div class="form-item">
					<input type="checkbox" class="agree" v-model="agree" checked>
					<label><span class="agree_text">同意磨方《用户协议》和《隐私协议》</span></label>
				</div>
				<div class="form-item">
					<img class="commit" @click="registerHandle" src="../image/commit.png"/>
				</div>
			</div>
		</div>
	</div>
	<script>
    apiready = function(){
        Vue.prototype.game = new Game("../mp3/bg1.mp3");
        new Vue({
            el:"#app",
            data(){
                return {
					mobile: "13312345677",
					sms_code: "1234",
					password: "123456",
					password2: "123456",
					agree: true,
                    music_play: true,
                }
            },
            watch:{
                music_play(){
                    if(this.music_play){
                        this.game.play_music("../mp3/bg1.mp3");
                    }else{
                        this.game.stop_music();
                    }
                },
				mobile(){
					if( /^1[3-9]\d{9}$/.test(this.mobile) ){
						this.check_mobile()
					}
				}
            },
            methods:{
                open_login(){
					// 剔除当前页面
                    this.game.outFrame();
                },
				check_mobile(){
					// 验证手机号
					this.axios.post("",{
					    "jsonrpc": "2.0",
					    "id": this.game.uuid(),
					    "method": "Users.mobile",
					    "params": {"mobile": this.mobile}
					}).then(response=>{
						if(response.data.result.errno !== 0){
							api.alert({
							    title: "错误警告",
							    msg: response.data.result.errmsg,
							});
						}
					}).catch(error=>{
						this.game.print(error.response.data.error);
					});
				},
				registerHandle(){
					// 注册处理
					this.game.play_music('../mp3/btn1.mp3');  // 点击按钮声音
					// 验证数据[双向验证]
					if (!/1[3-9]\d{9}/.test(this.mobile)){
						this.game.tips("手机号格式不正确！");
						return; // 阻止代码继续往下执行
					}

					if(this.password.length<6 || this.password.length > 16){
						this.game.tips("密码长度必须在6-16个字符之间!");
						return;
					}

					if(this.password != this.password2){
						this.game.tips("密码和确认密码不匹配!");
						return; // 阻止代码继续往下执行
					}

					if(this.sms_code.length < 1){
						this.game.tips("验证码不能为空！");
						return; // 阻止代码继续往下执行
					}

					if(this.agree === false){
						this.game.tips("必须同意魔方APP的用户协议和隐私协议才能继续注册!");
						return; // 阻止代码继续往下执行
					}

					// 提交注册信息
					this.axios.post("",{
						"jsonrpc": "2.0",
						"id": this.game.uuid(),
						"method": "Users.register",
						"params": {
							"mobile": this.mobile,
							"sms_code": this.sms_code,
							"password": this.password,
							"password2": this.password2,
						}
					}).then(response=>{
						if(response.data.result.errno !== 0){
							api.alert({
							    title: "错误提示",
							    msg: response.data.result.errmsg,
							});
						}else{
							// 注册成功!
							api.confirm({
							    title: '系统提示',
							    msg: '注册成功',
							    buttons: ['返回首页', '个人中心']
							}, (ret, err)=>{
							    if(ret.buttonIndex == 1){
									// 跳转到首页
									this.game.goWin("root","./index.html");
								}else{
									// 跳转到个人中心
									this.game.goWin("user","./user.html");
								}
								// 2秒后关闭当前窗口
								setTimeout(() => {
									this.game.outWin();
								}, 2000);
							});
						}

					}).catch(error=>{
						this.game.print(error.response.data.error);
					});



				}
            }
		})
	}
	</script>
</body>
</html>
```

main.js，提供了一个消息提示功能，代码；

```javascript
class Game{
	// 主程序
	constructor(bg_music){
		// 构造函数，类似于python的 __init__()
		this.init();
    	this.play_music(bg_music);
		this.quit();
	}
	init(){
		// 初始化
		this.print("系统初始化");
    	this.rem();
		this.init_config();
		this.init_axios();
	}
	init_config(){
		// 初始化配置
		this.config = {
			"server_api": "http://192.168.19.251:5000/api", // api服务端的网关地址
		}
	}
	init_axios(){
		// 初始化axios http请求工具包
        if(window.axios && window.Vue){
			this.print("初始化axios");
			axios.defaults.baseURL = this.config.server_api    // 服务端api接口网关地址
			axios.defaults.withCredentials = false; // 跨域请求资源的情况下,忽略cookie的发送
			Vue.prototype.axios = axios;            // 给vue对象增加一个全局的属性，this.axios
		}
	}
	quit(){
		// 监听设备中的keyback按钮是否被按了
		api.addEventListener({
			name: 'keyback'
		}, (ret, err) => {
			// 弹出一个确认框
			var windows = api.windows()
			if(windows.length>1){
				// 如果当前APP打开了多个窗口，则直接关闭窗口
				this.outWin();
			}else{
				// 如果当前APP只打开了一个窗口，则弹窗确认用户是否退出当前APP
				api.confirm({
					title: '系统提示',
					msg: '您确认退出魔方APP吗？',
					buttons: ['退出', '取消']
				}, (ret, err) => {
					var index = ret.buttonIndex;
					if(index === 1) {
						this.outWin();
					}
				});
			}
		});
	}
	print(data,show=false){
		// 打印数据
		if(show){
			// 以弹窗的方式打印数据
			api.alert({"msg": JSON.stringify(data)});
		}else{
			// 以终端的方式打印数据
			console.log(JSON.stringify(data));
		}
	}
	rem(){
		// 页面自适配方法
		if(window.innerWidth<1200){
			this.UIWidth = document.documentElement.clientWidth;
			this.UIHeight = document.documentElement.clientHeight;
			document.documentElement.style.fontSize = (0.01*this.UIWidth*3)+"px";
			document.querySelector("#app").style.height=this.UIHeight+"px"
		}
		window.onresize = ()=>{
			if(window.innerWidth<1200){
				this.UIWidth = document.documentElement.clientWidth;
				this.UIHeight = document.documentElement.clientHeight;
				document.documentElement.style.fontSize = (0.01*this.UIWidth*3)+"px";
			}
		}
	}
	stop_music(){
		this.print("停止音乐")
		try {
			document.body.removeChild(this.audio);
		} catch (error) {
			this.print(error)
		}
	}
	play_music(src){
		this.print("播放音乐")
		try {
			this.audio = document.createElement("audio");
			this.source = document.createElement("source");
			this.source.type = "audio/mp3";
			this.audio.autoplay = "autoplay";
			this.source.src=src;
			this.audio.appendChild(this.source);
			document.body.appendChild(this.audio);
			var t = setInterval(()=>{
				if(this.audio.readyState > 0){
					if(this.audio.ended){
						clearInterval(t);
						document.body.removeChild(this.audio);
					}
				}
			},100);
		} catch (error) {
			this.print(error);
		}
	}

	goWin(name, url, pageParam){
		// 打开窗口
		api.openWin({
		    name: name,            // 自定义窗口名称
		    bounces: false,        // 窗口是否上下拉动
		    reload: true,          // 如果页面已经在之前被打开了,是否要重新加载当前窗口中的页面
		    url: url,              // 窗口创建时展示的html页面的本地路径[相对于当前代码所在文件的路径]
		    animation:{            // 打开新建窗口时的过渡动画效果
		    	type: "push",                //动画类型（详见动画类型常量）
		    	subType: "from_right",       //动画子类型（详见动画子类型常量）
		    	duration:300                 //动画过渡时间，默认300毫秒
		    },
		    pageParam: pageParam   // 传递给下一个窗口使用的参数.将来可以在新窗口中通过 api.pageParam.name 获取
		});
	}
	outWin(name){
		// 关闭窗口
		api.closeWin({
			name: name
		});
	}

	goFrame(name, url, pageParam){
		// 打开帧页面
		api.openFrame({
				name: name,
				url: url,
				rect: {
						x: 0,
						y: 0,
						w: 'auto',
						h: 'auto'
				},
				useWKWebView: true,
				historyGestureEnabled: true,
				bounces: false,
				animation:{
							type:"push",
							subType: "from_right",
							duration:300
				},
				pageParam: pageParam
		});
	}

	outFrame(name){
		// 关闭帧页面
		api.closeFrame({
		    name: name,
		});
	}

	uuid(){
		// UUID
		return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c)=>{
			var r = Math.random()*16|0,v=c=='x'?r:r&0x3|0x8;
			return v.toString(16);
		})
	}

	tips(msg, location='middle'){
		// 消息提示
		api.toast({
			msg: msg,
			duration: 3000,
			location: location
		});
	}
}

```

html/user.html，代码：

```vue
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>用户中心</h1>
</body>
</html>
```



在`html/index.html`，新增用户中心页面`user.html`的链接跳转，代码：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <title>首页</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
    <meta name="format-detection" content="telephone=no,email=no,date=no,address=no">
    <link rel="stylesheet" href="../css/main.css">
	<script src="../script/vue.js"></script>
	<script src="../script/axios.js"></script>
	<script src="../script/main.js"></script>
</head>
<body>
  <div class="app" id="app">
    <img class="music" :class="music_play?'music2':''" @click="music_play=!music_play" src="../image/player.png">
    <div class="bg">
      <img src="../image/bg0.jpg">
    </div>
    <ul>
      <li><img class="module1" src="../image/image1.png"></li> <!-- 果园 -->
      <li><img class="module2" @click="open_user" src="../image/image2.png"></li> <!-- 会员 -->
      <li><img class="module3" src="../image/image3.png"></li> <!-- 娱乐 -->
      <li><img class="module4" @click="open_login" src="../image/image4.png"></li> <!-- 签到 -->
    </ul>
  </div>
  <script>
	apiready = function(){
		Vue.prototype.game = new Game("../mp3/bg1.mp3");  // vue3.0里面需要修改这句代码
		new Vue({
			el:"#app",
			data(){
				return {
                    music_play: true,  // 默认播放背景音乐
                }
			},
            watch:{
                music_play(){
                    if(this.music_play){
                        this.game.play_music("../mp3/bg1.mp3");
                    }else{
                        this.game.stop_music();
                    }
                }
            },
            methods:{
                open_login(){
                    this.game.goWin("login","./login.html");
                },
                open_user(){
                    this.game.goWin("user","./user.html");
                }
            }
		})
	}
	</script>
</body>
</html>
```



#### 使用云通讯发送短信

官方文档：https://www.yuntongxun.com/member/main

在登录后的平台上面获取一下信息:

```
ACCOUNT SID：8a216da863f8e6c20164139687e80c1b
AUTH TOKEN : 6dd01b2b60104b3dbc88b2b74158bac6
AppID(默认)：8a216da863f8e6c20164139688400c21
Rest URL(短信服务器)： app.cloopen.com:8883
```

在开发过程中,为了节约发送短信的成本,可以把自己的或者同事的手机加入到测试号码中.


安装sdk

```bash
pip install ronglian_sms_sdk
```



#### 服务端实现发送短信验证码的api接口

application/settings/dev.py，配置文件中填写短信接口相关配置，代码：

```python
"""短信相关配置"""
SMS_ACCOUNT_ID: str = "8a216da863f8e6c20164139687e80c1b"  # 接口主账号
SMS_ACCOUNT_TOKEN: str = "6dd01b2b60104b3dbc88b2b74158bac6"  # 认证token令牌
SMS_APP_ID: str = "8a216da863f8e6c20164139688400c21"  # 应用ID
SMS_TEMPLATE_ID: int = 1  # 短信模板ID
SMS_EXPIRE_TIME: int = 60 * 5  # 短信有效时间，单位:秒/s
SMS_INTERVAL_TIME: int = 60  # 短信发送冷却时间，单位:秒/s
```

`application/apps/users/api.py`，代码：

```python
import random, json

from typing import Dict, Union, Any

from flask import current_app
from ronglian_sms_sdk import SmsSDK
from redis.client import Pipeline

from application import message, code, redis_check as redis
from .serializers import MobileSchema, ValidationError, UserSchema
from .models import User


# ...中间代码省略


def sms(mobile: str) -> Dict[str, Any]:
    """
    发送短信验证码
    :param mobile: 手机号
    :return:
    """
    # 验证手机
    ret: Dict[str, Any] = check_mobile(mobile=mobile)
    if ret["errno"] != 0:
        return ret

    # 短信发送冷却时间
    ret: int = redis.ttl("int_%s" % mobile)
    if ret > 0:
        return {
            "errno": code.CODE_INTERVAL_TIME,
            "errmsg": message.sms_interval_time,
            "data": {
                "time": ret,
            }
        }

    # 生成验证码
    sms_code: str = "%04d" % random.randint(0, 9999)

    # 实例化SDK
    sdk: SmsSDK = SmsSDK(
        current_app.config.get("SMS_ACCOUNT_ID"),
        current_app.config.get("SMS_ACCOUNT_TOKEN"),
        current_app.config.get("SMS_APP_ID")
    )

    # 发送短信
    ret: str = sdk.sendMessage(
        current_app.config.get("SMS_TEMPLATE_ID"),
        mobile,
        (sms_code, current_app.config.get("SMS_EXPIRE_TIME") // 60)
    )

    # 获取接口操作的结果
    result: Dict[str, Any] = json.loads(ret)

    if result["statusCode"] == "000000":
        pipe: Pipeline = redis.pipeline()
        pipe.multi()  # 开启事务
        # 保存短信记录到redis中
        pipe.setex("sms_%s" % mobile, current_app.config.get("SMS_EXPIRE_TIME"), sms_code)
        # 进行冷却倒计时
        pipe.setex("int_%s" % mobile, current_app.config.get("SMS_INTERVAL_TIME"), "_")
        pipe.execute()  # 提交事务

        # 返回结果
        result: Dict[str, Any] = {"errno": code.CODE_OK, "errmsg": message.ok}

    else:
        result: Dict[str, Any] = {"errno": code.CODE_SMS_ERROR, "errmsg": message.sms_send_error}

    return result
```



users/urls.py，代码：

```python
from typing import List
from application import path
from . import api

apipatterns: List = [
    path("mobile", api.check_mobile),
    path("register", api.register),
    path("sms", api.sms),
]
```

message，代码：

```python
sms_interval_time: str = "短信发送过于频繁！"
sms_send_error: str = "短信发送失败！"
```

code.py，代码：

```python
CODE_OK: int = 0  # 接口操作成功
CODE_VALIDATE_ERROR: int = 1001  # 验证有误！
CODE_INTERVAL_TIME: int = 1002 # 接口操作过于频繁!

CODE_SMS_ERROR: int = 1100  # 短信发送失败！
```

提交版本

```bash
git add .
git commit -m "api : send sms"
git push
```



#### 客户端实现点击发送短信

html/register.html，代码：

```html
<!DOCTYPE html>
<html>
<head>
	<title>注册</title>
	<meta name="viewport" content="width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
	<meta charset="utf-8">
	<link rel="stylesheet" href="../css/main.css">
	<script src="../script/vue.js"></script>
	<script src="../script/axios.js"></script>
	<script src="../script/main.js"></script>
</head>
<body>
	<div class="app" id="app">
        <img class="music" :class="music_play?'music2':''" @click="music_play=!music_play" src="../image/player.png">
        <div class="bg">
            <img src="../image/bg0.jpg">
        </div>
		<div class="form">
			<div class="form-title">
				<img src="../image/register.png">
				<img class="back" @click="open_login" src="../image/back.png">
			</div>
			<div class="form-data">
				<div class="form-data-bg">
					<img src="../image/bg1.png">
				</div>
				<div class="form-item">
					<label class="text">手机</label>
					<input type="text" v-model="mobile" placeholder="请输入手机号">
				</div>
				<div class="form-item">
					<label class="text">验证码</label>
					<input type="text" class="code" v-model="sms_code" placeholder="请输入验证码">
					<img class="refresh" @click="send" src="../image/refresh.png">
				</div>
				<div class="form-item">
					<label class="text">密码</label>
					<input type="password" v-model="password" placeholder="请输入密码">
				</div>
				<div class="form-item">
					<label class="text">确认密码</label>
					<input type="password" v-model="password2" placeholder="请再次输入密码">
				</div>
				<div class="form-item">
					<input type="checkbox" class="agree" v-model="agree" checked>
					<label><span class="agree_text">同意磨方《用户协议》和《隐私协议》</span></label>
				</div>
				<div class="form-item">
					<img class="commit" @click="registerHandle" src="../image/commit.png"/>
				</div>
			</div>
		</div>
	</div>
	<script>
    apiready = function(){
        Vue.prototype.game = new Game("../mp3/bg1.mp3");
        new Vue({
            el:"#app",
            data(){
                return {
					mobile: "13312345677",
					sms_code: "1234",
					password: "123456",
					password2: "123456",
					agree: true,
                    music_play: true,
					is_send: false,     // 短信发送的冷却状态，false表示没有冷却，true表示进入冷却状态
					send_interval: 60,  // 短信发送冷却时间
					timer: null,        // 定时器的标识符
                }
            },
            watch:{
                music_play(){
                    if(this.music_play){
                        this.game.play_music("../mp3/bg1.mp3");
                    }else{
                        this.game.stop_music();
                    }
                },
				mobile(){
					if( /^1[3-9]\d{9}$/.test(this.mobile) ){
						this.check_mobile()
					}
				}
            },
            methods:{
                open_login(){
					// 剔除当前页面
                    this.game.outFrame();
                },
				check_mobile(){
					// 验证手机号
					this.axios.post("",{
					    "jsonrpc": "2.0",
					    "id": this.game.uuid(),
					    "method": "Users.mobile",
					    "params": {"mobile": this.mobile}
					}).then(response=>{
						if(response.data.result.errno !== 0){
							api.alert({
							    title: "错误警告",
							    msg: response.data.result.errmsg,
							});
						}
					}).catch(error=>{
						this.game.print(error.response.data.error);
					});
				},
				registerHandle(){
					// 注册处理
					this.game.play_music('../mp3/btn1.mp3');  // 点击按钮声音
					// 验证数据[双向验证]
					if (!/1[3-9]\d{9}/.test(this.mobile)){
						this.game.tips("手机号格式不正确！");
						return; // 阻止代码继续往下执行
					}

					if(this.password.length<6 || this.password.length > 16){
						this.game.tips("密码长度必须在6-16个字符之间!");
						return;
					}

					if(this.password != this.password2){
						this.game.tips("密码和确认密码不匹配!");
						return; // 阻止代码继续往下执行
					}

					if(this.sms_code.length < 1){
						this.game.tips("验证码不能为空！");
						return; // 阻止代码继续往下执行
					}

					if(this.agree === false){
						this.game.tips("必须同意魔方APP的用户协议和隐私协议才能继续注册!");
						return; // 阻止代码继续往下执行
					}

					// 提交注册信息
					this.axios.post("",{
						"jsonrpc": "2.0",
						"id": this.game.uuid(),
						"method": "Users.register",
						"params": {
							"mobile": this.mobile,
							"sms_code": this.sms_code,
							"password": this.password,
							"password2": this.password2,
						}
					}).then(response=>{
						if(response.data.result.errno !== 0){
							api.alert({
							    title: "错误提示",
							    msg: response.data.result.errmsg,
							});
						}else{
							// 注册成功!
							api.confirm({
							    title: '系统提示',
							    msg: '注册成功',
							    buttons: ['返回首页', '个人中心']
							}, (ret, err)=>{
							    if(ret.buttonIndex == 1){
									// 跳转到首页
									this.game.goWin("root","./index.html");
								}else{
									// 跳转到个人中心
									this.game.goWin("user","./user.html");
								}
								// 2秒后关闭当前窗口
								setTimeout(() => {
									this.game.outWin();
								}, 2000);
							});
						}

					}).catch(error=>{
						this.game.print(error.response.data.error);
					});



				},
				send(){
					// 发送短信
					if (!/1[3-9]\d{9}/.test(this.mobile)){
						this.game.tips("手机号格式不正确！");
						return; // 阻止代码继续往下执行
					}

					if(this.is_send){
						this.game.tips(`短信发送冷却中,请${this.send_interval}秒之后重新点击发送!`);
						return; // 阻止代码继续往下执行
					}

					this.axios.post("",{
						"jsonrpc": "2.0",
						"id": this.game.uuid(),
						"method": "Users.sms",
						"params": {
							"mobile": this.mobile,
						}
					}).then(response=>{
						if(response.data.result.errno === 0){
							// 短信已经发送....
							this.game.tips("短信已经发送，请留意手机！");
							this.is_send=true; // 进入冷却状态
							this.send_interval = 60;
							var timer = setInterval(()=>{
								this.send_interval--;
								if(this.send_interval<1){
									clearInterval(timer);
									this.is_send=false;  // 退出冷却状态
								}
							}, 1000);
						}else{
							// 发送短信失败！
							api.alert({
							    title: "系统警告",
							    msg: response.data.result.errmsg,
							});
							if(response.data.result.errno === 1002){
								this.send_interval = response.data.result.data.time; // 获取服务端返回的冷却时间
								this.is_send=true;
								var timer = setInterval(()=>{
									this.send_interval--;
									if(this.send_interval<1){
										clearInterval(timer);
										this.is_send=false;  // 退出冷却状态
									}
								}, 1000);
							}

						}

					}).catch(error=>{
						this.game.print(error.response.data.error);
					});
				}
            }
		})
	}
	</script>
</body>
</html>
```



### 完成短信验证码的校验

`application.apps.ursers.serialziers`,代码:

```python
from typing import List, Dict, Optional
from flask_marshmallow.sqla import SQLAlchemyAutoSchema, auto_field
from marshmallow import Schema, fields, validate, validates, ValidationError, decorators
from sqlalchemy.orm import scoped_session

from application import message, db, redis_check as redis
from .models import User


class MobileSchema(Schema):
    """手机号验证"""
    mobile: fields.String = fields.String(required=True, validate=validate.Regexp(
        regex=r"^1[3-9]\d{9}$",
        error=message.mobile_format_error
    ))

    @validates("mobile")
    def validates_mobile(self, mobile: str) -> str:
        # 验证手机是否已经被注册
        user: User = User.query.filter(User.mobile == mobile).first()
        if user:
            raise ValidationError(message=message.mobile_is_used, field_name="mobile")

        return mobile


class UserSchema(SQLAlchemyAutoSchema):
    """用户注册信息验证"""
    mobile: fields.String = auto_field(required=True, load_only=True, validates=validate.Regexp(
        regex="^1[3-9]\d{9}$",
        error=message.mobile_format_error
    ))
    password: fields.String = fields.String(required=True, load_only=True, validate=validate.Length(
        min=6,
        max=16,
        error=message.password_format_error
    ))
    password2: fields.String = fields.String(required=True, load_only=True)
    sms_code: fields.String = fields.String(required=True, load_only=True, validate=validate.Length(
        min=4,
        max=4,
        error=message.sms_code_format_error
    ))

    class Meta:
        model: User = User
        include_fk: bool = True  # 启用外键关系
        include_relationships: bool = True  # 模型关系外部属性
        fields: List[str] = ["id", "name", "mobile", "password", "password2",
                             "sms_code"]  # 如果要全换全部字段，就不要声明fields或exclude字段即可
        sqla_session: scoped_session = db.session

    @decorators.validates_schema
    def validate(self, data, **kwargs) -> Dict[str, str]:
        # 校验密码和确认密码
        if data["password"] != data["password2"]:
            raise ValidationError(message=message.password_not_match, field_name="password")

        # 校验短信验证码
        # 1. 从redis中提取验证码
        redis_sms_code: Optional[bytes] = redis.get("sms_%s" % data["mobile"])
        if redis_sms_code is None:
            raise ValidationError(message=message.sms_code_expired, field_name="sms_code")
        redis_sms_code: str = redis_sms_code.decode()

        # 2. 从客户端提交的数据data中提取验证码
        sms_code: str = data["sms_code"]

        # 3. 删除redis中的验证码[减少暴力破解的风险]
        redis.delete("sms_%s" % data["mobile"])

        # 4. 字符串比较，如果失败，则抛出异常，否则，直接删除验证码
        if sms_code != redis_sms_code:
            raise ValidationError(message=message.sms_code_not_match, field_name="sms_code")

        data.pop("password2")
        data.pop("sms_code")
        return data

    @decorators.post_load
    def save_object(self, data, **kwargs) -> User:
        print(data)
        data["name"] = data["mobile"]
        user: User = User(**data)
        self.session.add(user)
        self.session.commit()
        return user

```

`application.utils.language.message_text`, 代码:

```python
ok: str = "success"
mobile_format_error: str = "手机号格式有误！"
mobile_is_empty: str = "手机号不能为空！"
mobile_is_used: str = "手机号已经被注册！"
password_not_match: str = "密码和确认不一致！"
password_format_error: str = "密码长度有误，必须在{min}~{max}个字符长度之间"
sms_code_format_error: str = "验证码格式错误，必须是{min}个字符长度"
sms_interval_time: str = "短信发送过于频繁！"
sms_send_error: str = "短信发送失败！"
sms_code_expired: str = "验证码不存在或已过期！"
sms_code_not_match: str = "验证码错误！"
```

提交版本

```bash
git add .
git commit -m "fix: virify sms code"
git push
```



## 基于Celery实现短信异步发送

Celery：python编写的异步任务框架

消息中间件：消息队列，redis或者RabbitMQ

安装

```bash
pip install celery -i https://pypi.douban.com/simple
```

在项目入口程序`applicaiton.__init__`中，创建celery应用实例对象，并完成配置加载和初始化过程。代码：

```python
# 项目初始化主程序

from pathlib import Path

from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_redis import FlaskRedis
from flask_pymongo import PyMongo
from flask_jsonrpc import JSONRPC
from celery import Celery

from application.utils.config import Config
from application.utils.logger import Log
from application.utils.commands import Command
from application.utils.blueprint import register_blueprint, path, APIView
from application.utils import code, message

"""加载组件[单例模式]"""

# 初始化配置加载类
config: Config = Config()

# SQLAlchemy初始化
db: SQLAlchemy = SQLAlchemy()

# redis初始化
redis_cache: FlaskRedis = FlaskRedis(config_prefix="REDIS")
redis_check: FlaskRedis = FlaskRedis(config_prefix="CHECK")


# mongo初始化
mongo: PyMongo = PyMongo()


# 日志配置类初始化
logger: Log = Log()

# 终端命令管理类实例化
command: Command = Command()


# 实例化JSONRPC
jsonrpc = JSONRPC()

# celery初始化
celery = Celery()

def init_app(config_path: str) -> Flask:
    """用于创建app实例对象并完成初始化过程的工厂函数"""
    # 实例化flask应用对象
    app: Flask = Flask(__name__)
    # 项目跟目录路径
    app.BASE_DIR = Path(__file__).resolve().parent.parent
    # 加载配置
    config.init_app(app, config_path)

    # 加载mysql数据库配置
    db.init_app(app)

    # redis加载配置
    redis_cache.init_app(app)
    redis_check.init_app(app)

    # pymongo加载配置
    mongo.init_app(app)

    # 日志加载配置
    logger.init_app(app)

    # 终端命令管理类加载配置
    command.init_app(app)

    # jsonrpc注册到项目中，必须写在蓝图注册代码的上方
    # 开启rpc接口的web调试界面：/api/browse
    jsonrpc.browse_url = app.config.get("API_BROWSE_URL", "/api/browse")
    jsonrpc.enable_web_browsable_api = app.config.get("DEBUG", False)
    jsonrpc.init_app(app)

    # 注册蓝图
    register_blueprint(app, jsonrpc)

    # 加载celery配置
    celery.main = app.name
    celery.app = app
    # 更新配置
    celery.conf.update(app.config)
    # 自动注册任务
    celery.autodiscover_tasks(app.config.get("INSTALL_BLUEPRINT"))

    # db创建数据表
    with app.app_context():
        db.create_all()

    return app

```

celery配置，application/settings/dev.py，代码：

```python
"""Celery配置"""
# 某些情况下可以防止死锁
CELERY_FORCE_EXECV = True
# 设置并发的worker数量
CELERYD_CONCURRENCY = 20
# 设置失败允许重试
CELERY_ACKS_LATE = True
# 每个worker最多执行500个任务被销毁，可以防止内存泄漏
CELERYD_MAX_TASKS_PER_CHILD = 500
# 单个任务的最大运行时间，超时会被杀死【注意：如果异步任务中有IO操作则建议不要设置这个数字太小，或者建议不要设置了】
CELERYD_TIME_LIMIT = 10 * 60
# 任务发出后，经过一段时间还未收到acknowledge , 就将任务重新交给其他worker执行
CELERY_DISABLE_RATE_LIMITS = True
# celery的任务结果内容格式
CELERY_ACCEPT_CONTENT = ['json', 'pickle']
# celery的任务队列地址
BROKER_URL = "redis://127.0.0.1:6379/15"
# celery的结果队列地址
CELERY_RESULT_BACKEND = "redis://127.0.0.1:6379/14"

# celery的定时任务调度器配置
BEAT_SCHEDULE = {
    # "test": {
    #     "task": "get_sendback",
    #     "schedule": 10,
    # }
}
```

启动文件中引入celery实例对象，`manage.py`，代码：

```python
from application import init_app, Flask, celery

app: Flask = init_app("application.settings.dev")

if __name__ == '__main__':
    app.run()
```

终端提供启动celery和beat的操作命令，command.sh，代码：

```bash
#!/usr/bin/env bash
export FLASK_APP="/home/moluo/Desktop/mofangapi/manage.py"
# 生产模式/运营模式
# export FLASK_ENV=product
# 开发模式
export FLASK_ENV=development

if [ $1 ]; then
  if [ $1 == "run" ]; then
    flask run --host=0.0.0.0 --port=5000

  elif [ $1 == "blue" ]; then
    cd application/apps
    flask $1 --name=$2

  elif [ $1 == "celery" ]; then
    celery -A manage.celery worker -l info

  elif [ $1 == "beat" ]; then
    celery -A manage.celery beat -l info

  else
    flask $1
  fi
fi
```

启动celery命令如下：

```bash
./command.sh celery
```



### 编写发送短信的异步任务

在users蓝图下的tasks.py任务文件中，创建异步任务，users/tasks.py，代码：

```python
from application import celery

@celery.task(name="send_sms")
def send_sms(mobile:str):
    print("发送短信~")
```

终端下重启celery

```bash
celery -A manage.celery worker -l info
```

同时,在任务执行过程中, 基于监听器和任务bind属性对失败任务进行记录和重新尝试执行. `users.tasks`，

```python
pip install orjson  # rust编写的高性能json解析库
```

代码：

```python
import orjson

from typing import Dict, Any
from ronglian_sms_sdk import SmsSDK
from redis.client import Pipeline


from application import celery, redis_check as redis
from celery import Task


class SMSTask(Task):
    def on_success(self, retval, task_id, args, kwargs):
        print( '任务执行成功!')
        return super().on_success(retval, task_id, args, kwargs)

    def on_failure(self, exc, task_id, args, kwargs, einfo):
        print('任务执行失败!%s' % self.request.retries)
        # 重新尝试执行失败任务，时间间隔:3秒，最大尝试次数：5次
        self.retry(exc=exc, countdown=3, max_retries=5)
        return super().on_failure(exc, task_id, args, kwargs, einfo)

    def after_return(self, status, retval, task_id, args, kwargs, einfo):
        print('任务执行的回调操作，不管执行的结果是成功还是失败，都会执行这里')
        return super().after_return(status, retval, task_id, args, kwargs, einfo)

    def on_retry(self, exc, task_id, args, kwargs, einfo):
        print('当任务尝试重新执行时，会执行到这里，但是目前执行有问题')
        return super().on_retry(exc, task_id, args, kwargs, einfo)


@celery.task(name="send_sms", base=SMSTask)
def send_sms(mobile: str, sms_code: str) -> Dict[str, Any]:
    """发送短信"""
    sdk: SmsSDK = SmsSDK(
        celery.app.config.get("SMS_ACCOUNT_ID"),
        celery.app.config.get("SMS_ACCOUNT_TOKEN"),
        celery.app.config.get("SMS_APP_ID")
    )
    try:
        ret: str = sdk.sendMessage(
            celery.app.config.get("SMS_TEMPLATE_ID"),  # 模板ID
            mobile,  # 用户手机号
            (sms_code, celery.app.config.get("SMS_EXPIRE_TIME") // 60)  # 模板变量信息
        )

        result: Dict[str, Any] = orjson.loads(ret)

        if result["statusCode"] == "000000":
            pipe: Pipeline = redis.pipeline()
            pipe.multi()  # 开启事务
            # 保存短信记录到redis中
            pipe.setex("sms_%s" % mobile, celery.app.config.get("SMS_EXPIRE_TIME"), sms_code)
            # 进行冷却倒计时
            pipe.setex("int_%s" % mobile, celery.app.config.get("SMS_INTERVAL_TIME"), "_")
            pipe.execute()  # 提交事务
            return result
        else:
            raise Exception
    except Exception as exc:
        celery.app.logger.error("短信发送失败!\r\n%s" % exc)
        return result



"""另一种监听异步任务的执行结果的监听器写法"""
@celery.task(name="send_sms2",bind=True) # bind=True表示把当前异步任务作为Task类的方法来执行
def send_sms2(self, mobile: str, sms_code: str) -> Dict[str, Any]:
    sdk: SmsSDK = SmsSDK(
        celery.app.config.get("SMS_ACCOUNT_ID"),
        celery.app.config.get("SMS_ACCOUNT_TOKEN"),
        celery.app.config.get("SMS_APP_ID")
    )
    try:
        ret: str = sdk.sendMessage(
            celery.app.config.get("SMS_TEMPLATE_ID"),  # 模板ID
            mobile,  # 用户手机号
            (sms_code, celery.app.config.get("SMS_EXPIRE_TIME") // 60)  # 模板变量信息
        )

        result: Dict[str, Any] = orjson.loads(ret)

        if result["statusCode"] == "000000":
            pipe: Pipeline = redis.pipeline()
            pipe.multi()  # 开启事务
            # 保存短信记录到redis中
            pipe.setex("sms_%s" % mobile, celery.app.config.get("SMS_EXPIRE_TIME"), sms_code)
            # 进行冷却倒计时
            pipe.setex("int_%s" % mobile, celery.app.config.get("SMS_INTERVAL_TIME"), "_")
            pipe.execute()  # 提交事务

            return result
        else:
            celery.app.logger.error("异步短信发送失败!\r\n%s" % ret)
            raise Exception
    except Exception as exc:
        # 发生异常，每隔3秒尝试重新执行，一共5次
        self.retry(exc=exc, countdown=3, max_retries=5)
```

进入flask提供的终端交互环境，测试上面编写的异步任务是否有问题。注意：要重启celery

```bash
./command.sh celery

# 新建一个终端测试celery异步任务
./command.sh shell

from application.apps.users.tasks import send_sms
# 发送异步任务，让celery尽快异步执行
ret = send_sms.delay("13928835901", "1236")

# 30秒后异步执行任务
ret = send_sms.apply_async(kwargs={'mobile':'13928835901', 'sms_code': '1236'}, countdown=30)
ret = send_sms.apply_async(args=('13928835901', '1236'), countdown=30)

ret.id     # 获取异步任务ID
ret.status # 获取异步任务的当前执行装填 SUCCESS表示执行成功 FAIL表示执行失败 PENDING表示等待
ret.get()  # 以同步阻塞的方式获取任务结果，慎用！！！
```

经过上面的测试用，异步任务的执行没有问题，所以我们需要在项目中调用异步任务发送短信，`application.apps.users.api`，代码：

```python
import random

from typing import Dict, Union, Any

from application import message, code, redis_check as redis
from .serializers import MobileSchema, ValidationError, UserSchema
from .models import User
from .tasks import send_sms


# 中间代码省略

def sms(mobile: str) -> Dict[str, Any]:
    """
    发送短信验证码
    :param mobile: 手机号
    :return:
    """
    # 验证手机
    ret: Dict[str, Any] = check_mobile(mobile=mobile)
    if ret["errno"] != 0:
        return ret

    # 短信发送冷却时间
    ret: int = redis.ttl("int_%s" % mobile)
    if ret > 0:
        return {
            "errno": code.CODE_INTERVAL_TIME,
            "errmsg": message.sms_interval_time,
            "data": {
                "time": ret,
            }
        }

    # 生成验证码
    sms_code: str = "%04d" % random.randint(0, 9999)
    # 异步发送短信
    send_sms.delay(mobile=mobile, sms_code=sms_code)
    return {"errno": code.CODE_OK, "errmsg": message.ok}

```

提交版本

```bash
git add .
git commit -m "api: async send sms by celery"
git push
```



# 用户登录

## 服务端实现jwt登陆认证

当前我们开发的项目属于前后端分离，而目前最适合我们使用的认证方式就是jwt认证，也有些公司采用 Oauth2.0认证。

在flask中，我们可以通过`flask_jwt_extended`模块来快速实现jwt用户登录认证。当然，也可以采用原生提供的pyjwt模块。

```
注意：
1.  flask_jwt_extended 的作者开发当前模块主要适用于flask的普通视图认证的。其认证方式主要通过装饰器来完成。
	而我们当前所有服务端接口都改造成了jsonrpc规范接口，所以我们在使用过程中，需要对部分源代码进行调整才能正常使用。

2.  事实上，在我们当前使用的`flask_jsonrpc`也提供了基于用户名username和密码password进行的用户登陆认证功能，
	但是这个功能是依靠用户账户`username`和密码`password`来实现。如果我们基于当前这种方式，也可以实现jwt登陆认证，
	只是相对于上面的`flask_jwt_extended`模块而言，要补充的源代码会更多，所以在此，我们放弃这块功能的使用。
```



#### 模块安装

```bash
pip install flask-jwt-extended
# 添加了jwt认证以后，会出现跨域问题，解决下跨域问题
# pip install flask-cors
```

官网文档：https://flask-jwt-extended.readthedocs.io/en/latest/

配置说明：https://flask-jwt-extended.readthedocs.io/en/latest/options/

#### 快速使用

在魔方APP项目中对模块进行初始化，`application/__init__.py`，代码：

```python
# 项目初始化主程序

from pathlib import Path

from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_redis import FlaskRedis
from flask_pymongo import PyMongo
from flask_jsonrpc import JSONRPC
from celery import Celery
from flask_jwt_extended import JWTManager

from application.utils.config import Config
from application.utils.logger import Log
from application.utils.commands import Command
from application.utils.blueprint import register_blueprint, path, APIView
from application.utils import code, message

"""加载组件[单例模式]"""

# 初始化配置加载类
config: Config = Config()

# SQLAlchemy初始化
db: SQLAlchemy = SQLAlchemy()

# redis初始化
redis_cache: FlaskRedis = FlaskRedis(config_prefix="REDIS")
redis_check: FlaskRedis = FlaskRedis(config_prefix="CHECK")


# mongo初始化
mongo: PyMongo = PyMongo()


# 日志配置类初始化
logger: Log = Log()

# 终端命令管理类实例化
command: Command = Command()


# 实例化JSONRPC
jsonrpc = JSONRPC()

# celery初始化
celery = Celery()


# jwt认证模块实例化
jwt = JWTManager()


def init_app(config_path: str) -> Flask:
    """用于创建app实例对象并完成初始化过程的工厂函数"""
    # 实例化flask应用对象
    app: Flask = Flask(__name__)
    # 项目跟目录路径
    app.BASE_DIR = Path(__file__).resolve().parent.parent
    # 加载配置
    config.init_app(app, config_path)

    # 加载mysql数据库配置
    db.init_app(app)

    # redis加载配置
    redis_cache.init_app(app)
    redis_check.init_app(app)

    # pymongo加载配置
    mongo.init_app(app)

    # 日志加载配置
    logger.init_app(app)

    # 终端命令管理类加载配置
    command.init_app(app)

    # jsonrpc注册到项目中，必须写在蓝图注册代码的上方
    # 开启rpc接口的web调试界面：/api/browse
    jsonrpc.browse_url = app.config.get("API_BROWSE_URL", "/api/browse")
    jsonrpc.enable_web_browsable_api = app.config.get("DEBUG", False)
    jsonrpc.init_app(app)

    # jwt初始化，必须写在蓝图注册代码的上方
    jwt.init_app(app)

    # 注册蓝图
    register_blueprint(app, jsonrpc)

    # 加载celery配置
    celery.main = app.name
    celery.app = app
    # 更新配置
    celery.conf.update(app.config)
    # 自动注册任务
    celery.autodiscover_tasks(app.config.get("INSTALL_BLUEPRINT"))

    # db创建数据表
    with app.app_context():
        db.create_all()

    return app

```

配置文件，`application.settings.dev`，代码：

```python
# jwt 相关配置
# 加密算法,默认: HS256
JWT_ALGORITHM = "HS256"
# 秘钥，默认是flask配置中的SECRET_KEY
JWT_SECRET_KEY = "y58Rsqzmts6VCBRHes1Sf2DHdGJaGqPMi6GYpBS4CKyCdi42KLSs9TQVTauZMLMw"
# token令牌有效期，单位: 秒/s，默认:　datetime.timedelta(minutes=15) 或者 15 * 60
JWT_ACCESS_TOKEN_EXPIRES = 60
# refresh刷新令牌有效期，单位: 秒/s，默认：datetime.timedelta(days=30) 或者 30*24*60*60
JWT_REFRESH_TOKEN_EXPIRES = 30 * 24 * 60 * 60
# 设置通过哪种方式传递jwt，默认是http请求头，也可以是query_string，json，cookies
JWT_TOKEN_LOCATION = ["headers", "json", "query_string"]
# 当通过http请求头传递jwt时，请求头参数名称设置，默认值： Authorization
JWT_HEADER_NAME = "Authorization"
# 当通过http请求头传递jwt时，令牌的前缀。
# 默认值为 "Bearer"，例如：Authorization: Bearer <JWT>
JWT_HEADER_TYPE = "jwt"
# 当通过json请求体传递jwt时，access_token令牌参数名称
JWT_JSON_KEY = "access_token"
# 当通过json请求体传递jwt时，refresh_token令牌参数名称
JWT_REFRESH_JSON_KEY = "refresh_token"
# 当通过查询字符串query_string传递jwt时，地址栏的参数名称设置，默认值： Authorization
JWT_QUERY_STRING_NAME = "token"
# 当通过查询字符串query_string传递jwt时，令牌的前缀。
# 默认值为 "Bearer"，例如：Authorization: Bearer <JWT>
JWT_QUERY_STRING_VALUE_PREFIX = "jwt "
```

视图提供基本操作jwt的rpc接口

refresh token只能用于给客户端换取新的access_token，有效期都会比access_token长

access_token只能用于服务端提供的其他api接口数据，但是有效期会很短，当access_token过期，则允许客户端凭借refresh_token来换取新的access_token。

application/apps/users/api.py，代码：

```python
import random

from typing import Dict, Union, Any


from flask_jwt_extended import get_jwt_identity, jwt_required

from application import message, code, redis_check as redis
from .serializers import MobileSchema, ValidationError, UserSchema, UserLoginSchema
from .models import User
from .tasks import send_sms
from .services import gen_token, get_user_by_id

# ... 中间代码省略

def login(account: str, password: str) -> Dict[str, Any]:
    """
    用户jwt登录
    :param account: 账户名[可以是手机号、邮箱、用户名]
    :param password: 登录密码
    :return
    """
    # 1. 验证数据
    try:
        us: UserLoginSchema = UserLoginSchema()
        # 反序列化
        user: User = us.load({
            "account": account,
            "password": password
        })

        # 序列化
        payload: Dict[str, Any] = us.dump(user)

        # 2. 生成jwt assess token 和 refresh token
        access_token, refresh_token = gen_token(payload=payload)

        # 3. 返回2个token给客户端
        result: Dict[str, Any] = {
            "errno": code.CODE_OK,
            "errmsg": message.ok,
            "access_token": access_token,
            "refresh_token": refresh_token
        }

    except ValidationError as e:
        result: Dict[str, Any] = {"errno": code.CODE_VALIDATE_ERROR, "errmsg": e.messages}

    return result


@jwt_required()   # 验证 jwt的 assess token
def info() -> Any:
    """获取用户身份信息"""
    user_info: Dict[str, Any] = get_jwt_identity()  # 获取refresh token中的载荷
    return {
        "errno": code.CODE_OK,
        "errmsg": message.ok,
        "data": user_info
    }


@jwt_required(refresh=True)  # 验证 jwt的 refresh token
def refresh() -> Dict[str, Any]:
    """依靠refresh token 换取 assess token"""
    user_info: Dict[str, Any] = get_jwt_identity() # 获取refresh token中的载荷
    user: User = get_user_by_id(user_info["id"])
    if user is None:
        return {
            "errno": code.CODE_USER_NOT_EXISTS,
            "errmsg": message.user_not_exists
        }

    access_token,  _ = gen_token(payload=user_info)

    return {
        "errno": code.CODE_OK,
        "errmsg": message.ok,
        "access_token": access_token
    }
```

users/services.py，代码：

```python
from typing import Dict, List, Any, Tuple

from flask import current_app
from flask_jwt_extended import create_access_token, create_refresh_token

from application import redis_cache as cache
from .models import User


def gen_token(payload: Dict[str, Any]) -> Tuple:
    """生成access_token和refresh_token"""
    access_token: str = create_access_token(identity=payload)  # identity 就是载荷
    refresh_token: str = create_refresh_token(identity=payload)
    # 缓存一个token到redis中，表示当前用户在服务端的登录状态，将来如果token或者删除数据库中用户信息时，会删除调用当前redis中保存的token
    cache.setex(f"access_token_{payload['id']}", current_app.config["JWT_ACCESS_TOKEN_EXPIRES"], access_token)

    return access_token, refresh_token

def get_user_by_id(id: int):
    """根据用户ID来获取用户模型对象"""
    return User.query.get(id)

```

users/serialziers.py，代码：

```python
from typing import List, Dict, Optional
from flask_marshmallow.sqla import SQLAlchemyAutoSchema, auto_field
from marshmallow import Schema, fields, validate, validates, ValidationError, decorators
from sqlalchemy.orm import scoped_session
from sqlalchemy import or_

from application import message, db, redis_check as redis
from .models import User


# ....中间代码省略

class UserLoginSchema(SQLAlchemyAutoSchema):
    """用户登录的构造器"""
    account = fields.String(required=True, load_only=True)
    password = fields.String(required=True, load_only=True)
    money = fields.Float(dump_only=True)
    credit = fields.Float(dump_only=True)

    class Meta:
        model = User
        # 如果要转换模型的全部字段，就不要声明fields或exclude字段即可
        fields = ["id", "nickname", "account", "password", "money","credit", "avatar","province","city","area"]
        sqla_session = db.session

    # 钩子，验证成功以后，自动调用
    @decorators.post_load
    def save_object(self, data, **kwargs):
        account = data.get("account")
        password = data.get("password")
        user = User.query.filter(
            or_(
                User.mobile == account,
                User.name == account,
                User.email == account
            )
        ).first()  # 实例化模型

        if not user:
            raise ValidationError(message=message.user_not_exists, field_name="username")

        if not user.check_password(password):
            raise ValidationError(message=message.password_not_match, field_name="password")

        return user


```

users/urls.py，代码：

```python
from typing import List
from application import path
from . import api

apipatterns: List = [
    path("mobile", api.check_mobile),
    path("register", api.register),
    path("sms", api.sms),
    path("login", api.login),
    path("info", api.info),
    path("refresh", api.refresh),
]
```

message，代码：

```python
user_not_exists: str = "当前用户不存在！"
```

code，代码：

```python
CODE_USER_NOT_EXISTS: int = 1101 # 当前用户不存在！
```



提交代码版本

```bash
git add .
git commit -m "api: jwt auth"
git push
```



#### 针对token验证失败、过期、无效的错误提示，调整返回的数据格式和状态码

装饰器`jwt_required`就是用于判断客户端提交的数据中的jwt token是否有效，这里我们还需要进行2处的源码调整。以方便它更好的展示错误信息。

注意： 修改源码之前，要把flask_jwt_extended目录从site_packages中复制出来到项目根目录下。

`flask_jwt_extended/view_decorators.py`，代码：

```python
from jwt.exceptions import DecodeError, PyJWTError
from flask_jwt_extended.exceptions import JWTExtendedException
from application.utils import message, code


def jwt_required(optional=False, fresh=False, refresh=False, locations=None):
    """
    ....
    """

    def wrapper(fn):
        @wraps(fn)
        def decorator(*args, **kwargs):
            # verify_jwt_in_request(optional, fresh, refresh, locations)
            try:
                verify_jwt_in_request(optional, fresh, refresh, locations)
            except DecodeError:
                return {"errno": code.CODE_JWT_INVALID, "errmsg": message.authorization_is_invalid}
            except JWTExtendedException:
                return {"errno": code.CODE_JWT_NOT_TOKEN, "errmsg": message.no_authorization}
            except PyJWTError:
                return {"errno": code.CODE_JWT_EXPIRED, "errmsg": message.authorization_has_expired}

            # Compatibility with flask < 2.0
            if hasattr(current_app, "ensure_sync") and callable(
                getattr(current_app, "ensure_sync", None)
            ):
                return current_app.ensure_sync(fn)(*args, **kwargs)

            return fn(*args, **kwargs)  # pragma: no cover

        return decorator

    return wrapper

```

`application.utils.code`,代码:

```python
CODE_JWT_INVALID: int = 1010    # 无效的jwt token
CODE_JWT_NOT_TOKEN: int = 1011  # 没有找到jwt token
CODE_JWT_EXPIRED: int = 1012    # jwt登录已超时
```

`application.utils.message`,代码:

```python
no_authorization: str = "没有认证令牌"
authorization_has_expired: str = "过期的认证令牌"
authorization_is_invalid: str = "无效的认证令牌"
```



## 客户端提交登录信息

`html/login.html`，代码：

```html
<!DOCTYPE html>
<html>
<head>
	<title>登录</title>
	<meta name="viewport" content="width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
	<meta charset="utf-8">
	<link rel="stylesheet" href="../css/main.css">
	<script src="../script/vue.js"></script>
	<script src="../script/axios.js"></script>
	<script src="../script/main.js"></script>
</head>
<body>
	<div class="app" id="app">
        <img class="music" :class="music_play?'music2':''" @click="music_play=!music_play" src="../image/player.png">
        <div class="bg">
            <img src="../image/bg0.jpg">
        </div>
        <div class="form">
            <div class="form-title">
                <img src="../image/login.png">
                <img class="back" @click="open_index" src="../image/back.png">
            </div>
            <div class="form-data">
                <div class="form-data-bg">
                    <img src="../image/bg1.png">
                </div>
                <div class="form-item">
                    <label class="text">账户</label>
                    <input type="text" v-model="account" placeholder="请输入手机号、用户名或邮箱">
                </div>
                <div class="form-item">
                    <label class="text">密码</label>
                    <input type="password" v-model="password" placeholder="请输入密码">
                </div>
                <div class="form-item">
                    <input type="checkbox" class="agree remember" v-model="remember">
                    <label><span class="agree_text ">记住密码，下次免登录</span></label>
                </div>
                <div class="form-item">
                    <img class="commit" @click="loginhandle" src="../image/commit.png">
                </div>
                <div class="form-item">
                    <p class="toreg" @click="open_register">立即注册</p>
                    <p class="tofind">忘记密码</p>
                </div>
            </div>
        </div>
	</div>
	<script>
	apiready = function(){
		Vue.prototype.game = new Game("../mp3/bg1.mp3");
		new Vue({
			el:"#app",
			data(){
				return {
                    account: "13928835905",
                    password: "123456",
                    remember: true,              // 是否保存登陆状态，下次免登陆
                    music_play:true,
				}
			},
			watch:{
                music_play(){
                    if(this.music_play){
                        this.game.play_music("../mp3/bg1.mp3");
                    }else{
                        this.game.stop_music();
                    }
                }
            },
            methods:{
                open_register(){
                    this.game.goFrame("register","./register.html");
                },
                open_index(){
                    this.game.outWin();
                },
                loginhandle(){
                    // 登陆处理
                    this.game.play_music('../mp3/btn1.mp3');
                    // 验证数据
					if(this.account.length<1 || this.password.length<1){
						this.game.tips("账号或者密码不能为空！");
						return false;
					}
                    // 提交获取token
					this.axios.post("",{
						"jsonrpc": "2.0",
						"id": this.game.uuid(),
						"method": "Users.login",
						"params": {
							"account": this.account,
							"password": this.password,
						}
					}).then(response=>{
						if(response.data.result.errno === 0){
							// 删除上次登录遗留的token数据

							// 保存认证令牌
							if(this.remember){
								// 记住登陆状态

							}else{
								// 不记住登陆状态

							}

							// 注册成功!
							api.confirm({
							    title: '系统提示',
							    msg: '登陆成功',
							    buttons: ['返回首页', '个人中心']
							}, (ret, err)=>{
							    if(ret.buttonIndex == 1){
									// 跳转到首页
									this.game.goWin("root", "./index.html");
								}else{
									// 跳转到个人中心
									this.game.goWin("user","./user.html");
								}
								// 2秒后关闭当前窗口
								setTimeout(() => {
									this.game.outWin();
								}, 2000);
							});

						}else{
                            this.game.tips(response.data.result.errmsg);
                        }

					}).catch(error=>{
						this.game.print(error);
					});
                }
            }
		})
	}
	</script>
</body>
</html>
```



## 保存用户登录状态

基于APICloud提供的本地存储可以有效保存数据

```javascript
// 保存数据到内存中
api.setGlobalData({
    key: 'userName',
    value: 'api'
});

var userName = api.getGlobalData({
    key: 'userName'
});

// 保存数据到文件中
api.setPrefs({ // 储存
    key: 'userName',
    value: 'api'
});

api.getPrefs({ // 获取
    key: 'userName'
}, function(ret, err) {
    ...
});
// 注意：基于api.getPrefs获取数组时，会出现转义格式的字符

api.removePrefs({//删除
    key: 'userName'
});
```

main.js封装对于api对象提供的存储数据方法，main.js，代码：

```typescript
class Game{
	// 主程序
	constructor(bg_music){
		// 构造函数，类似于python的 __init__()
		this.init();
    	this.play_music(bg_music);
	}
	init(){
		// 初始化
		console.log("系统初始化");
    	this.rem();
		this.init_config();
		this.init_axios();
	}
	init_config(){
		// 初始化配置
		this.config = {
			"server_api": "http://192.168.21.253:5000/api", // api服务端的网关地址
		}
	}
	init_axios(){
		// 初始化axios http请求工具包
        if(window.axios && window.Vue){
			console.log("初始化axios");
			axios.defaults.baseURL = this.config.server_api    // 服务端api接口网关地址
			axios.defaults.withCredentials = false; // 跨域请求资源的情况下,忽略cookie的发送
			Vue.prototype.axios = axios;            // 给vue对象增加一个全局的属性，this.axios
		}
	}
	print(data,show=false){
		// 打印数据
		if(show){
			api.alert({"msg": JSON.stringify(data)});
		}else{
			console.log(JSON.stringify(data));
		}
	}
	rem(){
		// 页面自适配
		if(window.innerWidth<1200){
			this.UIWidth = document.documentElement.clientWidth;
			this.UIHeight = document.documentElement.clientHeight;
			document.documentElement.style.fontSize = (0.01*this.UIWidth*3)+"px";
			document.querySelector("#app").style.height=this.UIHeight+"px"
		}
		window.onresize = ()=>{
			if(window.innerWidth<1200){
				this.UIWidth = document.documentElement.clientWidth;
				this.UIHeight = document.documentElement.clientHeight;
				document.documentElement.style.fontSize = (0.01*this.UIWidth*3)+"px";
			}
		}
	}
	stop_music(){
		this.print("停止播放音乐")
		document.body.removeChild(this.audio);
	}
	play_music(src){
		this.audio = document.createElement("audio");
		this.source = document.createElement("source");
		this.source.type = "audio/mp3";
		this.audio.autoplay = "autoplay";
		this.source.src=src;
		this.audio.appendChild(this.source);
		document.body.appendChild(this.audio);
		var t = setInterval(()=>{
			if(this.audio.readyState > 0){
				if(this.audio.ended){
					clearInterval(t);
					document.body.removeChild(this.audio);
				}
			}
		},100);
	}
	goWin(name, url, pageParam=null, subType=null){
		if(pageParam === null){
			pageParam = {}
		}
		if(subType === null){
			subType = "from_right"
		}
		// 打开窗口
		api.openWin({
		    name: name,            // 自定义窗口名称
		    bounces: false,        // 窗口是否上下拉动
		    reload: false,         // 如果页面已经在之前被打开了,是否要重新加载当前窗口中的页面
		    url: url,              // 窗口创建时展示的html页面的本地路径[相对于当前代码所在文件的路径]
		    animation:{            // 打开新建窗口时的过渡动画效果
		    	type: "push",      // 动画类型（详见动画类型常量）
		    	subType: subType,  // 动画子类型（详见动画子类型常量）
		    	duration:300        // 动画过渡时间，默认300毫秒
		    },
		    pageParam: pageParam   // 传递给下一个窗口使用的参数.将来可以在新窗口中通过 api.pageParam.name 获取
		});
	}

	outWin(name){
		// 关闭窗口
		api.closeWin({
			name,
		});
	}

	goFrame(name,url,pageParam){
		// 打开帧页面
		api.openFrame({
			name: name,
			url: url,
			rect: {
				x: 0,
				y: 0,
				w: 'auto',
				h: 'auto'
			},
			useWKWebView:true,
			historyGestureEnabled:true,
			bounces:false,
			animation:{
				type:"push",
				subType:"from_right",
				duration:300
			},
			pageParam: pageParam
		});
	}

	outFrame(name){
		// 关闭帧页面
		api.closeFrame({
		    name: name,
		});
	}

	uuid(){
		// UUID
		return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
			var r = Math.random()*16|0,v=c=='x'?r:r&0x3|0x8;
			return v.toString(16);
		})
	}

	tips(msg, location='middle'){
		// 消息提示
		api.toast({
			msg: msg,
			duration: 3000,
			location: location
		});
	}

	setfs(data){
		// 保存数据到本地文件系统中
		for(let key in data){
			api.setPrefs({ // 储存
				 key: key,
				 value: data[key]
			});
		}
	}
	getfs(key){ // keys="access_token"    keys = ["access_token","refresh_token"]
		// 根据key值来获取本地文件系统中存储的数据
		let keys = key;
		if(!(key instanceof Array)){ // 如果不是数组，改造成数组，统一操作
			keys = [key];
		}

		let data = {}
		for(let item of keys){
			data[item] = api.getPrefs({
				key: item,
				sync: true,
			});
		}

		if(key instanceof Array){
			return data;
		}

		return data[key];
	}
	delfs(key){
		// 根据key值来删除本地文本系统中存储的数据
		let keys = key;
		if(!(key instanceof Array)){ // 如果不是数组，改造成数组，统一操作
			keys = [key];
		}

		for(let item of keys){
			api.removePrefs({
				key: item,
			});
		}

	}
	setdata(data){
		// 保存数据到内存中
		for(let key in data){
			api.setGlobalData({ // 储存
				key: key,
				value: data[key]
			});
		}
	}
	getdata(key){
		// 根据key值来获取内存中存储的数据
		let keys = key;
		if(!(key instanceof Array)){ // 如果不是数组，改造成数组，统一操作
			keys = [key];
		}

		let data = {}
		for(let item of keys){
			data[item] = api.getGlobalData({
				key: item
			});
		}

		if(key instanceof Array){
			return data;
		}

		return data[key];
	}

	deldata(key){
		// 根据key值来删除内存中存储的数据
		let keys = key;
		if(!(key instanceof Array)){ // 如果不是数组，改造成数组，统一操作
			keys = [key];
		}

		for(let item of keys){
			api.setGlobalData({
				key: item,
				value: "",
			});
		}

	}

}

```

最后，把登陆状态根据用户选择是否记住密码来采用不同的存储方式保存信息，login.html，代码：

```javascript
loginhandle(){
					// 登陆处理
					this.game.play_music('../mp3/btn1.mp3');
					// 验证数据
					if(this.account.length<1 || this.password.length<1){
						this.game.tips("账号或者密码不能为空！");
						return false;
					}

					// 提交获取token
					this.axios.post("",{
						"jsonrpc": "2.0",
						"id": this.game.uuid(),
						"method": "Users.login",
						"params": {
							"account": this.account,
							"password": this.password,
						}
					}).then(response=>{
						if(response.data.result.errno !== 1000){
							this.game.tips(response.data.result.errmsg);
						}else{
							// 删除上次登录遗留的token数据
							this.game.delfs(["access_token","refresh_token"]);
							this.game.deldata(["access_token","refresh_token"]);
							// 保存认证令牌
							if(this.remember){
								// 记住登陆状态
								this.game.setfs({
									'access_token': response.data.result.access_token,
									'refresh_token': response.data.result.refresh_token
								});
							}else{
								// 不记住登陆状态
								this.game.setdata({
									'access_token': response.data.result.access_token,
									'refresh_token': response.data.result.refresh_token
								});
							}

							// 注册成功!
							api.confirm({
							    title: '提示',
							    msg: '登陆成功',
							    buttons: ['返回首页', '个人中心']
							}, (ret, err)=>{
							    if(ret.buttonIndex == 1){
									// 跳转到首页
									this.game.outWin();
								}else{
									// 跳转到个人中心
									this.game.goWin("user","./user.html");
									// 2秒后关闭当前窗口
									setTimeout(() => {
										this.game.outWin();
									}, 500);
								}
							});

						}

					}).catch(error=>{
						this.game.print(error);
					});

				}
```

### Base64编码方法

有了本地保存token以后，将来我们可以通过window提供的base64算法方法来提取token内嵌的载荷数据。对于这块，我们也可以在main.js中针对base64编码的相关操作，可以封装成方法。

```typescript
class Game{
	// 主程序
	constructor(bg_music){
		// 构造函数，类似于python的 __init__()
		this.init();
    	this.play_music(bg_music);
		this.quit();
	}
	init(){
		// 初始化
		this.print("系统初始化");
    	this.rem();
		this.init_config();
		this.init_axios();
	}
	init_config(){
		// 初始化配置
		this.config = {
			"server_api": "http://192.168.19.251:5000/api", // api服务端的网关地址
		}
	}
	init_axios(){
		// 初始化axios http请求工具包
        if(window.axios && window.Vue){
			this.print("初始化axios");
			axios.defaults.baseURL = this.config.server_api    // 服务端api接口网关地址
			axios.defaults.withCredentials = false; // 跨域请求资源的情况下,忽略cookie的发送
			Vue.prototype.axios = axios;            // 给vue对象增加一个全局的属性，this.axios
		}
	}
	quit(){
		// 监听设备中的keyback按钮是否被按了
		api.addEventListener({
			name: 'keyback'
		}, (ret, err) => {
			// 弹出一个确认框
			var windows = api.windows()
			if(windows.length>1){
				// 如果当前APP打开了多个窗口，则直接关闭窗口
				this.outWin();
			}else{
				// 如果当前APP只打开了一个窗口，则弹窗确认用户是否退出当前APP
				api.confirm({
					title: '系统提示',
					msg: '您确认退出魔方APP吗？',
					buttons: ['退出', '取消']
				}, (ret, err) => {
					var index = ret.buttonIndex;
					if(index === 1) {
						this.outWin();
					}
				});
			}
		});
	}
	print(data,show=false){
		// 打印数据
		if(show){
			// 以弹窗的方式打印数据
			api.alert({"msg": JSON.stringify(data)});
		}else{
			// 以终端的方式打印数据
			console.log(JSON.stringify(data));
		}
	}
	rem(){
		// 页面自适配方法
		if(window.innerWidth<1200){
			this.UIWidth = document.documentElement.clientWidth;
			this.UIHeight = document.documentElement.clientHeight;
			document.documentElement.style.fontSize = (0.01*this.UIWidth*3)+"px";
			document.querySelector("#app").style.height=this.UIHeight+"px"
		}
		window.onresize = ()=>{
			if(window.innerWidth<1200){
				this.UIWidth = document.documentElement.clientWidth;
				this.UIHeight = document.documentElement.clientHeight;
				document.documentElement.style.fontSize = (0.01*this.UIWidth*3)+"px";
			}
		}
	}
	stop_music(){
		this.print("停止音乐")
		try {
			document.body.removeChild(this.audio);
		} catch (error) {
			this.print(error)
		}
	}
	play_music(src){
		this.print("播放音乐")
		try {
			this.audio = document.createElement("audio");
			this.source = document.createElement("source");
			this.source.type = "audio/mp3";
			this.audio.autoplay = "autoplay";
			this.source.src=src;
			this.audio.appendChild(this.source);
			document.body.appendChild(this.audio);
			var t = setInterval(()=>{
				if(this.audio.readyState > 0){
					if(this.audio.ended){
						clearInterval(t);
						document.body.removeChild(this.audio);
					}
				}
			},100);
		} catch (error) {
			this.print(error);
		}
	}

	goWin(name, url, pageParam){
		// 打开窗口
		api.openWin({
		    name: name,            // 自定义窗口名称
		    bounces: false,        // 窗口是否上下拉动
		    reload: true,          // 如果页面已经在之前被打开了,是否要重新加载当前窗口中的页面
		    url: url,              // 窗口创建时展示的html页面的本地路径[相对于当前代码所在文件的路径]
		    animation:{            // 打开新建窗口时的过渡动画效果
		    	type: "push",                //动画类型（详见动画类型常量）
		    	subType: "from_right",       //动画子类型（详见动画子类型常量）
		    	duration:300                 //动画过渡时间，默认300毫秒
		    },
		    pageParam: pageParam   // 传递给下一个窗口使用的参数.将来可以在新窗口中通过 api.pageParam.name 获取
		});
	}
	outWin(name){
		// 关闭窗口
		api.closeWin({
			name: name
		});
	}

	goFrame(name, url, pageParam){
		// 打开帧页面
		api.openFrame({
				name: name,
				url: url,
				rect: {
						x: 0,
						y: 0,
						w: 'auto',
						h: 'auto'
				},
				useWKWebView: true,
				historyGestureEnabled: true,
				bounces: false,
				animation:{
							type:"push",
							subType: "from_right",
							duration:300
				},
				pageParam: pageParam
		});
	}

	outFrame(name){
		// 关闭帧页面
		api.closeFrame({
		    name: name,
		});
	}

	uuid(){
		// UUID
		return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c)=>{
			var r = Math.random()*16|0,v=c=='x'?r:r&0x3|0x8;
			return v.toString(16);
		})
	}

	tips(msg, location='middle'){
		// 消息提示
		api.toast({
			msg: msg,
			duration: 3000,
			location: location
		});
	}

	setfs(data){
		// 保存一个或多个键值对数据到本地文件系统中
		for(let key in data){
			api.setPrefs({ // 储存
				 key: key,
				 value: data[key]
			});
		}
	}

	getfs(key){ // keys="access_token"    keys = ["access_token","refresh_token"]
		// 根据key值来获取本地文件系统中存储的数据
		let keys = key;
		if(!(key instanceof Array)){ // 如果不是数组，改造成数组，统一操作
			keys = [key];
		}

		let data = {}
		for(let item of keys){
			data[item] = api.getPrefs({
				key: item,
				sync: true,
			});
		}

		if(key instanceof Array){
			return data;
		}

		return data[key];
	}

	delfs(key){
		// 根据key值来删除本地文本系统中存储的数据
		let keys = key;
		if(!(key instanceof Array)){ // 如果不是数组，改造成数组，统一操作
			keys = [key];
		}

		for(let item of keys){
			api.removePrefs({
				key: item,
			});
		}

	}

	setdata(data){
		// 保存数据到内存中
		for(let key in data){
			api.setGlobalData({ // 储存
				key: key,
				value: data[key]
			});
		}
	}

	getdata(key){
		// 根据key值来获取内存中存储的数据
		let keys = key;
		if(!(key instanceof Array)){ // 如果不是数组，改造成数组，统一操作
			keys = [key];
		}

		let data = {}
		for(let item of keys){
			data[item] = api.getGlobalData({
				key: item
			});
		}

		if(key instanceof Array){
			return data;
		}

		return data[key];
	}

	deldata(key){
		// 根据key值来删除内存中存储的数据
		let keys = key;
		if(!(key instanceof Array)){ // 如果不是数组，改造成数组，统一操作
			keys = [key];
		}

		for(let item of keys){
			api.setGlobalData({
				key: item,
				value: "",
			});
		}
	}

	token(){
		// 获取token
		let token = {}
		let data = this.getdata("access_token");
		let fs   = this.getfs("access_token");
		if(data){
			token["access_token"] = data
			token["remember"] = false
		}else if (fs){
			token["access_token"] = fs
			token["remember"] = true
		}else{
			token["access_token"] = ""
			token["remember"] = false
		}
		return token;
	}

	payload(){
		let token = this.token().access_token
		// 获取载荷数据
		let arr = token.split(".")
		if(!arr[0]){
			return {}
		}
		let payload = JSON.parse( window.atob(arr[1]) )
		// 判断token是否已经过期了
		let current_time = parseInt((new Date()-0)) / 1000;
		if( current_time > payload.exp){
			this.delfs("access_token");
			this.deldata("access_token");
			return {}
		}
		return payload
	}
	user_info(){
		// 获取载荷中的用户信息
		return this.payload().sub
	}
}
```

基于上面封装的方法，我们可以在user.html暂时使用测试代码进行测试，代码：

```vue
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>用户中心</title>
	<link rel="stylesheet" href="../css/main.css">
	<script src="../script/vue.js"></script>
	<script src="../script/axios.js"></script>
	<script src="../script/main.js"></script>
</head>
<body>
    <div class="app" id="app">
        <h1>用户中心</h1>
    </div>
    <script>
        apiready = function(){
            Vue.prototype.game = new Game("../mp3/bg1.mp3");
            new Vue({
                el:"#app",
                data(){
                    return {
                        music_play:true,
                    }
                },
                watch:{
                    music_play(){
                        if(this.music_play){
                            this.game.play_music("../mp3/bg1.mp3");
                        }else{
                            this.game.stop_music();
                        }
                    }
                },
                created(){
                    this.game.print(this.game.token());
                    this.game.print(this.game.payload());
                    this.game.print(this.game.user_info());
                },
                methods:{
                    open_index(){
                        this.game.outWin();
                    },
                }
            })
        }
        </script>
</body>
</html>
```



## 在APPCloud中集成防水墙验证码

官网： [https://007.qq.com](https://007.qq.com/)

验证码控制台登陆地址: https://console.cloud.tencent.com/captcha

快速接入：<https://007.qq.com/python-access.html?ADTAG=acces.start>

使用微信扫码登录腾讯云控制台，然后根据官方文档，把验证码集成到项目中


把验证码应用的ID和秘钥保存到settings/dev.py配置文件中.

```python
"""防水墙验证码"""
CAPTCHA_GATEWAY="https://ssl.captcha.qq.com/ticket/verify"
CAPTCHA_APP_ID="2071340228"
CAPTCHA_APP_SECRET_KEY="0v714N6pMtV587ymedaJM2w**"
```



### 前端获取显示并校验验证码

把防水墙的前端核心js文件(TCaptcha.js)下载并保存在script目录下，并在当前需要验证码的页面中使用script引入。

下载地址：https://ssl.captcha.qq.com/TCaptcha.js

在客户端项目的main.js中init_config方法中添加配置项app_id。

```javascript
	init_config(){
		// 初始化配置
		this.config = {
			"server_api": "http://192.168.19.251:5000/api", // api服务端的网关地址
			"app_id": "2071340228",  // 防水墙验证码的应用ID
		}
	}
```



### 客户端展示验证码

`html/login.html`，代码：

```html
<!DOCTYPE html>
<html>
<head>
	<title>登录</title>
	<meta name="viewport" content="width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
	<meta charset="utf-8">
	<link rel="stylesheet" href="../css/main.css">
	<script src="../script/vue.js"></script>
	<script src="../script/axios.js"></script>
	<script src="../script/main.js"></script>
	<script src="../script/TCaptcha.js"></script>
</head>
<body>
	<div class="app" id="app">
    <img class="music" :class="music_play?'music2':''" @click="music_play=!music_play" src="../image/player.png">
    <div class="bg">
			<img src="../image/bg0.jpg">
		</div>
		<div class="form">
			<div class="form-title">
				<img src="../image/login.png">
				<img class="back" @click="open_index" src="../image/back.png">
			</div>
			<div class="form-data">
				<div class="form-data-bg">
					<img src="../image/bg1.png">
				</div>
				<div class="form-item">
					<label class="text">手机</label>
					<input type="text" v-model="account" placeholder="请输入手机号">
				</div>
				<div class="form-item">
					<label class="text">密码</label>
					<input type="password" v-model="password" placeholder="请输入密码">
				</div>
				<div class="form-item">
					<input type="checkbox" class="agree remember" v-model="agree" checked>
					<label><span class="agree_text ">记住密码，下次免登录</span></label>
				</div>
				<div class="form-item">
					<img class="commit" @click="show_captcha" src="../image/commit.png">
				</div>
				<div class="form-item">
					<p class="toreg" @click="open_register">立即注册</p>
					<p class="tofind">忘记密码</p>
				</div>
			</div>
		</div>
	</div>
	<script>
	apiready = function(){
		Vue.prototype.game = new Game("../mp3/bg1.mp3");
		new Vue({
			el:"#app",
			data(){
				return {
                    music_play:true,
					account: "13312345678",  // 手机号,邮箱,用户名
					password: "123456",
					agree:true,              // 是否保存登陆状态，下次免登陆
				}
			},
			watch:{
                music_play(){
                if(this.music_play){
                    this.game.play_music("../mp3/bg1.mp3");
                }else{
                    this.game.stop_music();
                }
                }
            },
            methods:{
                open_register(){
                    this.game.goFrame("register","./register.html");
                },
                open_index(){
                    this.game.goFrame("index","./index.html");
                },
				show_captcha(){
					// 显示验证码
					var captcha1 = new TencentCaptcha(this.game.config.app_id, (res)=>{
						if(res.ret==0){
							// 验证码验证成功,返回4个数据,ret,appid,ticket和randstr
							this.loginhandle(res); // 提交登录数据
						}
					});
					captcha1.show(); // 显示验证码
				},
				loginhandle(res){
					// 登陆处理
					// 验证数据
					if(this.account.length<1 || this.password.length<1){
						this.game.tips("账号或者密码不能为空！");
						return false;
					}

					// 提交获取token
					this.axios.post("",{
						"jsonrpc": "2.0",
						"id": this.game.uuid(),
						"method": "Users.login",
						"params": {
							"account": this.account,
							"password": this.password,
							"ticket": res.ticket,
							"randstr": res.randstr,
						}
					}).then(response=>{
						if(response.data.result.errno !== 1000){
							this.game.tips(response.data.result.errmsg);
						}else{
							// 删除上次登录遗留的token数据

							this.game.delfs(["access_token","refresh_token"]);
							this.game.deldata(["access_token","refresh_token"]);

							// 保存认证令牌
							if(this.r){
								// 记住登陆状态
								this.game.setfs({
									'access_token': response.data.result.access_token,
									'refresh_token': response.data.result.refresh_token
								});

							}else{
								// 不记住登陆状态
								this.game.setdata({
									'access_token': response.data.result.access_token,
									'refresh_token': response.data.result.refresh_token
								});
							}

							// 注册成功!
							api.confirm({
							    title: '提示',
							    msg: '登陆成功',
							    buttons: ['返回首页', '个人中心']
							}, (ret, err)=>{
							    if(ret.buttonIndex == 1){
									// 跳转到首页
									this.game.goFrame("index", "./index.html");
								}else{
									// 跳转到个人中心
									this.game.goWin("user","./user.html");
								}
								// 关闭当前页面返回首页
								this.game.goFrame("index", "./index.html");
							});

						}

					}).catch(error=>{
						this.game.print(error);
					});
				}
            }
		})
	}
	</script>
</body>
</html>
```



### 服务端登陆接口中校验验证码回调是否正确

封装了一个验证码验证工具函数，`application/utils/captcha.py`，代码：

```python
import json
from urllib.request import urlopen
from urllib.parse import urlencode
from flask import current_app
from typing import NoReturn, Dict, Any


class CaptchaError(Exception):
    """验证码异常"""
    pass


class CaptchaParamsError(CaptchaError):
    """参数异常"""
    pass


class CaptchaNetWorkError(CaptchaError):
    """网络异常"""
    pass


class CaptchaFailError(CaptchaError):
    """验证失败"""
    pass


def check_captcha(ticket: str, randstr: str, user_ip: str) -> NoReturn:
    """防水墙验证码的验证回调方法"""

    if len(ticket) < 1 or len(randstr) < 1:
        raise CaptchaParamsError

    try:
        params: Dict[str, Any] = {
            "aid": current_app.config.get("CAPTCHA_APP_ID"),
            "AppSecretKey": current_app.config.get("CAPTCHA_APP_SECRET_KEY"),
            "Ticket": ticket,
            "Randstr": randstr,
            "UserIP": user_ip
        }
    except Exception:
        raise CaptchaParamsError

    try:
        # aid=xxx&appsecretkey=xxx&
        params: bytes = urlencode(params).encode(encoding="utf-8")
        content: bytes = urlopen(current_app.config.get("CAPTCHA_GATEWAY"), params).read()
        res: Dict[str, Any] = json.loads(content)
    except:
        raise CaptchaNetWorkError

    if res["response"] != '1':
        raise CaptchaFailError

```

`users.api`，视图把客户端提交的验证码参数传递到序列化器中验证，代码：

```python
def login(account: str, password: str, ticket: str, randstr: str) -> Dict[str, Any]:
    """
    用户jwt登录
    :param account: 账户名[可以是手机号、邮箱、用户名]
    :param password: 登录密码
    :return
    """
    # 1. 验证数据
    try:
        us: UserLoginSchema = UserLoginSchema()
        # 反序列化
        user: User = us.load({
            "account": account,
            "password": password,
            "ticket": ticket,
            "randstr": randstr
        })

        # 序列化
        payload: Dict[str, Any] = us.dump(user)

        # 2. 生成jwt assess token 和 refresh token
        access_token, refresh_token = gen_token(payload=payload)

        # 3. 返回2个token给客户端
        result: Dict[str, Any] = {
            "errno": code.CODE_OK,
            "errmsg": message.ok,
            "access_token": access_token,
            "refresh_token": refresh_token
        }

    except ValidationError as e:
        result: Dict[str, Any] = {"errno": code.CODE_VALIDATE_ERROR, "errmsg": e.messages}

    return result

```

users/serializers，代码：

```python
from typing import List, Dict, Optional
from flask import request
from flask_marshmallow.sqla import SQLAlchemyAutoSchema, auto_field
from marshmallow import Schema, fields, validate, validates, ValidationError, decorators
from sqlalchemy.orm import scoped_session
from sqlalchemy import or_

from application import message, db, redis_check as redis
from application.utils.captcha import check_captcha, CaptchaParamsError, CaptchaNetWorkError, CaptchaFailError
from .models import User


# ...中间代码省略


class UserLoginSchema(SQLAlchemyAutoSchema):
    """用户登录的构造器"""
    account = fields.String(required=True, load_only=True)
    password = fields.String(required=True, load_only=True)
    money = fields.Float(dump_only=True)
    credit = fields.Float(dump_only=True)
    ticket = fields.String(required=True, load_only=True)
    randstr = fields.String(required=True, load_only=True)

    class Meta:
        model = User
        # 如果要转换模型的全部字段，就不要声明fields或exclude字段即可
        fields = ["id", "nickname", "account", "password", "money","credit", "avatar","province","city","area", "ticket", "randstr"]
        sqla_session = db.session

    @decorators.validates_schema
    def valivate(self, data, **kwargs):
        # 校验验证码
        try:
            check_captcha(data["ticket"], data["randstr"], request.remote_addr)
        except CaptchaParamsError:
            raise ValidationError(message=message.varity_params_error, field_name="ticket")
        except CaptchaNetWorkError:
            raise ValidationError(message=message.varity_network_error, field_name="ticket")
        except CaptchaFailError:
            raise ValidationError(message=message.varity_code_error, field_name="ticket")

    # 钩子，验证成功以后，自动调用
    @decorators.post_load
    def save_object(self, data, **kwargs):
        account = data.get("account")
        password = data.get("password")
        user = User.query.filter(
            or_(
                User.mobile == account,
                User.name == account,
                User.email == account
            )
        ).first()  # 实例化模型

        if not user:
            raise ValidationError(message=message.user_not_exists, field_name="username")

        if not user.check_password(password):
            raise ValidationError(message=message.password_not_match, field_name="password")

        return user

```

错误提示语，`message`，代码：

```python
varity_code_error: str = "验证码验证失败！"
varity_params_error: str = "验证码验证参数有误！"
varity_network_error: str = "验证码校验过程中发生网络异常！"
```

提交版本

```bash
git add .
git commit -m "fix: vefity code"
git push
```

