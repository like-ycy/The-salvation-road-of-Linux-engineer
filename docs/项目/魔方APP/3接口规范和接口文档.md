## Protobuf

### 基本介绍

Protobuf(Google Protocol Buffers)是google开发的的一套用于数据存储，网络通信时用于协议编解码的工具库.它和XML和Json数据差不多,把数据以某种形式保存起来.Protobuf相对与XML和Json的不同之处，它是一种**二进制的数据格式**，具有更高的传输，打包和解包效率。Protobuf 提供了C++、java、python、nodejs、php、go语言的支持，提供了windows(proto.exe)和linux平台动态编译生成proto文件对应的源文件。proto文件定义了协议数据中的实体结构(message ,field)。因为有google背书，所以在各个语言中被迅速普及，常见的应用场景就是微服务架构和DDD架构！！！

protoBuf下载地址：https://github.com/protocolbuffers/protobuf/releases

## flask中基于protobuf实现api接口

### 环境搭建

```bash
# 安装格式转换工具，不同的操作系统，转换工具不同。windows->proto.exe，Linux->protobuf-compiler
sudo apt install -y protobuf-compiler
pip install flask
# python下面用于对protobuf进行编码解码的模块
pip install protobuf
# 网络请求工具库
pip install requests
```



### 接口代码

编写Protobuf数据数据，`Protobuf_Message.proto`，代码：

```protobuf
syntax = "proto3";

// 响应体
message Response {
  int32 returncode = 1;
  message data {
    string username = 1;
    string email = 2;
    int32 age = 3;
  }
  repeated data dataList = 2;
  string message = 3;
}

// 请求体
message Request {
  string data = 1;
  int32 page = 2;
  int32 pageSize = 3;
}
```

编译转换成python格式

```bash
protoc --python_out=./ Protobuf_Message.proto
```

服务端接口，`server.py`，代码：

```python
from Protobuf_Message_pb2 import Request, Response
from flask import Flask, request
app=Flask(__name__)

@app.route("/api/demo", methods=["POST"])
def demo():
    # 解析请求
    request_data = Request()
    request_data.ParseFromString(request.get_data())

    print("data",request_data.data) # data user
    print("page",request_data.page) # page 1
    print("pageSize",request_data.pageSize) # pageSize 10

    # 编写响应信息
    response = Response()
    response.returncode = 200
    response.message = "Success"

    data_list = [
        {"username":"小明", "age": 18, "email":"xiaoming@mofang.com"},
        {"username":"小白", "age": 18, "email":"xiaobai@mofang.com"},
    ]

    for data in data_list:
        item = response.data()
        item.username=data["username"]
        item.age=data["age"]
        item.email=data["email"]
        response.dataList.append(item)

    return response.SerializeToString(), 200

if __name__ == '__main__':
    app.run("127.0.0.1", port=5000)
```

客户端，`client.py`，代码：

```python
from Protobuf_Message_pb2 import Request, Response
import requests
def test_protobuf_api():
    """
    测试 接口
    :return:
    """
    request_data = Request()
    # 编写请求信息
    request_data.data = "user"
    request_data.page = 1
    request_data.pageSize = 10
    req_data = request_data.SerializeToString()# 序列化
    response = requests.post("http://127.0.0.1:5000/api/demo", data=req_data)

    # 获取响应内容
    res = Response()
    res.ParseFromString(response.content) # 反序列化
    print(res.returncode) # 200
    print(res.message)    # 成功
    for data in res.dataList:
        print(f"username:{data.username}, age:{data.age}, email: {data.email}")
        # username:小明, age:18, email=xiaoming@mofang.com
        # username:小白, age:18, email=xiaobai@mofang.com
if __name__ == '__main__':
    test_protobuf_api()
```

先有运行服务端代码，再运行客户端代码，即可查看效果。

## JSON-RPC

所谓的RPC，`Remote Procedure Call`的简写，中文译作**远程过程调用**或者**远程服务调用**。

直观的理解就是，通过网络请求远程服务器获取指定接口的数据，而不用知晓底层网络协议的细节。

`RPC`支持的数据格式很多，比如`XML`格式，`JSON`格式、ProtoBuf等等。最常用的肯定是json和ProtoBuf。我们接下来项目使用到的数据格式json格式。因为是属于前后端之间的数据交互。而如果是属于服务端之间的不同平台或服务端之间的不同语言之间的交互往往有很多人采用了ProtoBuf，因为ProtoBuf在执行和执行的过程中，都是非常高效的，因为ProtoBuf是属于二进制安全的。

JSON-RPC是一个无状态的、轻量级的远程过程调用（RPC）协议。

协议文档：https://www.jsonrpc.org/specification

译文文档：http://wiki.geekdream.com/Specification/json-rpc_2.0.html

JSON-RPC协议中的客户端一般是为了向远程服务器请求执行某个方法/函数。客户端向实现了JSON-RPC协议的服务端发送请求，多个输入参数能够通过**数组或者对象**传递到远程方法，这个远程方法也能返回多个输出数据，具体是什么，当然要看具体的方法实现。因为RPC可以通俗理解为: 

客户端请求服务端完成某一个服务行为,所以JSON-RPC规范要求: <mark>客户端发送的所有请求都是POST请求</mark>!!!

所有的传输数据都是单个对象，用JSON格式进行序列化。

请求要求包含三个特定属性：

```
jsonrpc: 用来声明JSON-RPC协议的版本，现在基本固定为“2.0”

method，方法，是等待调用的远程方法名，字符串类型

params，参数，对象类型或者是数组，向远程方法传递的多个参数值

id，任意类型值，用于和最后的响应进行匹配，也就是这里设定多少，后面响应里这个值也设定为相同的
响应的接收者必须能够给出所有请求以正确的响应。这个值一般不能为Null，且为数字时不能有小数。

{
   "jsonrpc": "2.0",
   "method": "add",
   "params": {
      "键": "值",
   },
   "id": "UUID格式...."
}
```

响应也有三个属性：

```
jsonrpc, 用来声明JSON-RPC协议的版本，现在基本固定为“2.0”

result，结果，是方法的返回值，调用方法出现错误时，必须不包含该成员。

error，错误，当出现错误时，返回一个特定的错误编码，如果没有错误产生，必须不包含该成员。

id，就是请求带的那个id值，必须与请求对象中的id成员的值相同。请求对象中的id时发生错误（如：转换错误或无效的请求），它必须为Null

# 操作成功
{
	"jsonrpc": "2.0",
	"result": {
	   data: {
	   
	   }
	}
	"id": "UUID格式(来自请求中的ID，原样返回)...."
}

# 操作失败
{
	"jsonrpc": "2.0",
	"error": {
	   detail: {
	   
	   }
	}
	"id": "UUID格式(来自请求中的ID，原样返回)...."
}

```

当然，有一些场景下，是不用返回值的，比如只对客户端进行通知，由于不用对请求的id进行匹配，所以这个id就是不必要的，置空或者直接不要了。



在flask中要实现提供json-rpc接口，开发中一般使用**Flask JSON-RPC**模块来实现。

git地址：https://github.com/cenobites/flask-jsonrpc

### 安装Flask-JSONRPC模块

```shell
pip install Flask-JSONRPC
```

直接在`application/__init__.py`项目初始化文件中进行初始化jsonrpc，代码。

```python
# 先写 import.. 后写 from .. import ...
# 先解析器内置，后框架官方，然后第三方模块，接着是自己封装的本地模块。

from pathlib import Path

from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_redis import FlaskRedis
from flask_pymongo import PyMongo
from flask_jsonrpc import JSONRPC

from application.utils.config import init_config
from application.utils.logger import Log
from application.utils.commands import Command
from application.utils.blueprint import register_blueprint, path, include

"""加载组件[单例模式]"""
# SQLAlchemy实例化
db: SQLAlchemy = SQLAlchemy()

# redis实例化
redis_cache: FlaskRedis = FlaskRedis(config_prefix="REDIS")
redis_check: FlaskRedis = FlaskRedis(config_prefix="CHECK")

# mongoDB实例化
mongo: PyMongo = PyMongo()

# 日志实例化
logger:Log = Log()

# 终端命令管理类实例化
command: Command = Command()

# jsonrpc实例化
jsonrpc = JSONRPC()


def init_app(config_path: str) -> Flask:
    """用于创建app实例对象并完成初始化过程的工厂函数"""

    app: Flask = Flask(__name__)

    # 项目根目录
    app.BASE_DIR = Path(__file__).resolve().parent.parent

    # 初始化项目配置
    init_config(app=app, config_path=config_path)

    # SQLAlchemy加载配置
    db.init_app(app)

    # redis加载配置
    redis_cache.init_app(app)
    redis_check.init_app(app)

    # pymongo加载配置
    mongo.init_app(app)

    # 日志加载配置
    logger.init_app(app)

    # 终端命令管理类加载配置
    command.init_app(app)


    # jsonrpc注册到项目中
    # 开启rpc接口的web调试界面：/api/browse
    jsonrpc.browse_url = app.config.get("API_BROWSE_URL", "/api/browse")
    jsonrpc.enable_web_browsable_api = app.config.get("DEBUG", False)
    jsonrpc.init_app(app)

    # 注册蓝图
    register_blueprint(app)

    # db创建数据表
    with app.app_context():
        db.create_all()

    return app

```

`application/settigns/__init__.py`，代码：

```python
"""JSONRPC"""
# api接口web调试界面的url地址
API_BROWSE_URL = "/api/browse"
```

提交版本

```bash
git add .
git commit -m "fix: add flask json rpc"
git push
```

快速实现一个测试的RPC接口。

`application/apps/home/views.py`，编写接口代码：

```python
from flask import jsonify, request
def index():
    print(request.json)
    return "home.views.index"


def demo():
    data = {"name":"xiaoming","age":16}
    return jsonify(data)


from application import jsonrpc
# PEP484规范: 给所有的变量、函数/方法的返回值、参数，必须指定他们的类型
from typing import Union, Any, List, Dict
from numbers import Real


@jsonrpc.method("Home.menu")
def menu(data0: Any, data1: int, data2: float, data3: str, data4: Union[int, bool], data5: bool, data6: List[Any], data7: List[int], data8: Dict[str, Real]) -> List[Any]:
    ret = [
        data0,  # 可以填写任意类型数据
        data1,  # 只能填写整型
        data2,  # 只能填写浮点型
        data3,  # 只能填写字符串
        data4,  # Union表示联合类型， Union[int, bool]表示只能填写 整型和布尔型
        data5,  # 只能填写布尔型
        data6,  # List[Any]，只能填写列表数据，列表中的成员可以是任意类型的数据
        data7,  # List[int]，只能填写列表数据，列表中的成员只能是整型，除此之外，还有 List[str]、List[Dict[str, Any]]
        data8,  # [str, Real]，只能填写字典数据，字典中的键必须是字符串，值必须是数值类型
    ]
    print(f"ret={ret}")
    return ret
```

客户端需要发起post请求，访问地址为：`http://127.0.0.1:5000/api/browse/#/`

可以通过postman发送请求接口，访问数据格式应是：

```json
{
  "jsonrpc": "2.0",
  "method": "Home.menu",
  "params": {
    "data0": 1,
    "data1": 100,
    "data2": 200,
    "data3": "me",
    "data4": 0,
    "data5": true,
    "data6": [
      "A",
      "B",
      200
    ],
    "data7": [
      1,
      2,
      3,
      4
    ],
    "data8": {
      "age": 18,
      "money": 1000
    }
  },
  "id": "272806ab-29a5-49ab-bd2f-36ff2ef29402"
}
```

请求效果：

![image-20210922093908129](3%E6%8E%A5%E5%8F%A3%E8%A7%84%E8%8C%83%E5%92%8C%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3.assets/image-20210922093908129.png)



### 系统自动注册蓝图下的api接口并实现访问名称和视图方法分离

路由代码新增api接口的路由列表apipatterns，`home.urls`：

```python
from typing import List
from application import path
from . import views, api

# 普通视图注册列表
urlpatterns: List = [
    path("/test", views.test, methods=["GET"]),
    path("/test", views.test, methods=["POST"]),
    path("/home", views.Home.as_view("home")),
]


# api接口注册列表
apipatterns: List = [
    path("menu", api.menu),
]
```

把原来home/views.py中的api视图代码，剪切到home/api.py，代码：

```python
# PEP484规范: 给所有的变量、函数/方法的返回值、参数，必须指定他们的类型
from typing import Union, Any, List, Dict
from numbers import Real


def test() -> List[int]:
    ret = [1, 2, 3]
    return ret


def menu(data0: str, data1: int, data2: float, data3: List[int], data4: List[str],
         data5: List[Any], data6: bool, data7: Union[bool, int], data8: Union[int, float, str],
         data9: Real) -> Dict[str, Any]:
    ret = {
        "data0": data0,  # "hello"             --->str
        "data1": data1,  # 100                 --->int
        "data2": data2,  # 3.14                --->float
        "data3": data3,  # [1,2,3]             --->List[int]
        "data4": data4,  # ["A","C","D"]       --->List[str]
        "data5": data5,  # ["小明", 100, true]  --->List[Any]
        "data6": data6,  # true                --->bool
        "data7": data7,  # true / 100                  --->Union[bool, int]
        "data8": data8,  # 75.5 / "75.5" / 75          --->Union[str, float, str]
        "data9": data9,  # 75.5 / "75.5" / 75          --->Real
    }
    return ret
```



调整蓝图注册的代码，自动注册jsonrpc相关的api视图和请求方法名。`utils.blueprint`，代码：

```python
from types import ModuleType
from typing import List, Callable, Dict, Union
from flask import Flask, Blueprint
from importlib import import_module  # 可以根据字符串路径完成导报操作
from flask_jsonrpc import JSONRPC


def register_blueprint(app: Flask, jsonrpc: JSONRPC):
    """自动注册蓝图的工具函数"""
    # 从配置文件中读取需要注册到项目中的蓝图路径信息
    blueprint_path_list: List = app.config.get("INSTALL_BLUEPRINT", [])

    # 从配置文件中读取总路由模块
    app_urls_path: str = app.config.get("URL_PATH", "application.urls")
    # 总路由模块
    app_urls_module: ModuleType = import_module(app_urls_path)

    # 总路由列表
    if not hasattr(app_urls_module, "urlpatterns"):
        app.logger.error("总路由文件URL_PATH，没有路由列表！")
        raise Exception("总路由文件URL_PATH，没有路由列表！")

    app_urlpatterns: List = app_urls_module.urlpatterns

    # 遍历蓝图路径列表，对每一个蓝图进行初始化
    for blueprint_path in blueprint_path_list:
        # 获取蓝图路径中最后一段的包名作为蓝图的名称
        blueprint_name: str = blueprint_path.split(".")[-1]
        # 创建蓝图对象
        blueprint: Blueprint = Blueprint(blueprint_name, blueprint_path)

        # 蓝图路由的前缀
        url_prefix: str = ""

        # 蓝图下注册普通视图的子路由列表
        urlpatterns: List = []

        # 蓝图下注册api视图的子路由列表
        apipatterns: List = []

        # 获取蓝图的父级目录，目的是为了拼接总路由中所有蓝图下的urls子路由文件的路径
        blueprint_father_path: str = ".".join(blueprint_path.split(".")[:-1])

        # 循环总路由列表
        for item in app_urlpatterns:
            # 判断当前蓝图是否有注册到总路由中提供对外访问，如果没有把蓝图注册到总路由中，则无法被外界访问。
            if blueprint_name in item["blueprint_url_subffix"]:
                # 导入当前蓝图下的子路由模块
                urls_module: ModuleType = import_module(f"{blueprint_father_path}.{item['blueprint_url_subffix']}")
                if hasattr(urls_module, "urlpatterns"):
                    # 获取子路由文件中的路由列表
                    urlpatterns = urls_module.urlpatterns
                # 获取urls模块下api列表apiurlpatterns
                if hasattr(urls_module, "apipatterns"):
                    apipatterns = urls_module.apipatterns

                # 提取蓝图路由的前缀
                url_prefix = item["url_prefix"]
                # 从总路由中查到当前蓝图对象的前缀就不要继续往下遍历了
                # 把urlpatterns的每一个路由信息添加注册到蓝图对象里面
                for url in urlpatterns:
                    blueprint.add_url_rule(**url)
                break

        # 把urlpatterns的每一个路由信息添加注册到蓝图对象里面
        for url in urlpatterns:
            blueprint.add_url_rule(**url)

        # 把apipatterns的每一个路由信息添加注册到JSONRPC对象里面
        for api in apipatterns:
            name = api.pop("rule")
            # 判断总路由中针对当前蓝图中所有api子路由列表是否增加了访问前缀
            if len(url_prefix) > 0:
                # 如果有增加了前缀，则转换访问前缀
                # 例如：applications.urls.py中代码：path("/home", "home.urls"),
                # 则普通视图的访问还是遵循原来的访问规则：/home/视图url地址
                # 则api视图的访问方法名为：Home.menu，menu为子路由列表中的访问方法名
                api["name"] = f"{url_prefix[1:].title()}.{name}" # title()表示把单词转换成首字母大写
            else:
                # 如果没有追钱，则直接方法名为：menu，menu为子路由列表中的访问方法名
                api["name"] = name
            jsonrpc.register_view_function(**api)

        try:
            # 让蓝图自动发现模型模块
            import_module(f"{blueprint_path}.models")
        except ModuleNotFoundError:
            pass

        # 把蓝图对象注册到app实例对象
        # url_prefix 是蓝图下所有子路由的地址前缀
        app.register_blueprint(blueprint, url_prefix=url_prefix)


def path(rule: str, name: Union[Callable, str], **kwargs) -> Dict:
    """
    绑定url地址和视图的映射关系
    :param rule: 视图路由或者蓝图路由前缀
    :param name: 视图函数名称或者蓝图名称，
           当name是一个蓝图的名称时，
           格式：蓝图包名.路由模块名
           例如：蓝图目录是home, 路由模块名是urls，则参数：home.urls
    :return: Dict
    """
    if isinstance(name, Callable):
        return {"rule": rule, "view_func": name, **kwargs}
    elif isinstance(name, str):
        return {"url_prefix": rule, "blueprint_url_subffix": name, **kwargs }
    else:
        return {}
```

在项目初始化主程序中，调用register_blueprint函数时，增加jsonrpc对象，`application/__init__.py`，代码：

```python
# 项目初始化主程序

from pathlib import Path

from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_redis import FlaskRedis
from flask_pymongo import PyMongo
from flask_jsonrpc import JSONRPC

from application.utils.config import Config
from application.utils.logger import Log
from application.utils.commands import Command
from application.utils.blueprint import register_blueprint, path


"""加载组件[单例模式]"""

# 初始化配置加载类
config: Config = Config()

# SQLAlchemy初始化
db: SQLAlchemy = SQLAlchemy()

# redis初始化
redis_cache: FlaskRedis = FlaskRedis(config_prefix="REDIS")
redis_check: FlaskRedis = FlaskRedis(config_prefix="CHECK")


# mongo初始化
mongo: PyMongo = PyMongo()


# 日志配置类初始化
logger: Log = Log()

# 终端命令管理类实例化
command: Command = Command()


# 实例化JSONRPC
jsonrpc = JSONRPC()

def init_app(config_path: str) -> Flask:
    """用于创建app实例对象并完成初始化过程的工厂函数"""
    # 实例化flask应用对象
    app: Flask = Flask(__name__)
    # 项目跟目录路径
    app.BASE_DIR = Path(__file__).resolve().parent.parent
    # 加载配置
    config.init_app(app, config_path)

    # 加载mysql数据库配置
    db.init_app(app)

    # redis加载配置
    redis_cache.init_app(app)
    redis_check.init_app(app)

    # pymongo加载配置
    mongo.init_app(app)

    # 日志加载配置
    logger.init_app(app)

    # 终端命令管理类加载配置
    command.init_app(app)

    # jsonrpc注册到项目中，必须写在蓝图注册代码的上方
    # 开启rpc接口的web调试界面：/api/browse
    jsonrpc.browse_url = app.config.get("API_BROWSE_URL", "/api/browse")
    jsonrpc.enable_web_browsable_api = app.config.get("DEBUG", False)
    jsonrpc.init_app(app)

    # 注册蓝图
    register_blueprint(app, jsonrpc)


    # db创建数据表
    with app.app_context():
        db.create_all()

    return app

```



通过postman访问地址：`127.0.0.1:5000/api`，请求体：

```python
{
  "jsonrpc": "2.0",
  "method": "Home.menu",
  "params": {
    "data0": 1,
    "data1": 100,
    "data2": 200,
    "data3": "me",
    "data4": 0,
    "data5": true,
    "data6": [
      "A",
      "B",
      200
    ],
    "data7": [
      1,
      2,
      3,
      4
    ],
    "data8": {
      "age": 18,
      "money": 1000
    }
  },
  "id": "272806ab-29a5-49ab-bd2f-36ff2ef29402"
}
```

注意：在上面的蓝图注册函数中，注册api别名的时候，拼接了当前蓝图名称所以访问的method值实际上是`蓝图名称.访问名称`。



上面的json-rpc的API接口中视图方法都是函数，JSONRPC中也支持类视图。

当前flask-jsonrpc模块也支持把多个相关的api接口函数写成类方法格式。`home/api.py`，代码：

```python
class User(object):
    def index(self, num: int) -> Dict[str, Union[int, str]]:
        return {
            "errno": 200,
            "errmsg": "ok",
            "data": "hello world!%s" % num
        }

    def list(self) -> Dict[str,str]:
        return {
            "data": "hello,list"
        }
```

路由示例代码，`home/urls.py`:

```python
from typing import List
from application import path
from . import views, api

# 普通视图注册列表
urlpatterns: List = [
    path("/test", views.test, methods=["GET"]),
    path("/test", views.test, methods=["POST"]),
    path("/home", views.Home.as_view("home")),
]


# 实例化视图类，此处比较麻烦，所以你可以参考django的as_views方法，让路径和视图方法名对应。
user = api.User()

# api接口注册列表
apipatterns: List = [
    path("menu", api.menu),
    path("User.index", user.index),
    path("User.list", user.list),
]
```

访问请求：

```json
POST  /api
{
    "jsonrpc": "2.0",
    "id": "148c96a5-456c-43ba-a534-ebb0b54311cc",
    "method": "Home.User.index",  // Home就是蓝图名称，User就是类名，index则是方法名
    "params": {
        "num": 300
    }
}
```



访问效果：

![image-20220117161946181](3%E6%8E%A5%E5%8F%A3%E8%A7%84%E8%8C%83%E5%92%8C%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3.assets/image-20220117161946181.png)



如果觉得上面的代码中，每次注册类视图比较麻烦的话，可以根据之前django中所学的原理，给flask的类视图增加as_view方法。

先到urils/blueprint.py中新增一个视图基类，代码：

```python
class APIView(object):
    """视图基类"""
    @classmethod
    def as_view(cls, func):
        if hasattr(cls, func):
            obj = cls()
            return getattr(obj, func)
```

将来的蓝图下的api.py文件中的类视图都继承这个视图基类，代码：

```python
# PEP484规范: 给所有的变量、函数/方法的返回值、参数，必须指定他们的类型
from typing import Union, Any, List, Dict
from numbers import Real


def test() -> List[int]:
    ret = [1, 2, 3]
    return ret


def menu(data0: str, data1: int, data2: float, data3: List[int], data4: List[str],
         data5: List[Any], data6: bool, data7: Union[bool, int], data8: Union[int, float, str],
         data9: Real) -> Dict[str, Any]:
    ret = {
        "data0": data0,  # "hello"             --->str
        "data1": data1,  # 100                 --->int
        "data2": data2,  # 3.14                --->float
        "data3": data3,  # [1,2,3]             --->List[int]
        "data4": data4,  # ["A","C","D"]       --->List[str]
        "data5": data5,  # ["小明", 100, true]  --->List[Any]
        "data6": data6,  # true                --->bool
        "data7": data7,  # true / 100                  --->Union[bool, int]
        "data8": data8,  # 75.5 / "75.5" / 75          --->Union[str, float, str]
        "data9": data9,  # 75.5 / "75.5" / 75          --->Real
    }
    return ret


from application import APIView


class User(APIView):
    def index(self, num: int) -> Dict[str, Union[int, str]]:
        return {
            "errno": 200,
            "errmsg": "ok",
            "data": "hello world!%s" % num
        }

    def list(self) -> Dict[str,str]:
        return {
            "data": "hello,list"
        }
```

视图类继承了APIView这个视图基类以后，类视图在绑定视图访问名称则如下，home/urls.py，代码：

```python
from typing import List
from application import path
from . import views, api

# 普通视图注册列表
urlpatterns: List = [
    path("/test", views.test, methods=["GET"]),
    path("/test", views.test, methods=["POST"]),
    path("/home", views.Home.as_view("home")),
]


# 实例化视图类，此处比较麻烦，所以你可以参考django的as_views方法，让路径和视图方法名对应。
# api接口注册列表
apipatterns: List = [
    path("menu", api.menu),
    path("User.index", api.User.as_view("index")),
    path("User.list", api.User.as_view("list")),
]

```

经过上面的处理以后，则视图类的视图方法在注册RPC子路由列表时不需要提前实例化了。



因为flask-jsonrpc模块虽然像之前drf框架提供了一个web版本的调试页面给我们查看和使用接口，但是提供界面在参数上提示是不清晰的。所以不利于项目在开发过程客户端与服务端的沟通和交流，对于项目将来的维护来说，也是不利的。

## 接口文档编写

在企业中，如果我们作为服务端开发编写api接口，主要工作除了**编写API接口代码**以外，还需要我们**编写api接口文档**和**API接口的测试用例代码**。

这里我们先介绍一个比较常用的文档工具编写api接口文档，例如：当前笔记使用的typora，或者showdoc

官网: https://www.showdoc.com.cn/

下载: https://www.showdoc.com.cn/clients

安装完成以后,第一次使用需要配置一个服务端地址, 这个服务端地址,可以是本地开发的真实服务端地址,也可以官方提供的测试地址.

除了上面的showdoc以外，还可以使用postman或者 swagger