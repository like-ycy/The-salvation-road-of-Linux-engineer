## 服务端项目搭建

创建虚拟环境

```python
conda create -n mofang python=3.8
conda activate mofang
```

安装开发中使用的依赖模块

```bash
pip install flask
pip install flask-redis
pip install flask-mysqldb -i https://pypi.douban.com/simple
pip install flask-sqlalchemy -i https://pypi.douban.com/simple
pip install Flask-PyMongo -i https://pypi.douban.com/simple
```

新建服务端项目根目录mofangapi，接着在pycharm中打开项目目录mofangapi编写manage.py启动程序文件

常见的系统启动程序文件名：manage.py / run.py / main.py / home.py / index.py / common.py

### 创建启动程序

manage.py，代码：

```python
from flask import Flask

app = Flask(__name__)

@app.route('/')
def index():
    return 'index'

if __name__ == '__main__':
    app.run()
```

manage.py终不能存放大量的开发代码, 在开发中应该体现的是一种分工精神,所以我们可以把flask中各种功能代码进行分类分文件存储.

创建项目目录结构：

```
服务端项目根目录/
├── application/            # 项目主要逻辑代码保存目录
|   ├── settings/           # 项目配置存储目录
│   │   ├ dev.py            # 开发阶段的配置文件【本地开发者使用】
│   │   ├ pro.py            # 生产阶段的配置文件【线上服务器使用】
|   |   ├ __init__.py       # 项目公共配置文件，相当于django的global_settings.py
│   ├── __init__.py         # 项目初始化入口
├── manage.py               # 项目的终端管理脚本文件
```



### 构建全局初始化工厂函数创建app应用对象

把引导整个项目启动的全局初始化代码,保存到`application/__init__py`,代码:

```python
# 项目初始化主程序
from flask import Flask

def init_app() -> Flask:
    """用于创建app实例对象并完成初始化过程的工厂函数"""
    # 实例化flask应用对象
    app: Flask = Flask(__name__)
    return app

```

manage.py,中调用初始化函数,创建app应用实例对象,代码:

```python
from application import init_app,Flask

app: Flask = init_app()

@app.route('/')
def index():
    return 'index'

if __name__ == '__main__':
    app.run()
```

记录代码版本

```python
git init
git config user.name "mooluo"
git config user.email "649641514@qq.com"
git remote add origin git@gitee.com:mooluo_admin/mofangapi.git
ssh-keygen -C "649641514@qq.com"
cat ~/.ssh/id_rsa.pub  # 把公钥复制到gitee 「个人设置」->「安全设置」->「SSH公钥」->「添加公钥」
rm -rf .idea
git add .
git commit -m "fix: crate app instance"
git push -u origin master
```



### 基于shell脚本启动项目

项目根目录下`mofangapi/command.sh`，代码：

```python
#!/usr/bin/env bash
export FLASK_APP="/home/moluo/Desktop/mofangapi/manage.py"
export FLASK_ENV=development

if [ $1 ]; then
  if [ $1 == "run" ]; then
    flask run --host=0.0.0.0 --port=5000
  else
    flask $1
  fi


fi
```

终端下设置执行权限

```bash
cd ~/Desktop/mofangapi
chmod 755 command.sh
./command.sh run
```

终端运行效果：

![image-20220112153453807](1%E5%90%8E%E7%AB%AF%E6%90%AD%E5%BB%BA.assets/image-20220112153453807.png)



### 加载项目配置

在application/utils/config.py中准备加载配置的函数代码：

```python
from flask import Flask


class Config(object):
    """项目配置加载类"""
    def __init__(self, app: Flask=None, config_path: str=None):

        if app:
            self.init_app(app, config_path)

    def init_app(self, app: Flask, path: str) -> None:
        """
        项目配置初始化函数
        :param app: 当前flask应用实例对象[python中的对象属于引用类型，所以函数内部改了app的数据，外界的app也会修改]
        :param path: 配置文件的导包路径   application.settings.dev
        :return:
        """
        # 先加载默认配置settings.__init__，然后加载当前指定配置config_path
        init_path: str = ".".join(path.split(".")[:-1])
        app.config.from_object(init_path)   # 先加载settings.__init__
        app.config.from_object(path) # 再加载settings.dev或者settings.prod
```

编写项目默认配置文件, `application/settings/__init__.py`代码:

```python
"""公共配置"""
# 调试模式
DEBUG: bool = False
# 语言
LANGUAGE: str = "en"
```

当然, 项目开发过程完成以后肯定会项目上线,所以针对配置文件,我们可以准备不同环境下的配置

`application/settings/dev.py`,代码:

```python
"""本地配置"""
# 调试模式
DEBUG: bool = True
# 语言
LANGUAGE: str = "zh_hans"
```

`application/settings/pro.py`,代码:

```python
"""本地配置"""
# 调试模式
DEBUG: bool = False
# 语言
LANGUAGE: str = "zh_hans"
```



在项目入口文件`application/__init__py`中加载配置,代码:

```python
# 项目初始化主程序
from flask import Flask
from application.utils.config import Config

# 初始化配置加载类
config: Config = Config()


def init_app(config_path) -> Flask:
    """用于创建app实例对象并完成初始化过程的工厂函数"""
    # 实例化flask应用对象
    app: Flask = Flask(__name__)
    # 加载配置
    config.init_app(app, config_path)
    return app
```

在创建app对象的项目启动文件manage.py中,设置配置路径

```python
from application import init_app,Flask

app: Flask = init_app("application.settings.dev")

@app.route('/')
def index():
    return 'index'

if __name__ == '__main__':
    app.run()
```

提交版本


```
git add .
git commit -m "fix: add config function, init porject config"
git push
```



### 数据库初始化

#### SQLAlchemy初始化

默认项目配置文件中增加配置选项,`application/settings/__init__.py`,代码:

```python
"""公共配置"""


"""调试模式"""
DEBUG: bool = False

"""本地化国际化"""
# 语言
LANGUAGE: str = "en"


"""数据库配置"""
# 数据库连接
SQLALCHEMY_DATABASE_URI: str = ""

# 动态追踪修改设置
SQLALCHEMY_TRACK_MODIFICATIONS: bool = False

# 查询时会显示原始SQL语句
SQLALCHEMY_ECHO: bool = False
```

开发配置`settings/dev.py`中,配置数据库连接信息,代码:

```python
"""本地配置"""
# 调试模式
DEBUG: bool = True
# 语言
LANGUAGE: str = "zh_hans"

"""数据库配置"""
# 数据库连接
SQLALCHEMY_DATABASE_URI: str = "mysql://mofanguser:mofang@127.0.0.1:3306/mofang?charset=utf8mb4"

# 查询时会显示原始SQL语句
SQLALCHEMY_ECHO: bool = True
```



在mysql终端下, 创建属于当前魔方项目的数据库管理用户, 命令如下:

```python
mysql -uroot -p123
create database mofang charset=utf8mb4;
# 针对当前数据库配置账户信息
# mysql8.0之后
create user 'mofanguser'@'%' identified with mysql_native_password by 'mofang';
GRANT ALL ON mofang.* TO 'mofanguser'@'%';

# mysql8.0之前
# create user mofanguser identified by 'mofang'; 
# grant all privileges on mofang.* to 'mofanguser'@'%';
# flush privileges;
```

在项目初始化主程序中,对数据库功能进行初始化,`application/__init__.py`,代码:

```python
from flask import Flask
from flask_sqlalchemy import SQLAlchemy

from application.utils.config import init_config

# 初始化配置类
config: Config = Config()
    
# SQLAlchemy初始化
db: SQLAlchemy = SQLAlchemy()

def init_app(config_path):
    """用于创建app实例对象并完成初始化过程的工厂函数"""
    app: Flask = Flask(__name__)
    # 加载配置
    init_config(app, config_path)
    # print(app.config)

    # SQLAlchemy加载配置
    db.init_app(app)

    return app
```

提交版本

```bash
git add .
git commit -m "fix: connect mysql"
git push
```



#### Redis数据库初始化

公共配置文件，`application/settings/__init__.py`，代码：

```python
"""公共配置"""


"""调试模式"""
DEBUG: bool = False

"""本地化国际化"""
# 语言
LANGUAGE: str = "en"


"""mysql数据库配置"""
# 数据库连接
SQLALCHEMY_DATABASE_URI: str = ""

# 动态追踪修改设置
SQLALCHEMY_TRACK_MODIFICATIONS: bool = False

# 查询时会显示原始SQL语句
SQLALCHEMY_ECHO: bool = False

"""redis数据库配置"""
REDIS_URL = "redis://@127.0.0.1:6379/0"

```

开发配置文件，`application/settings/dev.py`，代码：

```python
"""本地配置"""


"""调试模式"""
DEBUG: bool = True


"""本地化国际化"""
# 语言
LANGUAGE: str = "zh_hans"


"""数据库配置"""
# 数据库连接
SQLALCHEMY_DATABASE_URI: str = "mysql://mofanguser:mofang@127.0.0.1:3306/mofang?charset=utf8mb4"

# 查询时会显示原始SQL语句
SQLALCHEMY_ECHO: bool = True


"""redis配置"""
# 默认缓存数据
REDIS_URL: str = "redis://:@127.0.0.1:6379/0"
# 验证相关缓存
CHECK_URL: str  = "redis://:@127.0.0.1:6379/1"
```



在项目初始化主程序中, 对redis进行初始化,`applicaiton/__init__.py`,代码:

```python
# 项目初始化主程序
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_redis import FlaskRedis

from application.utils.config import Config


"""加载组件[单例模式]"""

# 初始化配置加载类
config: Config = Config()

# SQLAlchemy初始化
db: SQLAlchemy = SQLAlchemy()

# redis初始化
redis_cache: FlaskRedis = FlaskRedis(config_prefix="REDIS")
redis_check: FlaskRedis = FlaskRedis(config_prefix="CHECK")


def init_app(config_path) -> Flask:
    """用于创建app实例对象并完成初始化过程的工厂函数"""
    # 实例化flask应用对象
    app: Flask = Flask(__name__)

    # 加载配置
    config.init_app(app, config_path)

    # 加载mysql数据库配置
    db.init_app(app)

    # redis加载配置
    redis_cache.init_app(app)
    redis_check.init_app(app)

    return app

```



#### mongoDB数据库初始化

在接下来的项目开发中，我们会先使用pymongo进行数据库操作，后面改成MongoEngineORM框架。所以暂时我们先进行pymongo的初始化。

进入mongoDB交互终端，分配一个账号给当前项目

```bash
# 如果有mongodb的账户管理员，则直接进入mongoDB终端，通过如下操作创建mofang数据库的管理员
mongo
use admin
db.auth("admin","123")

# 如果没有mongoDB的账户管理员，则需要先确保已经关闭了mongoDB的访问控制
# sudo vim /etc/mongod.conf
# 找到31行左右的security配置项，把security和authorization的左边添加注释#，并保存配置文件
# systemctl restart mongod
# 重启完mongoDB以后，接着mongo进入终端
# 进入admin数据库
# use admin;

# 给mofang数据库创建一个数据库拥有者身份的管理员账号
use mofang
db.createUser({
    user: "mofang",
    pwd: "mofang",
    roles: [
        { role: "dbOwner", db: "mofang"}
    ]
})

# 如果是关闭mongoDB的访问控制而创建，则需要重新打开配置文件
# sudo vim /etc/mongod.conf
# 找到31行左右的security配置项，把security和authorization的左边注释#号去掉，并保存配置文件
# systemctl restart mongod
```



`settings/__init__.py`，代码：

```python
"""公共配置"""


"""调试模式"""
DEBUG: bool = False

"""本地化国际化"""
# 语言
LANGUAGE: str = "en"


"""mysql数据库配置"""
# 数据库连接
SQLALCHEMY_DATABASE_URI: str = ""

# 动态追踪修改设置
SQLALCHEMY_TRACK_MODIFICATIONS: bool = False

# 查询时会显示原始SQL语句
SQLALCHEMY_ECHO: bool = False

"""redis数据库配置"""
REDIS_URL = "redis://@127.0.0.1:6379/0"


"""mongoDB配置"""
# mongodb://[username:password@]host1[:port1][,...hostN[:portN]][/[defaultauthdb][?options]]
MONGO_URI: str = "mongodb://:@127.0.0.1:27017/admin"

```

settings/dev.py，代码：

```python
"""本地配置"""


"""调试模式"""
DEBUG: bool = True


"""本地化国际化"""
# 语言
LANGUAGE: str = "zh_hans"


"""数据库配置"""
# 数据库连接
SQLALCHEMY_DATABASE_URI: str = "mysql://mofanguser:mofang@127.0.0.1:3306/mofang?charset=utf8mb4"

# 查询时会显示原始SQL语句
SQLALCHEMY_ECHO: bool = True


"""redis配置"""
# 默认缓存数据
REDIS_URL: str = "redis://:@127.0.0.1:6379/0"
# 验证相关缓存
CHECK_URL: str  = "redis://:@127.0.0.1:6379/1"

"""mongoDB配置"""
MONGO_URI: str = "mongodb://mofang:mofang@127.0.0.1:27017/mofang"

```

`application/__init__.py`，对mongoDB进行初始化

```python
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_redis import FlaskRedis
from flask_pymongo import PyMongo

from application.utils.config import init_config

"""加载组件[单例模式]"""
# SQLAlchemy实例化
db: SQLAlchemy = SQLAlchemy()

# redis实例化
redis_cache: FlaskRedis = FlaskRedis(config_prefix="REDIS")
redis_check: FlaskRedis = FlaskRedis(config_prefix="CHECK")

# mongoDB实例化
mongo: PyMongo = PyMongo()


def init_app(config_path: str) -> Flask:
    """用于创建app实例对象并完成初始化过程的工厂函数"""
    app: Flask = Flask(__name__)

    # 初始化项目配置
    init_config(app=app, config_path=config_path)

    # SQLAlchemy加载配置
    db.init_app(app)

    # redis加载配置
    redis_cache.init_app(app)
    redis_check.init_app(app)

    # pymongo加载配置
    mongo.init_app(app)

    return app

```

提交版本

```bash
git add .
git commit -m "fix: add redis configration and mongodb configration"
git push
```



完成上面的项目构建步骤以后，此时目录结构新增logs目录，目录结构如下：

```bash
mofangapi/                  # 项目根目录
├── logs/                   # 项目日志存储目录
|   └ mofang.log            # 项目日志
├── application/            # 项目主要逻辑代码保存目录
|   ├── settings/           # 项目配置存储目录
│   │   ├ dev.py            # 开发阶段的配置文件
│   │   ├ pro.py            # 生产阶段的配置文件
|   |   └ __init__.py       # 项目公共配置文件
|   ├── utils/              # 工具函数库/类库
│   │   └ config.py         # 配置相关的辅助类或者辅助函数
│   └── __init__.py         # 项目初始化文件[入口程序，APP工厂函数]
├── manage.py               # 项目的终端管理脚本文件
└── command.sh              # 终端shell命令脚本，用于完成终端操作和启动项目
```



### 日志初始化

flask中本身内置了基于loging模块封装的日志功能的,我们在使用的时候, 一般日志如果不是核心重点,则通过由python内置的logging模块进行配置集成使用即可, 如果项目中日志发挥作用比较重要, 则一般安装部署ELK日志分析系统.

#### 日志的等级

```
从高到低，依次：
	FATAL/CRITICAL = 致命的，危险的
	ERROR = 错误
	WARNING = 警告
	INFO = 信息
	DEBUG = 调试
```

flask日志功能的基本使用

manage.py

```python
from flask import Flask

from application import init_app

# PEP484规范
app: Flask = init_app(config_path="application.settings.dev")


@app.route('/')
def index():
    # 生产模式下，debug和info等级的日志信息会被忽略
    app.logger.debug("debug等级的日志信息")
    app.logger.info("info等级的日志信息")
    app.logger.warning("warning等级的日志信息")
    app.logger.error("error等级的日志信息")
    app.logger.fatal("fatal等级的日志信息")
    
    return 'index'

if __name__ == '__main__':
    app.run()
```

command.sh，代码：

```bash
#!/usr/bin/env bash
export FLASK_APP="/home/moluo/Desktop/mofangapi/manage.py"
# 生产模式/运营模式
# export FLASK_ENV=product
# 开发模式
export FLASK_ENV=development

if [ $1 ]; then
  if [ $1 == "run" ]; then
    flask run --host=0.0.0.0 --port=5000
  else
    flask $1
  fi
fi
```

在项目运行时，框架本身会不断记录代码程序运行的日志错误，但是我们将来编写的业务逻辑也可能存在抛出异常的情况，这些异常和框架代码本身无关，如果都混在一起的话，对于找出错误，是没有帮助的。所以，我们在这里新建一个日志记录器，专门只是记录我们业务逻辑的相关日志。

#### 构建日志模块

把日志初始化相关的代码封装成一个日志类Log，`application/utils/logger.py`，代码：

```python
import logging
from logging.handlers import RotatingFileHandler       # 按文件大小分割日志文件
from logging.handlers import TimedRotatingFileHandler    # 按时间分割日志文件
from flask import Flask

class Log(object):
    """日志配置类"""

    def __init__(self, app: Flask = None):
        """
        日志实例化
        :param app: 当前flask应用实例对象
        """
        if app is not None:
            self.init_app(app)

    def init_app(self, app):
        """
        读取项目的配置项
        :param app: 当前flask应用实例对象
        :return: None
        """
        self.app = app
        self.log_file = self.app.BASE_DIR / self.app.config.get("LOG_FILE", 'logs/app.log')
        self.log_level = self.app.config.get("LOG_LEVEL", 'INFO')
        self.log_backpu_count = self.app.config.get("LOG_BACKPU_COUNT", 31)
        self.log_format = self.app.config.get("LOG_FORMAT", '%(asctime)s - %(levelname)s - %(filename)s - %(funcName)s - %(lineno)s - %(message)s')

        self.setup()

    def setup(self) -> None:
        """
        集成日志功能到flask项目中
        :return:
        """
        # from logging.handlers import TimedRotatingFileHandler 按时间周期分割日志
        handler: TimedRotatingFileHandler = TimedRotatingFileHandler(
            filename=self.log_file,  # 日志存储的文件路径
            when="midnight",  # 每天备份日志的时间，午夜
            backupCount=self.log_backpu_count,  # 备份数量
            encoding='UTF-8'
        )

        # from logging.handlers import RotatingFileHandler      按文件大小分割日志
        # handler: RotatingFileHandler = RotatingFileHandler(
        #     filename=self.log_file,
        #     maxBytes=300*1024*1024,
        #     backupCount=self.log_backpu_count,
        #     encoding='UTF-8',
        # )

        # 设置日志信息的等级
        handler.setLevel(self.log_level)

        # 日志信息的格式
        logging_format: logging.Formatter = logging.Formatter(self.log_format)
        handler.setFormatter(logging_format)

        self.app.logger.addHandler(handler)
```

`application/settings/__init__.py`代码：

```python
"""日志配置"""
LOG_FILE: str = "logs/app.log"
LOG_LEVEL: str = "INFO"
LOG_BACKPU_COUNT: int = 31
LOG_FORMAT: str = '%(asctime)s - %(levelname)s - %(filename)s - %(funcName)s - %(lineno)s - %(message)s'
```

`application/settings/dev.py`代码：

```python
"""日志配置"""
LOG_FILE: str = "logs/mofang.log"
LOG_LEVEL: str = "DEBUG"
LOG_BACKPU_COUNT: int = 31
LOG_FORMAT: str = '%(asctime)s - %(levelname)s - %(filename)s - %(funcName)s - %(lineno)s - %(message)s'
```

在 `application/__init__.py`文件中的`init_app` 方法中调用日志类进行日志功能的初始化。

```python
# 项目初始化主程序

from pathlib import Path

from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_redis import FlaskRedis
from flask_pymongo import PyMongo

from application.utils.config import Config
from application.utils.logger import Log


"""加载组件[单例模式]"""

# 初始化配置加载类
config: Config = Config()

# SQLAlchemy初始化
db: SQLAlchemy = SQLAlchemy()

# redis初始化
redis_cache: FlaskRedis = FlaskRedis(config_prefix="REDIS")
redis_check: FlaskRedis = FlaskRedis(config_prefix="CHECK")


# mongo初始化
mongo: PyMongo = PyMongo()


# 日志配置类初始化
logger = Log()

def init_app(config_path) -> Flask:
    """用于创建app实例对象并完成初始化过程的工厂函数"""
    # 实例化flask应用对象
    app: Flask = Flask(__name__)
    # 项目跟目录路径
    app.BASE_DIR = Path(__file__).resolve().parent.parent
    # 加载配置
    config.init_app(app, config_path)

    # 加载mysql数据库配置
    db.init_app(app)

    # redis加载配置
    redis_cache.init_app(app)
    redis_check.init_app(app)

    # pymongo加载配置
    mongo.init_app(app)

    # 日志加载配置
    logger.init_app(app)

    return app

```



新增日志以后的项目目录结构

```bash
mofangapi/
├── application/
│   ├── __init__.py
│   ├── settings/
│   │   ├── dev.py
│   │   ├── __init__.py
│   │   ├── pro.py
│   └── utils/
│       ├── config.py
│       ├── __init__.py
│       └── logger.py      # 日志相关模块代码
├── logs/                  # 日志文件存储目录
│   └── mofang.log
├── .gitignore
├── command.sh
└── manage.py
```

经过上面的改造，我们接下来就可以开始创建蓝图了。

提交代码

```bash
git add .
git commit -m "fix: add log"
git push
```



### 蓝图初始化

在application下创建apps目录，apps以后专门用于保存项目的每一个蓝图应用，并在apps创建home蓝图目录,并在`home/__init__.py`文件中创建蓝图对象，还有蓝图目录下若干文件，例如视图、模型、路由、序列化器等文件。

```
.
└── application
    ├── __init__.py
    └── apps/
        └─ home/
           ├─ __init__.py
           ├─ admin.py        # admin站点配置文件
           ├─ serializers.py  # 序列化文件  marshmallow
           ├─ models.py       # mysql模型
           ├─ documents.py     # mongoDB模型
           ├─ tasks.py        # celery的异步任务
           ├─ ws.py           # websocket 的视图文件[websocket接口视图]
           ├─ api.py          # api 的视图文件[api接口视图]
           ├─ views.py        # http web视图接口   [普通视图]
           ├─ urls.py         # 子路由文件
           └─ tests.py        # 单元测试的测试用例
```

我们可以通过自定义终端命令, 创建一个自动生成蓝图目录的命令.`application/utils/commands.py`,代码:

```python
import click, os
from typing import Optional
from flask import Flask

class Command(object):
    """命令管理类"""
    def __init__(self, app: Optional[Flask] = None):
        if app is not None:
            self.init_app(app)

    def init_app(self, app: Flask):
        self.app: Flask = app
        self.setup()

    def setup(self):
        """初始化终端命令"""
        self.blueprint()  # 自动创建蓝图目录和文件

    def blueprint(self):
        """蓝图生成命令"""
        @self.app.cli.command("blue")  # 指定终端命令的调用名称
        @click.option("--name", default="home", help="蓝图目录名称", type=str)
        def create_blueprint(name: str):
            # 生成蓝图名称对象的目录
            os.mkdir(name)
            open("%s/__init__.py" % name, "w")
            open("%s/ws.py" % name, "w")  # websocket的视图文件
            open("%s/api.py" % name, "w")  # api接口的视图文件
            open("%s/views.py" % name, "w")  # 普通视图文件
            open("%s/models.py" % name, "w")
            open("%s/documents.py" % name, "w")
            open("%s/urls.py" % name, "w")  # 视图路由
            open("%s/test.py" % name, "w")
            open("%s/tasks.py" % name, "w")
            open("%s/serializers.py" % name, "w")  # 序列化器文件

            print("蓝图[%s]创建完成...." % name)
```

上面的命令就可以帮我们完成项目中生成蓝图的功能,就下来我们就可以直接把命令注册到manage对象中就可以使用了.

在项目入口文件`application/__init__.py`中, 初始化终端命令即可。

```python
# 先写 import.. 后写 from .. import ...
# 先解析器内置，后框架官方，然后第三方模块，接着是自己封装的本地模块。

from pathlib import Path

from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_redis import FlaskRedis
from flask_pymongo import PyMongo

from application.utils.config import init_config
from application.utils.logger import Log
from application.utils.commands import Command

"""加载组件[单例模式]"""
# SQLAlchemy实例化
db: SQLAlchemy = SQLAlchemy()

# redis实例化
redis_cache: FlaskRedis = FlaskRedis(config_prefix="REDIS")
redis_check: FlaskRedis = FlaskRedis(config_prefix="CHECK")

# mongoDB实例化
mongo: PyMongo = PyMongo()

# 日志实例化
logger:Log = Log()

# 终端命令管理类实例化
command: Command = Command()


def init_app(config_path: str) -> Flask:
    """用于创建app实例对象并完成初始化过程的工厂函数"""

    app: Flask = Flask(__name__)

    # 项目根目录
    app.BASE_DIR = Path(__file__).resolve().parent.parent

    # 初始化项目配置
    init_config(app=app, config_path=config_path)

    # SQLAlchemy加载配置
    db.init_app(app)

    # redis加载配置
    redis_cache.init_app(app)
    redis_check.init_app(app)

    # pymongo加载配置
    mongo.init_app(app)

    # 日志加载配置
    logger.init_app(app)

    # 终端命令管理类加载配置
    command.init_app(app)

    return app

```

接下来就可以在终端下,通过命令生成蓝图目录了，在项目根目录下创建生成蓝图的shell命令，`command.sh`：

```bash
#!/usr/bin/env bash
export FLASK_APP="/home/moluo/Desktop/mofangapi/manage.py"
# 生产模式/运营模式
# export FLASK_ENV=product
# 开发模式
export FLASK_ENV=development

if [ $1 ]; then
  if [ $1 == "run" ]; then
    flask run --host=0.0.0.0 --port=5000
  elif [ $1 == "blue" ]; then
    cd application/apps
    flask $1 --name=$2
  else
    flask $1
  fi
fi
```

终端下调用：

```bash
./command.sh blue home
```

效果:

![image-20220112174344507](1%E5%90%8E%E7%AB%AF%E6%90%AD%E5%BB%BA.assets/image-20220112174344507.png)

有了蓝图以后,接下来我们就可以把视图代码,模型代码,路由代码等存储到蓝图目录下了,但是我们需要把蓝图注册到app应用对象下，想想以后，是不是会出现很多的蓝图？

所以我们能不能像django项目中的配置项INSTALLED_APPS里面填写完蓝图路径就可以自动注册蓝图？

可以的，我们也可以封装注册蓝图的功能到一个函数中，让项目自动识别并注册蓝图，并自动加载蓝图下的所有内容。

我们需要在配置文件中声明一个蓝图注册列表（例如：INSTALL_BLUEPRINT）, 在蓝图自动注册的函数中只注册列表中填写的蓝图。

`application/settings/__init__.py`，代码：

```python
from typing import List

"""蓝图注册"""
"""蓝图列表"""
INSTALL_BLUEPRINT: List = [

]
```

`application/settings/dev.py`,代码:

```python
"""蓝图列表"""
INSTALL_BLUEPRINT = [
    "application.apps.home",
]
```



#### 自动注册蓝图

在`application/utils/blueprint.py`模块中声明一个resgister_blueprint函数,函数中针对注册到项目配置文件中的INSTALL_BLUEPRINT蓝图列表选项的蓝图内容实现自动注册到app应用对象里面。

`application/utils/blueprint.py`,代码:

```python
from typing import List
from flask import Flask, Blueprint


def register_blueprint(app: Flask):
    """自动注册蓝图"""
    # 从配置文件中读取需要注册到项目中的蓝图路径信息
    blueprint_path_list: List = app.config.get("INSTALL_BLUEPRINT", [])

    # 遍历蓝图路径列表，对每一个蓝图进行初始化
    for blueprint_path in blueprint_path_list:
        # 获取蓝图路径中最后一段的包名作为蓝图的名称
        blueprint_name: str = blueprint_path.split(".")[-1]
        # 创建蓝图对象
        blueprint: Blueprint = Blueprint(blueprint_name, blueprint_path)
        # 把蓝图对象注册到app实例对象
        # todo url_prefix 是地址前缀，将来我们将来实现一个总路由来声明它
        app.register_blueprint(blueprint, url_prefix="")
```



项目入口文件`application.__init__`中, 调用`register_blueprint`方法, 自动注册蓝图.`application/__init__.py`,代码:

```python
# 先写 import.. 后写 from .. import ...
# 先解析器内置，后框架官方，然后第三方模块，接着是自己封装的本地模块。

from pathlib import Path

from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_redis import FlaskRedis
from flask_pymongo import PyMongo

from application.utils.config import init_config
from application.utils.logger import Log
from application.utils.commands import Command
from application.utils.blueprint import register_blueprint

"""加载组件[单例模式]"""
# SQLAlchemy实例化
db: SQLAlchemy = SQLAlchemy()

# redis实例化
redis_cache: FlaskRedis = FlaskRedis(config_prefix="REDIS")
redis_check: FlaskRedis = FlaskRedis(config_prefix="CHECK")

# mongoDB实例化
mongo: PyMongo = PyMongo()

# 日志实例化
logger:Log = Log()

# 终端命令管理类实例化
command: Command = Command()


def init_app(config_path: str) -> Flask:
    """用于创建app实例对象并完成初始化过程的工厂函数"""

    app: Flask = Flask(__name__)

    # 项目根目录
    app.BASE_DIR = Path(__file__).resolve().parent.parent

    # 初始化项目配置
    init_config(app=app, config_path=config_path)

    # SQLAlchemy加载配置
    db.init_app(app)

    # redis加载配置
    redis_cache.init_app(app)
    redis_check.init_app(app)

    # pymongo加载配置
    mongo.init_app(app)

    # 日志加载配置
    logger.init_app(app)

    # 终端命令管理类加载配置
    command.init_app(app)

    # 注册蓝图
    register_blueprint(app)

    return app

```

注册了蓝图对象以后,蓝图下面的视图方法和视图对应的路由关系也要进行注册!

#### 注册蓝图的路由和视图

在蓝图home下面的urls.py文件中,通过path方法把url地址和视图方法、http请求、处理成字典，然后把字典作为成员添加到路由列表的固定变量urlpatterns列表中.

`application/utils/blueprint.py`,声明path函数,代码：

```python
from typing import List, Callable
from flask import Flask, Blueprint
from importlib import import_module  # 可以根据字符串路径完成导报操作


def register_blueprint(app: Flask):
    """自动注册蓝图的工具函数"""
    # 从配置文件中读取需要注册到项目中的蓝图路径信息
    blueprint_path_list: List = app.config.get("INSTALL_BLUEPRINT", [])

    # 遍历蓝图路径列表，对每一个蓝图进行初始化
    for blueprint_path in blueprint_path_list:
        # 获取蓝图路径中最后一段的包名作为蓝图的名称
        blueprint_name: str = blueprint_path.split(".")[-1]
        # 创建蓝图对象
        blueprint: Blueprint = Blueprint(blueprint_name, blueprint_path)

        # 导入子路由关系，blueprint_url_path就是当前蓝图下的urls模块的导包路径
        blueprint_url_path: str = blueprint_path + ".urls"
        urls_module = import_module(blueprint_url_path)
        # 获取urls模块下路由列表urlpatterns
        urlpatterns = urls_module.urlpatterns
        # 在循环中，把urlpatterns的每一个路由信息添加注册到蓝图对象里面
        for url in urlpatterns:
            blueprint.add_url_rule(**url)
        # 把蓝图对象注册到app实例对象
        # todo url_prefix 是地址前缀，将来我们将来实现一个总路由来声明它
        app.register_blueprint(blueprint, url_prefix="")


def path(rule: str, view_func: Callable,**kwargs):
    """绑定url地址和视图的映射关系"""
    return {"rule": rule, "view_func": view_func, **kwargs}
```

在`application.__init__`入口文件中，导入path路由映射函数，将来方便再其他地方调用该函数，`application.__init__`，文件添加代码如下：

```python
from application.utils.blueprint import register_blueprint, path
```

在home蓝图下的urls.py中,使用path函数绑定视图和路由的映射关系并添加urlpatterns中,`home.urls.py`,代码：

```python
from typing import List
from application import path
from . import views

urlpatterns: List = [
    # {"rule": "/home", "view_func": views.index, "methods": ["GET"]},
    path("/test", views.test, methods=["GET"]),
    path("/test", views.test, methods=["POST"]),
    path("/index", views.index),
]
```

为了方便测试，先到当前home蓝图下视图文件views.py中，添加测试的视图，代码：

```python
def test():
    return "home.test"

def index():
    return "home.index"
```



完成上面步骤，将来即便有新的蓝图也可以参考上面的写法，把当前蓝图中所有的路由全部集中在urlpatterns中，接着下来我们就可以在`application.utils.blueprint.register_blueprint`蓝图注册函数中, 生成蓝图对象以后添加自动加载并注册蓝图的路由和视图了。

此时,运行项目，就可以通过url地址访问蓝图下的视图方法了。

```bash
GET http://192.168.233.129:5000/index

POST http://192.168.233.129:5000/test
```

提交代码版本

```bash
git add .
git commit -m "fix: auto register blueprint"
git push
```

