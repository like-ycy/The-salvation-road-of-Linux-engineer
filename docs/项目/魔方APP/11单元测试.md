# 单元测试

## 测试用例

类似vue中的axios可以用于发起http网络请求，python中也有对应的模块可以使用与axios一样的操作，甚至更强大。

python中用于发起http请求的模块：urllib、requests(简单爬虫操作、最常用)、aiohttp（异步）

安装requests，代码：

```python
pip install requests -i https://pypi.douban.com/simple
```

python内置了一个简单易用的测试模块unittest给我们，用于进行代码测试和断言assert。那么要使用unittest，那么久需要先进行初始化。

`application.utils.unittest`，代码：

```python
import unittest, json, requests, time, datetime, uuid
from typing import Dict, Any
from requests import Response
from application.settings import test


class BaseTestCase(unittest.TestCase):
    """测试基类"""
    # 接口网关地址
    BASE_URL: str = test.TEST_SERVER

    def get_url(self, url=None):
        if url is None:
            return self.BASE_URL
        return url

    def post(self, url=None, data: Dict[str, Any] = None) -> Response:
        content = {
            "jsonrpc": "2.0",
            "id": uuid.uuid4().__str__(),
            "method": "",
            "params": {}
        }
        content.update(data)
        ret: Response = requests.post(self.get_url(url), json=content)
        # 发送put请求：requests.put(self.get_url(url), data=data)
        # 发送patch请求：requests.patch(self.get_url(url), data=data)
        # 发送get请求：requests.get(self.get_url(url))
        # 发送delete请求：requests.delete(self.get_url(url))
        # 如果要上传文件，则请求头中的enctype=multipart/form-data
        self.result: Response = ret
        return self

    def json(self) -> Dict[str, Any]:
        # 解析
        self.response = json.loads(self.result.content)
        return self

# 设计模式：链式模式
# btc = BaseTestCase()
# btc.post(data={"username":"1222"}).result
```

为了方便引入当前测试基类，所以在项目初始化模块中导包引入，`application/__init__.py`，代码：

```python
from application.utils.unittest import BaseTestCase
```



自定义终端命令，启动单元测试。`application.utils.commands`，代码：

```python
import click, os, unittest
from typing import Optional
from flask import Flask, current_app

class Command(object):
    """命令管理类"""
    def __init__(self, app: Optional[Flask] = None):
        if app is not None:
            self.init_app(app)

    def init_app(self, app: Flask):
        self.app: Flask = app
        self.setup()

    def setup(self):
        """初始化终端命令"""
        self.blueprint()  # 自动创建蓝图目录和文件
        self.faker()  # 自动创建蓝图目录和文件
        self.unittest()  # 启动单元测试

    def blueprint(self):
        """蓝图生成命令"""
        # ....

    def faker(self):
        """自定义终端命令: 创建测试用户"""
        # ....

    def unittest(self):
        """启动单元测试"""
        @self.app.cli.command("test")  # 指定终端命令的调用名称
        def create_blueprint():
            for test_path in self.app.config["INSTALL_BLUEPRINT"]:
                tests = unittest.TestLoader().discover(test_path)  # 自动找到目录下的test.py测试文件并导入
                # 让unittest自动查找test.py模块中所有测试函数/测试方法
                unittest.TextTestRunner(verbosity=2).run(tests)
```

在蓝图目录下创建users/test.py，编写用例。代码：

```python
from application import BaseTestCase


# 一个接口的代码就是一个测试类/测试集
class CheckMobile(BaseTestCase):
    # 方法名必须以test_开头，否则单元测试无法发现并运行该测试代码
    def test_check_mobile_pass(self):
        """测试：当要注册的手机号在数据库中不存在时，是否通过验证"""
        data = {
            "method": "Users.mobile",
            "params": {"mobile": "13315345600"}
        }
        self.post(data=data).json()
        # assert 断言，相当于判断，但是断言在没有启动单元测试的时候，斌不会被系统执行，也就不会占用系统资源
        # 期望：result字段在self.response中存在，存在则期望成立，测试通过，不存在，期望失败，则测试不通过
        self.assertIn("result", self.response, msg=self.response)
        self.assertIn("errmsg", self.response["result"])  # 提示
        # self.assertEqual(0, self.response["result"]["errno"])
        # 期望：0 与 self.response["result"]["errno"] 相等， 如果相等，则期望成立，测试通过，如果不相等，则期望失败，则测试不通过
        self.assertEqual(0, self.response["result"]["errno"], msg=self.response["result"]["errmsg"])  # 状态码

    def test_check_mobile_no_pass(self):
        """测试：当要注册的手机号在数据库中存在时，是否通过验证"""
        data = {
            "method": "Users.mobile",
            "params": {"mobile": "13928835902"}
        }
        self.post(data=data).json()
        self.assertIn("result", self.response)
        self.assertEqual("手机号已经被注册！", self.response["result"]["errmsg"])
        self.assertEqual(1001, self.response["result"]["errno"])

    def test_check_mobile_by_empty_mobile(self):
        """测试：当要注册的手机号不填写时，是否通过验证"""
        data = {
            "method": "Users.mobile",
            "params": {"mobile":""}
        }
        self.post(data=data).json()
        self.assertIn("result", self.response, msg=self.response)
        self.assertEqual("手机号格式有误！", self.response["result"]["errmsg"])
        self.assertEqual(1001, self.response["result"]["errno"])


class UserAPI(BaseTestCase):
    """用户相关的API接口测试集"""
    def test_create_token_to_login_by_username(self):
        """测试：测试使用正确的用户名和密码，是否通过验证"""
        data = {
            "method": "Users.login",
            "params": {"account":"GQSwoerA", "password": "123456"}
        }
        self.post(data=data).json()
        self.assertIn("result", self.response)
        self.assertIn("access_token", self.response["result"])
        self.assertEqual(0, self.response["result"]["errno"])

    def test_create_token_to_login_by_mobile(self):
        """测试：测试使用正确的手机号和密码，是否通过验证"""
        data = {
            "method": "Users.login",
            "params": {"account": "13928835905", "password": "123456"}
        }
        self.post(data=data).json()
        self.assertIn("result", self.response)
        self.assertIn("access_token", self.response["result"])
        self.assertEqual(0, self.response["result"]["errno"])

    def test_create_token_to_login_by_error_username(self):
        """测试：测试使用错误的用户名和密码，是否通过验证"""
        data = {
            "method": "Users.login",
            "params": {"account":"xiaoming", "password": "123456"}
        }
        self.post(data=data).json()
        self.assertIn("result", self.response)
        self.assertNotIn("access_token", self.response["result"])
        self.assertEqual(1001, self.response["result"]["errno"])

    def test_create_token_to_login_by_error_mobile(self):
        """测试：测试使用错误的手机号和密码，是否通过验证"""
        data = {
            "method": "Users.login",
            "params": {"account":"15539559393", "password": "123456"}
        }
        self.post(data=data).json()
        self.assertIn("result", self.response)
        self.assertNotIn("access_token", self.response["result"])
        self.assertEqual(1001, self.response["result"]["errno"])

    def test_create_token_to_login_by_error_password(self):
        """测试：测试使用手机号和错误的密码，是否通过验证"""
        data = {
            "method": "Users.login",
            "params": {"account":"13928835905", "password": "1235050230202020320302"}
        }
        self.post(data=data).json()
        self.assertIn("result", self.response)
        self.assertNotIn("access_token", self.response["result"])
        self.assertEqual(1001, self.response["result"]["errno"])
```

OK，接下来我们就可以在终端下，测试当前用例是否能成功调试api接口。

command.sh，代码：

```bash
#!/usr/bin/env bash
export FLASK_APP="/home/moluo/Desktop/mofangapi/manage.py"
# 生产模式/运营模式
# export FLASK_ENV=product
# 开发模式
export FLASK_ENV=development

# shell编程的循环
#for (( i = 0; i < 100; i++ )); do
#    echo $i
#done

if [ $1 ]; then
  if [ $1 == "run" ]; then
    flask run --host=0.0.0.0 --port=5000

  elif [ $1 == "blue" ]; then
    cd application/apps
    flask $1 --name=$2

  elif [ $1 == "celery" ]; then
    celery -A manage.celery worker -l info

  elif [ $1 == "beat" ]; then
    celery -A manage.celery beat -l info

  # 生成测试用户
  elif [ $1 == 'user' ]; then
    flask $1 --num=$2 --password=$3

  # 运行单元测试
  elif [ $1 == "test" ]; then
    flask test

  else
    flask $1
  fi

fi
```

运行单元测试，终端执行：

```bash
./command.sh test
```

因为在测试过程中，存在类似滑动验证码这样的逻辑，所以我们可以采用另一个配置文件，区分不同的环境。

settings/test.py，代码：

```python
from typing import List
"""本地配置"""


"""调试模式"""
DEBUG: bool = True

"""是否处于测试环境下"""
TESTING: bool = True
TEST_SERVER = "http://127.0.0.1:5000/api"


"""本地化国际化"""
# 语言
LANGUAGE: str = "zh_CN"


"""数据库配置"""
# 数据库连接
SQLALCHEMY_DATABASE_URI: str = "mysql://mofanguser:mofang@127.0.0.1:3306/mofang?charset=utf8mb4"

# 查询时会显示原始SQL语句
SQLALCHEMY_ECHO: bool = True


"""redis配置"""
# 默认缓存数据
REDIS_URL: str = "redis://:@127.0.0.1:6379/0"
# 验证相关缓存
CHECK_URL: str  = "redis://:@127.0.0.1:6379/1"

"""mongoDB配置"""
MONGO_URI: str = "mongodb://mofang:mofang@127.0.0.1:27017/mofang"


"""日志配置"""
LOG_FILE: str = "logs/mofang.log"
LOG_LEVEL: str = "DEBUG"
LOG_BACKPU_COUNT: int = 31
LOG_FORMAT: str = '%(asctime)s - %(levelname)s - %(filename)s - %(funcName)s - %(lineno)s - %(message)s'


"""蓝图列表"""
INSTALL_BLUEPRINT: List = [
    "application.apps.home",
    "application.apps.users",
]

"""短信相关配置"""
SMS_ACCOUNT_ID: str = "8a216da863f8e6c20164139687e80c1b"  # 接口主账号
SMS_ACCOUNT_TOKEN: str = "6dd01b2b60104b3dbc88b2b74158bac6"  # 认证token令牌
SMS_APP_ID: str = "8a216da863f8e6c20164139688400c21"  # 应用ID
SMS_TEMPLATE_ID: int = 1  # 短信模板ID
SMS_EXPIRE_TIME: int = 60 * 5  # 短信有效时间，单位:秒/s
SMS_INTERVAL_TIME: int = 60  # 短信发送冷却时间，单位:秒/s


"""Celery配置"""
# 某些情况下可以防止死锁
CELERY_FORCE_EXECV = True
# 设置并发的worker数量
CELERYD_CONCURRENCY = 20
# 设置失败允许重试
CELERY_ACKS_LATE = True
# 每个worker最多执行500个任务被销毁，可以防止内存泄漏
CELERYD_MAX_TASKS_PER_CHILD = 500
# 单个任务的最大运行时间，超时会被杀死【注意：如果异步任务中有IO操作则建议不要设置这个数字太小，或者建议不要设置了】
CELERYD_TIME_LIMIT = 10 * 60
# 任务发出后，经过一段时间还未收到acknowledge , 就将任务重新交给其他worker执行
CELERY_DISABLE_RATE_LIMITS = True
# celery的任务结果内容格式
CELERY_ACCEPT_CONTENT = ['json', 'pickle']
# celery的任务队列地址
BROKER_URL = "redis://127.0.0.1:6379/15"
# celery的结果队列地址
CELERY_RESULT_BACKEND = "redis://127.0.0.1:6379/14"

# celery的定时任务调度器配置
BEAT_SCHEDULE = {
    # "test": {
    #     "task": "get_sendback",
    #     "schedule": 10,
    # }
}


"""jwt 相关配置"""
# 加密算法,默认: HS256
JWT_ALGORITHM = "HS256"
# 秘钥，默认是flask配置中的SECRET_KEY
JWT_SECRET_KEY = "y58Rsqzmts6VCBRHes1Sf2DHdGJaGqPMi6GYpBS4CKyCdi42KLSs9TQVTauZMLMw"
# token令牌有效期，单位: 秒/s，默认:　datetime.timedelta(minutes=15) 或者 15 * 60
JWT_ACCESS_TOKEN_EXPIRES = 60 * 30
# refresh刷新令牌有效期，单位: 秒/s，默认：datetime.timedelta(days=30) 或者 30*24*60*60
JWT_REFRESH_TOKEN_EXPIRES = 30 * 24 * 60 * 60
# 设置通过哪种方式传递jwt，默认是http请求头，也可以是query_string，json，cookies
JWT_TOKEN_LOCATION = ["headers", "json", "query_string"]
# 当通过http请求头传递jwt时，请求头参数名称设置，默认值： Authorization
JWT_HEADER_NAME = "Authorization"
# 当通过http请求头传递jwt时，令牌的前缀。
# 默认值为 "Bearer"，例如：Authorization: Bearer <JWT>
JWT_HEADER_TYPE = "jwt"
# 当通过json请求体传递jwt时，access_token令牌参数名称
JWT_JSON_KEY = "access_token"
# 当通过json请求体传递jwt时，refresh_token令牌参数名称
JWT_REFRESH_JSON_KEY = "refresh_token"
# 当通过查询字符串query_string传递jwt时，地址栏的参数名称设置，默认值： Authorization
JWT_QUERY_STRING_NAME = "token"
# 当通过查询字符串query_string传递jwt时，令牌的前缀。
# 默认值为 "Bearer"，例如：Authorization: Bearer <JWT>
JWT_QUERY_STRING_VALUE_PREFIX = "jwt "


"""防水墙验证码"""
CAPTCHA_GATEWAY="https://ssl.captcha.qq.com/ticket/verify"
CAPTCHA_APP_ID="2071340228"
CAPTCHA_APP_SECRET_KEY="0v714N6pMtV587ymedaJM2w**"


"""静态文件存储目录"""
# 头像存储路径
AVATAR_DIR = "application/static/avatar"
AVATAR_URL = "static/avatar"


"""阿里云"""
ALI_ACCESS_KEY_ID = "LTAI4GAzC4MdRXVQBECjmckc"  # 访问key
ALI_ACCESS_KEY_SECRET = "0nxNLJ8W7M3ZheIwZhaeImVoJZWG9D"  # 访问秘钥

# OSS对象存储
OSS_ENDPOINT = "oss-cn-beijing.aliyuncs.com"  # 存储节点
OSS_BUCKET_NAME = "mofangp36" # 存储空间
OSS_BUCKET_URL = "https://mofangp36.oss-cn-beijing.aliyuncs.com"

```

settings/dev.py 和 settings/pro.py，中新增配置项，代码：

```python
"""是否处于测试环境下"""
TESTING: bool = True
TEST_SERVER = "http://127.0.0.1:5000/api"
```



调整在用户登录验证中的滑动验证码的验证代码，在测试环境下不要判断了。users/serializers.py，代码：

```python
import os
from typing import List, Dict, Optional
from flask import request
from flask_marshmallow.sqla import SQLAlchemyAutoSchema, auto_field
from marshmallow import Schema, fields, validate, validates, ValidationError, decorators
from sqlalchemy.orm import scoped_session
from sqlalchemy import or_

from application import message, db, redis_check as redis
from application.utils.captcha import check_captcha, CaptchaParamsError, CaptchaNetWorkError, CaptchaFailError
from .models import User
from flask import current_app

class MobileSchema(Schema):
    """手机号验证"""
    mobile: fields.String = fields.String(required=True, validate=validate.Regexp(
        regex=r"^1[3-9]\d{9}$",
        error=message.mobile_format_error
    ))

    @validates("mobile")
    def validates_mobile(self, mobile: str) -> str:
        # 验证手机是否已经被注册
        user: User = User.query.filter(User.mobile == mobile).first()
        if user:
            raise ValidationError(message=message.mobile_is_used, field_name="mobile")

        return mobile


class UserSchema(SQLAlchemyAutoSchema):
    """用户注册信息验证"""
    mobile: fields.String = auto_field(required=True, load_only=True, validates=validate.Regexp(
        regex="^1[3-9]\d{9}$",
        error=message.mobile_format_error
    ))
    password: fields.String = fields.String(required=True, load_only=True, validate=validate.Length(
        min=6,
        max=16,
        error=message.password_format_error
    ))
    password2: fields.String = fields.String(required=True, load_only=True)
    sms_code: fields.String = fields.String(required=True, load_only=True, validate=validate.Length(
        min=4,
        max=4,
        error=message.sms_code_format_error
    ))

    class Meta:
        model: User = User
        include_fk: bool = True  # 启用外键关系
        include_relationships: bool = True  # 模型关系外部属性
        fields: List[str] = ["id", "name", "mobile", "password", "password2",
                             "sms_code"]  # 如果要全换全部字段，就不要声明fields或exclude字段即可
        sqla_session: scoped_session = db.session

    @decorators.validates_schema
    def validate(self, data, **kwargs) -> Dict[str, str]:
        # 校验密码和确认密码
        if data["password"] != data["password2"]:
            raise ValidationError(message=message.password_not_match, field_name="password")

        # 校验短信验证码
        # 1. 从redis中提取验证码
        redis_sms_code: Optional[bytes] = redis.get("sms_%s" % data["mobile"])
        if redis_sms_code is None:
            raise ValidationError(message=message.sms_code_expired, field_name="sms_code")
        redis_sms_code: str = redis_sms_code.decode()

        # 2. 从客户端提交的数据data中提取验证码
        sms_code: str = data["sms_code"]

        # 3. 删除redis中的验证码[减少暴力破解的风险]
        redis.delete("sms_%s" % data["mobile"])

        # 4. 字符串比较，如果失败，则抛出异常，否则，直接删除验证码
        if sms_code != redis_sms_code:
            raise ValidationError(message=message.sms_code_not_match, field_name="sms_code")

        data.pop("password2")
        data.pop("sms_code")
        return data

    @decorators.post_load
    def save_object(self, data, **kwargs) -> User:
        data["name"] = data["mobile"]
        user: User = User(**data)
        self.session.add(user)
        self.session.commit()
        return user


class UserLoginSchema(SQLAlchemyAutoSchema):
    """用户登录的构造器"""
    account = fields.String(required=True, load_only=True)
    password = fields.String(required=True, load_only=True)
    money = fields.Float(dump_only=True)
    credit = fields.Float(dump_only=True)
    ticket = fields.String(required=False, load_only=True)
    randstr = fields.String(required=False, load_only=True)

    class Meta:
        model = User
        # 如果要转换模型的全部字段，就不要声明fields或exclude字段即可
        fields = ["id", "nickname", "account", "password", "money","credit", "avatar","province","city","area", "ticket", "randstr"]
        sqla_session = db.session

    @decorators.validates_schema
    def valivate(self, data, **kwargs):

        if not current_app.config["TESTING"]:
            # 非测试环境下，需要校验滑动验证码
            if data["ticket"] == "" or data["randstr"] == "":
                raise ValidationError(field_name="verify", message="滑动验证码的参数ticket或randstr不能为空！")

            # 校验验证码
            try:
                check_captcha(data["ticket"], data["randstr"], request.remote_addr)
            except CaptchaParamsError:
                raise ValidationError(message=message.varity_params_error, field_name="ticket")
            except CaptchaNetWorkError:
                raise ValidationError(message=message.varity_network_error, field_name="ticket")
            except CaptchaFailError:
                raise ValidationError(message=message.varity_code_error, field_name="ticket")

    # 钩子，验证成功以后，自动调用
    @decorators.post_load
    def save_object(self, data, **kwargs):
        account = data.get("account")
        password = data.get("password")
        user = User.query.filter(
            or_(
                User.mobile == account,
                User.name == account,
                User.email == account
            )
        ).first()  # 实例化模型

        if not user:
            raise ValidationError(message=message.user_not_exists, field_name="username")

        if not user.check_password(password):
            raise ValidationError(message=message.password_not_match, field_name="password")

        return user

```

message.py，代码：

```python
password_not_match: str = "密码错误！"
```



效果：

![image-20211115175428786](11%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.assets/image-20211115175428786.png)

showdoc版本的api接口文档：

```markdown
##### 简要描述

- 手机号验证

##### 请求URL
- ` http://192.168.241.130:5000/api `
  
##### 请求方式
- POST 

##### 参数

|参数名|必选|类型|说明|
|:----    |:---|:----- |-----   |
|jsonrpc |是  |string |协议版本   |
|id |是  |string | 请求唯一标记    |
|method     |否  |string | 接口方法名    |
|params{}     |否  | dict | 参数    |
##### params子参数
|参数名|必选|类型|说明|
|:----    |:---|:----- |-----   |
|mobile |是  | string | 手机号   |

##### 请求示例
​``` 
{
	"jsonrpc":"2.0",
	"id": 100,
	"method":"Users.mobile",
	"params":{"mobile":"13312345678"}
}
​``` 
##### 响应示例 
###### 成功
​``` 
{
    "id": 100,
    "jsonrpc": "2.0",
    "result": "ok"
}
​```
###### 失败
+ 手机被注册
​``` 
{
    "id": 100,
    "jsonrpc": "2.0",
    "result": {
        "errmsg": "对不起，当前手机已经被注册！",
        "errno": 1001
    }
}
​``` 
+ 格式错误
​```
{
    "id": 100,
    "jsonrpc": "2.0",
    "result": {
        "errmsg": "手机号码格式有误！",
        "errno": 1001
    }
}
​```

##### 返回参数说明 

|参数名|类型|说明|
|:-----  |:-----|-----                           |
|id |string   |请求唯一标记，由客户端请求接口时提供  |
|jsonrpc |string   |协议版本  |
|result{} |dict   |响应结果  |

###### result子参数

|参数名|类型|说明|
|:-----  |:-----|-----                           |
|errmsg | string   | 提示信息 |
|errno |int   | 提示码 |

##### 备注 

- 更多返回错误代码请看首页的错误代码描述
```

查看效果：https://www.showdoc.com.cn/1273450632156303?page_id=6390777619276289

访问密码：123456

 也可以基于swagger，编写测试文档，文档地址：https://editor.swagger.io/



### 单元测试的优点和缺点

```
优点：
	1. 便于操作、便于保存、便于分享、测试范围广和测试过程简单
	2. 测试过程中实现了自动化，不需要手动操作。
	3. 测试过程中完全可以基于日志记录下来，方便将来进行溯源和排查
	4. 可以轻松的测试到接口使用过程中各种边界

缺点：
    1. 测试目标发生改动，例如测试接口的参数或者返回值发生变化，则测试代码也没有每次跟着变化
    2. 需要考虑各种的测试边界，所以不同技术程度的测试人员编写的测试用户的可靠度高度不一样。
```

