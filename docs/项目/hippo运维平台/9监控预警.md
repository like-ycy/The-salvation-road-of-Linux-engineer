

## 计划任务

效果：

![image-20210312194844276](9%E7%9B%91%E6%8E%A7%E9%A2%84%E8%AD%A6.assets/image-20210312194844276.png)



创建应用

```python
cd hippo_api/apps/
python ../../manage.py startapp schedule
```



配置应用，settings.dev，代码：

```python
INSTALLED_APPS = [
    ...
    'schedule',
		...
]
```

在应用中创建urls.py文件，`schedule.urls`，代码：

```python
from django.urls import path,re_path
from . import views

urlpatterns = [
    
]
```

总路由，`hippo_api.urls`，代码：

```python
    path('schedule/', include('schedule.urls')),
```

创建模型类,保存任务计划

```python
from django.db import models
from host.models import Host
# Create your models here.

# 任务记录表
class TaskSchedule(models.Model):
    period_way_choices = (
        ('1', '普通周期'),
        ('2', '一次性任务'),
        ('3', 'cron任务'),
    )
    status_choices = (
        ('1', '激活'),
        ('2', '停止'),
        ('3', '报错'),

    )
		
    period_beat = models.IntegerField(verbose_name='django-celery-beat任务id', help_text='方便我们通过这个id值来控制celery的任务状态', null=True,blank=True)
    task_name = models.CharField(max_length=32, unique=True, verbose_name='任务名称')
    task_cmd = models.TextField(verbose_name='任务指令')
    #是否通知
    #通知方式
    #通知内容
    period_way = models.CharField(max_length=32,choices=period_way_choices, default='1', verbose_name='任务周期方式')
    period_content = models.CharField(max_length=32,verbose_name='周期计划')  #10秒、*****cron方式，datetime时间等
    period_status = models.CharField(max_length=32,default='1', choices=status_choices)

# 任务和主机的关系表
class TaskHost(models.Model):
    tasks = models.ForeignKey('TaskSchedule',on_delete=models.CASCADE,verbose_name='执行的任务')
    hosts = models.ForeignKey(Host,on_delete=models.CASCADE,verbose_name='任务执行主机')

```

![1629604514147](9%E7%9B%91%E6%8E%A7%E9%A2%84%E8%AD%A6.assets/1629604514147.png)

### celery定时计划

安装依赖库

```python
pip install celery==4.4.7
pip install django-celery-beat==2.0.0  
pip install django-celery-results
pip install django-redis==3.5.2
```



项目配置文件中配置django-celery-beat，`stttings.dev`，代码：

```python
INSTALLED_APPS = [
    'django.contrib.admin',
    ...
    'app01',
    'django_celery_beat',
]

LANGUAGE_CODE = 'zh-hans'  # 使用中国语言
TIME_ZONE = 'Asia/Shanghai'  # 设置Django使用中国上海时间
# 如果USE_TZ设置为True时，Django会使用系统默认设置的时区，此时的TIME_ZONE不管有没有设置都不起作用
# 如果USE_TZ 设置为False,TIME_ZONE = 'Asia/Shanghai', 则使用上海的UTC时间。
USE_TZ = False  # 如果用的sqlit数据库，那么改为True，sqlit数据库不支持
```

我们当前celery要使用redis作为消息队列，所以要记得查看下，redis是否正常启动了。

OK，安装完成相关的模块以后，我们接下来要使用celery。

首先，需要在hippo_api服务端项目根目录下创建一个保存celery代码的包目录celery_tasks。

在celery_tasks包目录下创建几个python文件，用于对celery进行初始化配置。

main.py(celery初始化) 、config.py(配置文件) 、  tasks.py(任务文件，文件名必须叫tasks.py)

main.py

```python
import os
from celery import Celery
from . import config


# 为celery设置django相关的环境变量，方便将来在celery中调用django的代码
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'hippo_api.settings.dev')
# 创建celery实例对象[可以以项目名作为名称，或者以项目根目录名也可以]
app = Celery('hippo_api')
# 从配置文件中加载celery的相关配置
app.config_from_object(config)

# 设置app自动加载任务
app.autodiscover_tasks([
    'celery_tasks', # celery会自动得根据列表中对应的目录下的tasks.py 进行搜索注册
])
```

config.py

```python
import os
# 为celery设置django相关的环境变量，方便将来在celery中调用django的代码
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'hippo_api.settings.dev')
from django.conf import settings
# 设置celery接受任务的队列
broker_url = 'redis://127.0.0.1:6379/14'
# 设置celery保存任务执行结果的队列
result_backend = 'redis://127.0.0.1:6379/15'
# celery 的启动工作数量设置[进程数量]
CELERY_WORKER_CONCURRENCY = 20
# 任务预取功能，就是每个工作的进程／线程在获取任务的时候，会尽量多拿 n 个，以保证获取的通讯成本可以压缩。
WORKER_PREFETCH_MULTIPLIER = 20
# 非常重要,有些情况下可以防止死锁
CELERYD_FORCE_EXECV = True
# celery 的 worker 执行多少个任务后进行重启操作
CELERY_WORKER_MAX_TASKS_PER_CHILD = 100
# 禁用所有速度限制，如果网络资源有限，不建议开足马力。
worker_disable_rate_limits = True

# celery beat配置
CELERY_ENABLE_UTC = False
settings.USE_TZ = True
timezone = settings.TIME_ZONE
# 保存定时任务记录的驱动类，使用mysql数据库来进行定时任务
CELERY_BEAT_SCHEDULER = 'django_celery_beat.schedulers:DatabaseScheduler'
```

tasks.py

```python
from .main import app

# 经过@app.task装饰过，就会被celery识别为任务，否则就是普通的函数
@app.task
def task1(a, b, c):
    print("任务1函数正在执行....")
    return a + b + c

@app.task
def task2():
    print("任务2函数正在执行....")

```

上述配置做完之后，我们需要执行数据库迁移指令，去生成django_celery_beat应用的表

```python
cd ../..
python manage.py makemigrations
python manage.py migrate
```



完成了数据迁移以后，我们接下来就要启动celery和celery_beat，让celery正常工作起来。

```shell
# 命令必须在manage.py的父目录下执行
# 启动定时任务首先需要有一个work执行异步任务，然后再启动一个定时器触发任务。
celery -A celery_tasks.main worker -l info

# 启动定时器触发 beat  (注意：下面是一条完整指令)
celery -A celery_tasks.main beat -l info --scheduler  django_celery_beat.schedulers:DatabaseScheduler
```

接下来，我们还没有提供客户端的操作界面，所以我们要测试celery的定时任务，可以先在django的终端下进行测试。

普通周期任务

```python
# 进入django提供的shell终端，执行如下指令
python manage.py shell

from django_celery_beat.models import PeriodicTask, IntervalSchedule
# executes every 10 seconds.
# 从定时器数据表中获取一个10秒的计时器信息，如果没有则先创建一个再读取出来。
schedule, _ = IntervalSchedule.objects.get_or_create(
  		every=10,
  		period=IntervalSchedule.SECONDS, # 单位，下面有说明
)
"""
   # 可以看到上面固定间隔的时间是采用秒 period=IntervalSchedule.SECONDS，
   # 如果你还想要固定其他的时间单位，可以设置其他字段参数，如下：
   IntervalSchedule.DAYS 固定间隔天数
   IntervalSchedule.HOURS 固定间隔小时数
   IntervalSchedule.MINUTES 固定间隔分钟数
   IntervalSchedule.SECONDS 固定间隔秒数
   IntervalSchedule.MICROSECONDS 固定间隔微秒

   # 可以从源码中进行查看
   # from django_celery_beat.models import PeriodicTask, IntervalSchedule                                                                                                  
   # IntervalSchedule.PERIOD_CHOICES                                                                                                                                       
   # 能够看到单位选项：
   (
      ('days', 'Days'),
      ('hours', 'Hours'),
      ('minutes', 'Minutes'),
      ('seconds', 'Seconds'),
      ('microseconds', 'Microseconds')
   )
"""
# 执行定时任务，带参数的
import json
from datetime import datetime, timedelta
# 带参数的任务写法：
period_obj = PeriodicTask.objects.create(
     interval=schedule,                  # we created this above.
     name='task23',                       # 唯一的任务名称，名字不能重复
     task='celery_tasks.tasks.task1',    # 任务的导包路径
     args=json.dumps([5, 10, 15]),  # 异步任务有参数时，可以通过args或者kwargs来设置
     #kwargs=json.dumps({
     #   'be_careful': True,
     #}),
     expires=datetime.utcnow() + timedelta(seconds=30), # 任务的持续时间
)

# 不带参数的任务写法：
period_obj1 = PeriodicTask.objects.create(
     interval=schedule,                  # we created this above.
     name='task30',                       # 唯一的任务名称，名字不能重复
     task='celery_tasks.tasks.task2',    # 任务的导包路径
     expires=datetime.utcnow() + timedelta(seconds=30), # 任务的持续时间
)

# 可以查看所有计划任务
PeriodicTask.objects.all()
# 所有任务执行都是ok的，只要数据库改变了，那么beat任务会自动调用执行，因为celery一直处于轮询状态。

# 暂停执行两个周期性任务
task = PeriodicTask.objects.get(name="task1")
task.enabled = False # 把执行状态改成False，就可以暂停了。                       
task.save() 

# 把暂停的任务，重启激活。设置任务的 enabled 为 True 即可：
task = PeriodicTask.objects.get(name="task1")
task.enabled = True                                     
task.save()

# 删除任务
task = PeriodicTask.objects.get(name="task2")
task.delete()

# 注意：如果celery中的任务文件代码发生改变，例如tasks.py中的任务逻辑修改了，都需要重启beat和worker  
```



基于 crontab 的周期性任务

```python
import pytz  
# 创建周期
# https://docs.celeryproject.org/en/v4.4.7/userguide/periodic-tasks.html#crontab-schedules
from django_celery_beat.models import CrontabSchedule, PeriodicTask
schedule, _ = CrontabSchedule.objects.get_or_create( 
     minute='*', 
     hour='*', 
     day_of_week='*', 
     day_of_month='*', 
     month_of_year='*', 
     timezone=pytz.timezone('Asia/Shanghai') 
)

# 查看crontab数据表的中所有crontab定时器
CrontabSchedule.objects.all()  


# 执行周期任务
PeriodicTask.objects.create(  
     crontab=schedule, # 上面创建的 crontab 对象 * * * * *，表示每分钟执行一次
     name='my_task2_crontab', # 设置任务的name值，还是一样，name必须唯一
     task='celery_tasks.tasks.task2',  # 指定需要周期性执行的任务，任务也可以通过args或kwargs添加参数
)

# 返回值
# <PeriodicTask: my_task2_crontab: * * * * * (m/h/d/dM/MY) Asia/Shanghai>
```





后端编写计划任务的异步任务注册celery中。

celery_tasks/tasks.py

```python
from .main import app

# 经过@app.task装饰过，就会被celery识别为任务，否则就是普通的函数
@app.task
def task1(a, b, c):
    print("任务1函数正在执行....")
    return a + b + c

"""
import json
from datetime import datetime, timedelta
period_obj = PeriodicTask.objects.create(
     interval=schedule,                  # we created this above.
     name='task23',                       # 唯一的任务名称，名字不能重复
     task='celery_tasks.tasks.task1',    # 任务的导包路径
     args=json.dumps([5, 10, 15]),  # 异步任务有参数时，可以通过args或者kwargs来设置
     #kwargs=json.dumps({
     #   'be_careful': True,
     #}),
     expires=datetime.utcnow() + timedelta(seconds=30), # 任务的持续时间
)
"""

@app.task
def task2():
    print("任务2函数正在执行....")

"""
period_obj1 = PeriodicTask.objects.create(
     interval=schedule,                  # we created this above.
     name='task30',                       # 唯一的任务名称，名字不能重复
     task='celery_tasks.tasks.task2',    # 任务的导包路径
     expires=datetime.utcnow() + timedelta(seconds=30), # 任务的持续时间
)
"""

# hippo计划任务
import json
from host.models import Host
from django.conf import settings
from hippo_api.utils.key import AppSetting
@app.task(name='schedule_task')
def schedule_task(cmd, hosts_ids):
    """计划任务"""
    hosts_objs = Host.objects.filter(id__in=hosts_ids)
    result_data = []
    private_key, public_key = AppSetting.get(settings.DEFAULT_KEY_NAME)
    for host_obj in hosts_objs:
        cli = host_obj.get_ssh(private_key)
        code, result = cli.exec_command(cmd)
        result_data.append({
            'host_id': host_obj.id,
            'host': host_obj.ip_addr,
            'status': code,
            'result': result
        })
        print('>>>>', code, result)

    return json.dumps(result_data)
```

Schedule/views.py

```python
import json
import random
from datetime import datetime, timedelta

from django_celery_beat.models import IntervalSchedule, PeriodicTask
from rest_framework.response import Response
from rest_framework.views import APIView
from .models import TaskSchedule, TaskHost


class PeriodView(APIView):
    # 获取计划任务的周期类型数据返回给客户端
    def get(self,request):
        data = TaskSchedule.period_way_choices
        return Response(data)


class TaskView(APIView):
    def get(self,request):
        # 1. 获取任务列表数据返回给客户端
        # 2. 去redis中获取每个任务的执行结果展示给客户端
        pass

    def post(self,request):
        task_data = request.data
        period_way = request.data.get('period_way') # 计划任务的周期类型
        hosts_ids = request.data.get('hosts')       # 计划任务的执行的远程主机列表
        task_cmd = request.data.get('task_cmd')     # 计划任务要执行的任务指令
        period_content = request.data.get('period_content') # 计划任务的周期的时间值
        task_name = request.data.get('task_name')   # 任务名称，注意不能重复
        try:
            PeriodicTask.objects.get(name=task_name)
            task_name = f"{task_name}-{str(random.randint(1000,9999))}"
        except:
            pass

        if period_way == '1':  # 普通周期任务,默认单位为秒数，可以选择修改
            schedule, created = IntervalSchedule.objects.get_or_create(
                every=int(period_content),
                period=IntervalSchedule.SECONDS,
            )
            period_obj = PeriodicTask.objects.create(
                interval=schedule,  # we created this above.
                name=task_name,  # simply describes this periodic task.
                task='schedule_task',  # name of task.
                # task='my_task2',  # name of task.
                args=json.dumps([task_cmd, hosts_ids]),
                expires=datetime.utcnow() + timedelta(seconds=30)
            )
            period_beat = period_obj.id
        elif period_way == '2':   # 一次性任务
            period_beat = 1
            pass
        else:  # cron任务
            period_beat = 1
            pass


        # 保存任务
        task_schedule_obj = TaskSchedule.objects.create(**{
            'period_beat':period_beat, # celery-beat的任务id值
            'period_way':period_way,
            'task_cmd':task_cmd,
            'period_content':period_content,
            'task_name':task_name,
            'period_status':'1' , # 默认为激活状态
        })

        for host_id in hosts_ids:

            TaskHost.objects.create(**{
                'tasks_id': task_schedule_obj.id,
                'hosts_id': host_id,
            })

        return Response({'errormsg': 'ok'})

```

schedule/urls.py

```python
from django.urls import path
from . import views

urlpatterns = [
    path('periods/', views.PeriodView.as_view()),
    path('tasks/', views.TaskView.as_view()),
]
```

前端实现

components/Schedule.vue，代码：

```html
<template>
  <div class="schedule">
    <h1>任务计划</h1>

    <a-form-model
      ref="ruleForm"
      :model="form"
      :rules="rules"
      :label-col="labelCol"
      :wrapper-col="wrapperCol"
    >
      <a-form-model-item ref="task_name" label="任务名称：" prop="task_name">
        <a-input
          v-model="form.task_name"
          @blur="
          () => {
            $refs.task_name.onFieldBlur();
          }
        "
        />
      </a-form-model-item>
      <a-form-model-item label="请选择主机：" prop="hosts">
        <a-select
          mode="multiple"
          :value="form.hosts"
          style="width: 100%"
          placeholder="请选择主机"
          @change="handleHostChange"
        >
          <a-select-option v-for="(host_value,host_index) in host_list" :key="host_index" :value="host_value.id">
           {{host_value.ip_addr}}--{{host_value.hostname}}
          </a-select-option>
        </a-select>


      </a-form-model-item>
      <a-form-model-item label="请选择周期方式：" prop="hosts">
        <a-select style="width: 120px" @change="handlePeriodChange">
          <a-select-option v-for="(period_value,period_index) in period_way_choices" :value="period_value[0]" :key="period_index">
            {{period_value[1]}}
          </a-select-option>

        </a-select>


      </a-form-model-item>

      <a-form-model-item ref="period_content" label="任务周期值：" prop="period_content">
        <a-input v-model="form.period_content" />
      </a-form-model-item>

      <a-form-model-item ref="period_content" label="任务指令：" prop="period_content">
        <editor v-model="form.task_cmd" @init="editorInit" lang="html" theme="chrome" width="500" height="300"></editor>
      </a-form-model-item>

      <a-form-model-item :wrapper-col="{ span: 14, offset: 4 }">
        <a-button type="primary" @click="onSubmit">
          添加任务
        </a-button>
        <a-button style="margin-left: 10px;" @click="resetForm">
          重置任务
        </a-button>
      </a-form-model-item>
    </a-form-model>
  </div>
</template>
<script>
  export default {
    name: 'Schedule',
    data() {
      return {
        labelCol: {span: 4},
        wrapperCol: {span: 14},
        other: '',
        // selectedItems:[], // 选择的主机id数据
        period_way_choices:[],  // 所有周期类型数据
        host_list:[], // 主机列表数据
        form: {
          task_name: '',
          hosts: [],
          period_way:'1',
          task_cmd:'',
          period_content:'',
        },
        rules: {
          task_name: [
            {required: true, message: '请输入任务名称', trigger: 'blur'},
          ],


        },
      };
    },
    components: {
      editor: require('vue2-ace-editor'),
    },
    created() {
      // 获取所有主机数据
      this.get_host_list();
      // 获取计划任务的周期类型选项数据
      this.get_period_data();
    },

    methods: {
      get_period_data(){
        this.$axios.get(`${this.$settings.host}/schedule/periods/`)
        .then((res)=>{
          this.period_way_choices = res.data;
          console.log(this.period_way_choices);
        }).catch((error)=>{
        })
      },

      get_host_list() {
        let token = sessionStorage.token || localStorage.token;
        this.$axios.get(`${this.$settings.host}/host/host/`,{
          headers:{
            Authorization: "jwt " + token
          }
        })
          .then((res) => {
            this.host_list = res.data;
          })

      },

      editorInit: function () {
        require('brace/ext/language_tools') //language extension prerequsite...
        require('brace/mode/html')
        require('brace/mode/javascript')    //language
        require('brace/mode/less')
        require('brace/theme/chrome')
        require('brace/snippets/javascript') //snippet
      },

      handlePeriodChange(value) {
        console.log(`selected ${value}`);
        this.form.period_way = value;
      },

      handleHostChange(value) {
        this.form.hosts = value;
        // console.log(typeof value);
        // console.log(value[1]);
        console.log(`selected hosts ${this.form.hosts}`);
      },

      onSubmit() {
        this.$refs.ruleForm.validate(valid => {
          if (valid) {
            console.log(this.form);
            this.$axios.post(`${this.$settings.host}/schedule/tasks/`,this.form)
            .then((res)=>{
              console.log(res.data);
            })

          } else {
            console.log('error submit!!');
            return false;
          }
        });
      },
      resetForm() {
        this.$refs.ruleForm.resetFields();
      },
    },
  };
</script>


<style scoped>

</style>
```



router/index.js

```js
// ..
import Schedule from '@/components/Schedule'

// ....
        {
          path: 'schedule',
          name: 'Schedule',
          component: Schedule,
        },
      ]
    },

  ]
})

```



## 监控和报警

基于echarts图表结合我们之前使用的websocket来完成。

效果：

![image-20210312194813533](9%E7%9B%91%E6%8E%A7%E9%A2%84%E8%AD%A6.assets/image-20210312194813533.png)

客户端，`Monitor.vue`，代码：

```vue
<template>
  <div class="monitor">
    <div ref="container" style="height: 300px;"></div>
  </div>
</template>

<script>
export default {
  name: "Monitor",
  data(){
    return {
      host: 2,
      cpu_echart: null,
      cpu_data: [],
    }
  },
  mounted(){
    this.init_cpu_echart();
    setInterval(()=>{
        this.get_cpu_data();
    }, 1000);
  },
  methods:{
    init_cpu_echart(){
      this.cpu_echart = this.$echarts.init(this.$refs.container);
      var option = {
          title: {
              text: 'CPU使用率'
          },
          tooltip: {
              trigger: 'axis',
              formatter: function (params) {
                  params = params[0];
                  return params.value[0] + ' : ' + params.value[1];
              },
              axisPointer: {
                  animation: true
              }
          },
          xAxis: {
              type: 'time',
              splitLine: {
                  show: true
              }
          },
          yAxis: {
              type: 'value',
              boundaryGap: [0, '100%'],
              splitLine: {
                  show: true
              }
          },
          series: [{
              name: '数据',
              type: 'line',
              showSymbol: true,
              hoverAnimation: true,
              data: this.cpu_data
          }]
      };

      if (option && typeof option === 'object') {
          this.cpu_echart.setOption(option);
      }
    },
    get_cpu_data(){
        this.$axios.get(`${this.$settings.host}/monitor/cpu/`,{
          params: {host: this.host},
        }).then((res)=>{
          let row = res.data;
          for (var i = 0; i < 5; i++) {
              this.cpu_data.shift();
              this.cpu_data.push(row);
          }
          this.cpu_echart.setOption({
              series: [{
                  data: this.cpu_data
              }]
          });
        }).catch((error)=>{

        })
    }
  }
}
</script>

<style scoped>

</style>

```

Base.vue中补充地址，代码：

```vue
{id: 7,icon:'mail', title: '监控', tube: '', 'menu_url': '/hippo/monitor', children: []},
```

路由，代码：

```javascript
import Monitor from '@/components/Monitor'

const router = new Router({
  mode: "history",
  routes: [
    //....
    {
      path: '/hippo',
      name: 'Base',
      component: Base,
      children: [
        // ....
        {
          path: 'monitor',
          name: 'Monitor',
          component: Monitor,
        },
      ]
    },

  ]
})


```



创建应用

```shell
cd hippo_api/apps
python ../../manage.py startapp monitor
```

settings.py配置应用

```python
INSTALLED_APPS = [
    ...
    'monitor',
]
```

总路由

```python
path('monitor/', include('monitor.urls')),
```



monitor/urls.py

```python
from django.urls import path,re_path
from . import views

urlpatterns = [
    path('data/', views.MonitorView.as_view()),
]
```

### 短信发送

使用容联云第三方进行短信发送

![1615705610571](9%E7%9B%91%E6%8E%A7%E9%A2%84%E8%AD%A6.assets/1615705610571.png)

在登录后的平台上面获取一下信息:[https://www.yuntongxun.com/]

```
ACCOUNT SID：8aaf07086f17620f016f308d0d2c0fa9
AUTH TOKEN : be8d96030fca44ffaf958062e6c658e8
AppID(默认)：8aaf07086f17620f016f308d0d850faf
```



https://www.yuntongxun.com/doc.html

![1615705656076](9%E7%9B%91%E6%8E%A7%E9%A2%84%E8%AD%A6.assets/1615705656076.png)

流程

http://doc.yuntongxun.com/space/5a5098313b8496dd00dcdd7f

![1615705685200](9%E7%9B%91%E6%8E%A7%E9%A2%84%E8%AD%A6.assets/1615705685200.png)



找到sdkdemo进行下载

![1615705698493](9%E7%9B%91%E6%8E%A7%E9%A2%84%E8%AD%A6.assets/1615705698493.png)



文档和sdk下载地址：https://doc.yuntongxun.com/p/5f029ae7a80948a1006e776e

安装短信的sdk，python模块

```bash
pip install ronglian_sms_sdk
pip install -U django-redis
```

视图代码：

```python
from django.shortcuts import render
from rest_framework.viewsets import ViewSet
from rest_framework.response import Response
from django.utils import timezone as datetime
from host.models import Host
from django.conf import settings
from hippo_api.utils.key import AppSetting
from ronglian_sms_sdk import SmsSDK
from django_redis import get_redis_connection

class MonitorViewSet(ViewSet):
    def cpu(self,request):
        # 根据当前host_id获取主机地址
        host_id = request.query_params.get("host")
        try:
            host = Host.objects.get(pk=host_id)
        except Host.DoesNotExist:
            return Response({"errmsg": "主机错误！"})

        private_key,_ = AppSetting.get(settings.DEFAULT_KEY_NAME)
        cli = host.get_ssh(private_key)
        code,result = cli.exec_command("iostat -c")
        if code == 0:
            value = result.split("\n")[-5].split()[0]
        else:
            print("远程无法查询！")
            return Response({"errmsg": "主机错误！"})

        now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        # 从数据库中查找出预警通知的管理员手机号，多个使用英文逗号拼接成字符串
        mobile = "13928835901"
        redis = get_redis_connection("monitor")
        if float(value)>90:
            """一级预警"""
            has_time = redis.ttl(f"1NF_{mobile}")
            if has_time < 0:
                self.sms("13928835901", host.ip_addr, value)
                redis.setex(f"1NF_{mobile}", settings.NF1, "90%")
        elif float(value)>75:
            """二级预警"""
            has_time = redis.ttl(f"2NF_{mobile}")
            if has_time < 0:
                self.sms("13928835901", host.ip_addr, value)
                redis.setex(f"2NF_{mobile}", settings.NF2, "75%")
        elif float(value)>65:
            """三级预警"""
            has_time = redis.ttl(f"3NF_{mobile}")
            if has_time < 0:
                self.sms("13928835901", host.ip_addr, value)
                redis.setex(f"3NF_{mobile}", settings.NF3, "65%")

        return Response({
            "name": now,
            "value": [now, float(value)]
        })

    def sms(self, mobile,host_ip, cpu_num):

        sdk = SmsSDK(settings.ACCID, settings.ACCTOKEN, settings.APPID)
        tid = settings.TEMID
        # 短信一定要基于redis实现冷却控制 expire设置一个键 控制手机号接受短信的间隔时间
        # 1NF_13928835901 90%   600
        # 2NF_13928835901 75%   3600
        # 3NF_13928835901 65%   18000

        datas = (host_ip, cpu_num)
        resp = sdk.sendMessage(tid, mobile, datas)
        print(resp)
        """
        from monitor.views import sms
        sms("13928835901")
        """

```

settings.dev，代码：

```python
# 短信发送配置
ACCID = '8a216da863f8e6c20164139687e80c1b'
ACCTOKEN = '6dd01b2b60104b3dbc88b2b74158bac6'
APPID = '8a216da863f8e6c20164139688400c21'
TEMID = 1


# 预警间隔时间
NF_1 = 600
NF_2 = 3600
NF_3 = 86400
```







































































































