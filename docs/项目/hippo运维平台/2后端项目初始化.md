## 后端项目初始化

### 虚拟环境

```shell
# 创建虚拟环境
conda create -n hippo python=3.8
# 进入虚拟环境
conda activate hippo
```

### 模块安装

```shell
conda install django
pip install djangorestframework -i https://pypi.douban.com/simple/
pip install cryptography
conda install PymySQL -c conda-forge
```

### 后端项目创建

```shell
cd ~/Desktop
mkdir hippo
cd hippo
django-admin startproject hippo_api
```

创建好项目之后，通过pycharm打开，并切换虚拟环境为hippo



### 项目目录调整

```python
├── hippo_api/      # 后端项目目录
       ├── logs/          # 项目运行时/开发时日志目录
       ├── manage.py
       ├── hippo_api/      # 项目主应用，开发时的代码保存
       │    ├── apps/      # 开发者的代码保存目录，以模块[子应用]为目录保存（包）
       │    ├── libs/      # 第三方类库的保存目录[第三方组件、模块]（包）
       │    ├── settings/  #（包）
       │         ├── dev.py   # 项目开发时的本地配置
       │         ├── prod.py  # 项目上线时的运行配置
       │         ├── test.py  # 测试人员使用的配置(咱们不需要)
       │    ├── urls.py    # 总路由（包）
       │    ├── utils/     # 多个模块[子应用]的公共函数类库[自己开发的组件]
       └── scripts/       # 保存项目运营时的脚本文件 bash
```

上面的目录结构图，使用Ubuntu的命令tree输出的。
如果没有安装tree，可以使用 `sudo apt install tree`，就有了。

注意：创建文件夹的时候，是创建包(含`__init__.py`文件的)还是创建单纯的文件夹，看目录里面放的是什么，如果放的是py文件相关的代码，最好创建包，如果不是，那就创建单纯的文件夹。

切换manage.py启动项目时使用的配置文件。mange.py，代码：

```python
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'hippo_api.settings.dev')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()

```

#### 把restframework注册到django

settings.dev.py，代码：

```python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',
]
```

调整子应用保存以后，创建并注册子应用需要调整如下，

例如：创建home子应用

```
cd hippo_api/apps
python ../../manage.py startapp home
```

子应用的注册，settings.dev.py，代码：

```python
# 设置apps为系统导报路径
import sys
sys.path.insert(0, str(BASE_DIR / 'apps'))

# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',
    'home',
]

```

创建了一个测试视图，提供给外界访问。home.views.py，代码：

```python
from rest_framework.views import APIView
from rest_framework.response import Response
class TestAPIView(APIView):
    def get(self,request):
        from django.db import DatabaseError
        raise DatabaseError("xxxx")
        return Response({"message":"hello"},)
```

home.urls.py，代码：

```python
from django.urls import path
from . import views
urlpatterns = [
    path("test", views.TestAPIView.as_view())
]
```

总路由加载home子应用的路由信息，`hippo_api.urls`，代码：

```python
from django.contrib import admin
from django.urls import path,include

urlpatterns = [
    path('admin/', admin.site.urls),
    path("", include("home.urls")),
]
```



### 日志配置

 参考django官方文档

网址：https://docs.djangoproject.com/zh-hans/3.2/topics/logging/

在settings/dev.py文件中追加如下配置：

```python
# 日志配置
LOGGING = {
    # 使用的python内置的logging模块，那么python可能会对它进行升级，所以需要写一个版本号，目前就是1版本
    'version': 1,
    # #是否去掉目前项目中其他地方中以及使用的日志功能，但是将来我们可能会引入第三方的模块，里面可能内置了日志功能，所以尽量不要关闭，肯定False
    'disable_existing_loggers': False,
    # 日志的处理格式
    'formatters': {
        # 详细格式，往往用于记录日志到文件/其他第三方存储设备
        'verbose': {
            # levelname等级，asctime记录时间，module表示日志发生的文件名称，lineno行号，message错误信息
            'format': '{levelname} {asctime} {module}:{lineno:d} {message}',
            # 日志格式中的，变量分隔符
            'style': '{',
        },
        'simple': {  # 简单格式，往往用于终端
            'format': '{levelname} {module}:{lineno} {message}',
            'style': '{',
        },
    },
    'filters': { # 日志的过滤设置，可以对日志进行输出时的过滤用的
        # 在debug=True下产生的一些日志信息，要不要记录日志，需要的话就在handlers中加上这个过滤器，不需要就不加
        'require_debug_true': {
            '()': 'django.utils.log.RequireDebugTrue',
        },
    },
    'handlers': {  # 日志的处理方式
        'console': {  # 终端下显示
            'level': 'DEBUG',  # 日志的最低等级
            'filters': ['require_debug_true'],
            'class': 'logging.StreamHandler', # 处理日志的核心类
            'formatter': 'simple'
        },
        'file': {  # 文件中记录日志
            'level': 'INFO',
            'class': 'logging.handlers.RotatingFileHandler',
            # 日志位置,日志文件名,日志保存目录必须手动创建
            'filename': BASE_DIR.parent / "logs/hippo.log",
            # 单个日志文件的最大值,这里我们设置300M
            'maxBytes': 300 * 1024 * 1024,
            # 备份日志文件的数量,设置最大日志数量为10
            'backupCount': 10,
            # 日志格式:详细格式
            'formatter': 'verbose',
            # 设置默认编码，否则打印出来汉字乱码
            'encoding': 'utf-8',
        },
    },
    # 日志实例对象
    'loggers': {
        'django': { # 固定名称，将来django内部也会有异常的处理，只会调用django下标的日志对象
            'handlers': ['console', 'file'],
            'propagate': True,  # 是否让日志信息继续冒泡给其他的日志处理系统
        },
    }
}

```



### 异常处理

新建utils/exceptions.py

```python
import logging

from rest_framework.views import exception_handler
from rest_framework.response import Response
from rest_framework import status

from django.db import DatabaseError

logger = logging.getLogger("django")

def custom_exception_handler(exc, context):
    """
    自定义异常处理
    :param exc: 异常类实例对象
    :param context: 抛出异常的执行上下文[context，是一个字典格式的数据，里面记录了异常发生时的环境信息]
    :return: Response 响应对象
    """
    # 先让drf内置的异常处理函数先解决掉它能识别的异常
    response = exception_handler(exc, context)

    if response is None:
        """drf无法处理的异常"""
        view = context["view"]
        if isinstance(exc, DatabaseError):
            logger.error('[%s] %s' % (view, exc))
            response = Response({"errmsg":"服务器内部存储错误"}, status=status.HTTP_507_INSUFFICIENT_STORAGE)

    return response
```



settings/dev.py配置文件中添加

```python
REST_FRAMEWORK = {
    # 异常处理
    'EXCEPTION_HANDLER': 'hippo_api.utils.exceptions.custom_exception_handler',
}
```



### 创建数据库

```mysql
create database hippo default charset=utf8mb4; -- utf8也会导致有些极少的中文出现乱码的问题，mysql5.5之后官方才进行处理，出来了utf8mb4，这个是真正的utf8，能够容纳所有的中文。
```

为当前项目创建数据库用户[这个用户只能看到hippo这个数据库]

```mysql
# 创建用户：create user '用户名'@'主机地址' identified by '密码';
create user 'hippo_user'@'%' identified by 'hippo';  # %表示任意主机都可以通过当前账户登录到mysql
# 分配权限：grant 权限选项 on 数据库名.数据表 to '用户名'@'主机地址' with grant option;
grant all privileges on hippo.* to 'hippo_user'@'%' with grant option;

# mysql8.0版本以下，创建数据库用户并设置数据库权限给当前新用户，并刷新内存中的权限记录
create user hippo_user identified by 'hippo';
grant all privileges on hippo.* to 'hippo_user'@'%';
flush privileges;
```



### 配置数据库连接

打开settings/dev.py文件，并配置

```python
DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.mysql",
        "HOST": "127.0.0.1",
        "PORT": 3306,
        "USER": "hippo_user",
        "PASSWORD": "hippo",
        "NAME": "hippo",
    }
}
```

在项目主模块的 `__init__.py`中导入pymysql

```python
from pymysql import install_as_MySQLdb

install_as_MySQLdb()
```



### 跨域设置

我们现在为前端和后端分别设置两个不同的域名：

| 位置   | 域名           |
| ------ | -------------- |
| 客户端 | `www.hippo.cn` |
| 服务端 | `api.hippo.cn` |

编辑`/etc/hosts`文件，可以设置本地域名

```bash
sudo vim /etc/hosts
```

在文件中增加两条信息

```shell
127.0.0.1   localhost
127.0.0.1   api.hippo.cn
127.0.0.1   www.hippo.cn
```



现在，前端与后端分处不同的域名，我们需要为后端添加跨域访问的支持

否则前端无法使用axios无法请求后端提供的api数据，开发中，我们使用CORS来解决后端对跨域访问的支持。

使用django-cors-headers扩展

```
在 Response(headers={"Access-Control-Allow-Origin":'客户端地址或*'})
```

文档：https://github.com/ottoyiu/django-cors-headers/

安装

```python
pip install django-cors-headers -i https://pypi.douban.com/simple/
```

添加应用，settings.dev.py，代码：

```python
INSTALLED_APPS = (
    ...
    'rest_framework',
    'corsheaders',
    ...
)
```

中间件设置【必须写在第一个位置】，settings.dev.py，代码：

```python
MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware', #放在中间件的最上面，就是给响应头加上了一个响应头跨域
    ...
]
```

需要添加跨域白名单，确定一下哪些客户端可以跨域。settings.dev.py，代码：

```python
# CORS组的配置信息
CORS_ORIGIN_WHITELIST = (
    #'www.hippo.cn:8080', #如果这样写不行的话，就加上协议(http://www.hippo.cn:8080，因为不同的corsheaders版本可能有不同的要求)
    'http://www.hippo.cn:8080',
)
CORS_ALLOW_CREDENTIALS = False  # 是否允许ajax跨域请求时携带cookie，False表示不用，我们后面也用不到cookie，所以关掉它就可以了，以防有人通过cookie来搞我们的网站
```

允许客户端通过api.hippo.cn访问Django项目，settings.dev.py，代码：

```python
ALLOWED_HOSTS = [
    "api.hippo.cn",
]
```

完成了上面的步骤，我们将来就可以通过后端提供数据给前端使用ajax访问了。前端使用 axios就可以访问到后端提供给的数据接口，但是如果要附带cookie信息，前端还要设置一下，这个等我们搭建客户端项目时再配置。

完成了上面的操作以后，服务端的初始化算基本完成了。我们现在已经写了那么多代码的话，肯定要对代码进行版本跟踪和管理，这时候，我们就要使用git通过gitee/github/gitlab进行创建代码版本。

码云：http://www.gitee.com

接下来，在终端下设置当前开发者的身份。这里，我们把客户端和服务端的代码保存到一个代码仓库中。所以直接在hippo目录下创建代码仓库。

```bash
cd ~/Desktop/hippo
# 初始化git代码库
git init
# 设置身份
git config user.name "mooluo"
git config user.email "649641514@qq.com"

# 设置远程仓库
git remote add origin git@gitee.com:mooluo_admin/hippo30.git

# 接下来，我们就可以把上面服务端初始化的代码保存一个版本
git  add .
git commit -m "api服务端初始化完成"

# 生成本地ssh密码，链接到服务端
# https://gitee.com/help/articles/4181
ssh-keygen -t rsa -C "649641514@qq.com"
```

```bash
# 查看上面生成的ssh公钥，并复制到gitee码云上面
cat ~/.ssh/id_rsa.pub

# ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDMOMyIyx0eyugPcTHJu3oH4N/7wVBV29mVoI2BcbD2650/fM0EJzrSmqRyz7UTglFi6M15p9qj7wu7wLyTsu92JnJkzazGTzfWlZ9dL0M+SiJBCL1fXqzkHndto/SidtuowSZBByQofnL+EOmf/ItCEIydZpUO3zUUHHViwzKLlGgMtjv5xQyRMFPrWVuCdZzxOZhnEFPtEcerdzXS7Vvnv8ptDzlWCjuNoRtvDLoHErZWFcygBW3wHFraqUeVnjg2qh3mApwxFuq/kCnn6eqGmi+kTbE2AW6opKFOK2SMLhhJdsTMDEnkp8q/8YsMTZ2FDlTCdRdzJkUSD05vUuGAyv2MXaCW3pQGwKPdrC/rZAIxD9oaYNBKUJ/lHdoBBCKzcU7Taidv3yAbba3dI9iMDETqGt51xf2IKf5R/xXIhaqMc3W4Y5LjBQU36Gm9Q5ACn+RtJaBmzGkVX8fK+IP8sBFn1j1wYMaBgMkmEzFyjBFkhiMuVolnBrAEPQKzlPE= 649641514@qq.com
```

访问个人中心的设置ssh公钥的地址：https://gitee.com/profile/sshkeys

```bash
# 把git版本库历史记录同步到gitee码云上面
git push -u origin master
```
