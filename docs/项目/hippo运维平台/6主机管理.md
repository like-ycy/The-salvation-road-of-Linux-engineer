### 主机管理

![1611457149820](6%E4%B8%BB%E6%9C%BA%E7%AE%A1%E7%90%86.assets/1611457149820.png)

前端页面代码，Host.vue：

```vue
<template>
    <div class="host">
      <a-card size="small" :bordered="false">
        <a-row>
          <a-col :span="6">
            <a-form-item label="主机类别：" :label-col="formItemLayout.labelCol" :wrapper-col="formItemLayout.wrapperCol">
              <a-select style="width: 120px;" placeholder="请选择" @change="handleSelectChange" v-model="host_form.form.category">
                <a-select-option :value="value.id" v-for="(value, index) in categorys" :key="value.id">
                  {{value.name}}
                </a-select-option>
              </a-select>
            </a-form-item>
          </a-col>
          <a-col :span="6">
            <a-form-item :label-col="formItemLayout.labelCol" :wrapper-col="formItemLayout.wrapperCol" label="主机别名：">
              <a-input placeholder="请输入"/>
            </a-form-item>
          </a-col>
          <a-col :span="6">
            <a-form-item :label-col="formItemLayout.labelCol" :wrapper-col="formItemLayout.wrapperCol" label="连接地址：" >
              <a-input v-decorator="['nickname', { rules: [{ required: checkHost, message: 'Please input your nickname' }] }, ]" placeholder="请输入"/>
            </a-form-item>
          </a-col>
          <a-col :span="6">
            <router-link to="/workbench">
              <a-button type="primary" icon="sync" style="margin-top: 3px;">
                刷新页面
              </a-button>
            </router-link>
          </a-col>
        </a-row>

        <div class="add_host" style="margin-bottom: 15px;">
          <a-button type="primary" icon="plus" @click="showModal">
            新建
          </a-button>
          <a-button type="primary" icon="import" style="margin-left: 20px;">
            批量导入
          </a-button>
        </div>
        <a-modal
          :width="800"
          title="新建主机"
          :visible="visible"
          :confirm-loading="confirmLoading"

          @cancel="handleCancel"
        >
          <template slot="footer">
            <a-button key="back" @click="handleCancel">取消</a-button>
            <a-button key="submit" type="primary" :loading="loading" @click="onSubmit">验证</a-button>
          </template>
          <a-form-model ref="ruleForm" :model="host_form.form" :rules="host_form.rules" :label-col="host_form.labelCol" :wrapper-col="host_form.wrapperCol">

            <a-form-model-item label="主机类别" prop="zone">
              <a-row>
                <a-col :span="12">
                  <a-select v-model="host_form.form.category" placeholder="请选择主机类别/区域/分组">
                    <a-select-option :value="value.id" v-for="(value, index) in categorys" :key="value.id">
                    {{value.name}}
                    </a-select-option>
                  </a-select>
                </a-col>
                <a-col :span="5" :offset="2">
                  <button type="button" class="ant-btn ant-btn-link"><span>添加类别</span></button>
                </a-col>
                <a-col :span="5">
                  <button type="button" class="ant-btn ant-btn-link"><span>编辑类别</span></button>
                </a-col>
              </a-row>
            </a-form-model-item>
            <a-form-model-item ref="hostname" label="主机名称" prop="hostname">
              <a-row>
                <a-col :span="24">
                  <a-input placeholder="请输入主机名称" v-model="host_form.form.hostname"/>
                </a-col>
              </a-row>
            </a-form-model-item>

            <a-form-model-item ref="ip_addr" label="连接地址" prop="ip_addr">
              <a-row>
                <a-col :span="8">
                  <a-input placeholder="用户名" addon-before="ssh" v-model="host_form.form.username"/>
                </a-col>
                <a-col :span="8">
                  <a-input placeholder="ip地址" addon-before="@" v-model="host_form.form.ip_addr"/>
                </a-col>
                <a-col :span="8">
                  <a-input placeholder="端口号" addon-before="-p" v-model="host_form.form.port"/>
                </a-col>
              </a-row>
            </a-form-model-item>

            <a-form-model-item ref="password" label="连接密码" prop="password">
              <a-row>
                <a-col :span="24">
                  <a-input placeholder="请输入连接密码" v-model="host_form.form.password" type="password"/>
                </a-col>
              </a-row>
            </a-form-model-item>

            <a-form-model-item extra="默认使用全局密钥，如果上传了独立密钥则优先使用该密钥。" ref="hostname" label="独立秘钥" prop="pkey">
              <a-row>
                <a-col :span="24">
                  <a-upload name="file" :multiple="true" action="上传文件的地址" :headers="upload_pkey_headers" @change="handleFileChange">
                    <a-button>
                      <a-icon type="upload"/>
                      点击上传
                    </a-button>
                  </a-upload>
                </a-col>
              </a-row>
            </a-form-model-item>
            <a-form-model-item ref="desc" label="备注信息" prop="desc">
              <a-row>
                <a-col :span="24">
                  <a-textarea v-model="host_form.desc" placeholder="请输入主机备注信息" :auto-size="{ minRows: 3, maxRows: 5 }"/>
                </a-col>
              </a-row>
            </a-form-model-item>

            <a-form-model-item>
              <a-row>
                <a-col :span="24" :offset="10">
                  <span>
                    <a-icon type="warning" style="color:yellow;"/>
                    首次验证时需要输入登录用户名对应的密码，但不会存储该密码。
                  </span>
                </a-col>
              </a-row>
            </a-form-model-item>
          </a-form-model>
        </a-modal>

        <a-table :columns="columns" :data-source="data" rowKey="id">
          <a slot="name" slot-scope="text">{{ text }}</a>
          <template v-slot:action>
            <a href="javascript:;">编辑</a> |
            <a href="javascript:;">删除</a> |
            <a href="javascript:;">Console</a>
          </template>
        </a-table>
      </a-card>
    </div>
</template>

<script>
  const formItemLayout = {
    labelCol: {span: 8},
    wrapperCol: {span: 12},
  };

    const columns = [
    {
      title: '类别',
      dataIndex: 'category_name',
      key: 'category_name',
    },
    {
      title: '主机名称',
      dataIndex: 'hostname',
      key: 'hostname',
      sorter: true,

    },
    {
      title: '连接地址',
      dataIndex: 'ip_addr',
      key: 'ip_addr',
      ellipsis: true,
      sorter: true,
      width: 200,
    },
    {
      title: '端口',
      dataIndex: 'port',
      key: 'port',
      ellipsis: true,
    },
    {
      title: '备注信息',
      dataIndex: 'desc',
      key: 'desc',
      ellipsis: true,
    },

    {
      title: '操作',
      key: 'action',
      width: 200,
      scopedSlots: {customRender: 'action'},
    },
  ];

  export default {
    name: "Host",
    data(){
      return {
        loading: false,
        formItemLayout,   // formItemLayout: formItemLayout,
        checkHost: false, // 是否验证信息
        visible: false,   // 是否显示添加主机的弹窗
        confirmLoading: false,
        categorys: [     // 主机类别

        ],
        data: [
          // {"id":1, "category_name":"数据库服务器","hostname":"iZbp1b1jw4l12ho53ivhkkZ","ip_addr":"47.98.130.212","port":22,"desc":""},
          // {"id":2, "category_name":"数据库服务器","hostname":"iZbp1b1jw4l12ho53ivhkkZ","ip_addr":"47.98.130.212","port":22,"desc":""},
          // {"id":3, "category_name":"数据库服务器","hostname":"iZbp1b1jw4l12ho53ivhkkZ","ip_addr":"47.98.130.212","port":22,"desc":""},
          // {"id":4, "category_name":"数据库服务器","hostname":"iZbp1b1jw4l12ho53ivhkkZ","ip_addr":"47.98.130.212","port":22,"desc":""},
        ],
        columns:columns, // 表格的表头信息
        // 上传文件的配置参数
        upload_pkey_headers: {
          authorization: 'authorization-text',
        },
        // 添加主机需要的数据属性
        host_form: {
          labelCol: {span: 6},
          wrapperCol: {span: 14},
          other: '',
          form: {
            hostname: '',
            category: '',
            ip_addr: '',

            username: '',
            port: '',
            desc: '',
            password:'',
          },
          rules: {
            hostname: [
              {required: true, message: '请输入主机名称', trigger: 'blur'},
              {min: 3, max: 10, message: '长度在3-10位之间', trigger: 'blur'},
            ],
            password: [
              {required: true, message: '请输入连接密码', trigger: 'blur'},
              {min: 3, max: 10, message: '长度在3-10位之间', trigger: 'blur'},
            ],
            category: [{required: true, message: '请选择类别', trigger: 'change'}],
            username: [
              {required: true, message: '请输入用户名', trigger: 'blur'},
              {min: 3, max: 10, message: '长度在3-10位', trigger: 'blur'},
            ],

            ip_addr: [
              {required: true, message: '请输入连接地址', trigger: 'blur'},
              {max: 15, message: '长度最大15位', trigger: 'blur'},
            ],

            port: [
              {required: true, message: '请输入端口号', trigger: 'blur'},
              {max: 5, message: '长度最大5位', trigger: 'blur'},
            ],
          },
        },
      }
    },
    methods:{
      handleSelectChange(value) {
        console.log(value);
      },
      showModal() {
        // 显示添加主机的表单窗口
        this.visible = true;
      },
      handleCancel(e) {
        // 表单取消
        this.resetForm(); //清空表单内容

        this.visible = false; // 关闭对话框
      },
      onSubmit(){
        this.$refs.ruleForm.validate(valid => {
          // 验证
          if (valid) {
            // 将数据提交到后台进行保存，但是先进行连接校验，验证没有问题，再保存
            // this.$axios.post(`${this.$settings.host}/host/`)
            // 发送验证请求

          } else {
            // 验证失败！
            return false;
          }
        });
      },
      handleFileChange(info){
        if (info.file.status !== 'uploading') {
          console.log(info.file, info.fileList);
        }
        if (info.file.status === 'done') {
          this.$message.success(`${info.file.name} 上传成功`);
        } else if (info.file.status === 'error') {
          this.$message.error(`${info.file.name} 上传失败`);
        }
      },
      resetForm(){
         // 重置添加主机的表单信息
         this.$refs.ruleForm.resetFields();
      }
    }
  }
</script>

<style scoped>

</style>
```



#### 主机管理基本功能实现

创建应用

```shell
cd hippo_api/apps/
python ../../manage.py startapp host
```

注册子应用，settings.dev，代码：

```python
INSTALLED_APPS = [

    'host',
]
```



总路由

```python
path('host/', include('host.urls')),
```

在host应用中创建urls.py文件，写如下内容

```python
from django.urls import path
from . import views
urlpatterns = [

]
```

模型

hippo_api/utils/models.py  基础模型类

```python
from django.db import models

class BaseModel(models.Model):
    """公共模型"""
    name = models.CharField(max_length=500,default="", null=True, blank=True, verbose_name='名称/标题')
    is_show = models.BooleanField(default=True, verbose_name="是否显示")
    orders = models.IntegerField(default=1, verbose_name="排序")
    is_deleted = models.BooleanField(default=False, verbose_name="是否删除")
    created_time = models.DateTimeField(auto_now_add=True, verbose_name="添加时间")
    updated_time = models.DateTimeField(auto_now=True, verbose_name="修改时间")
    description = models.TextField(null=True, blank=True, default="", verbose_name="描述信息")

    class Meta:
        # 数据库迁移时，设置了bstract = True的model类不会生成数据库表
        abstract = True

    def __str__(self):
        return self.name
```



主机相关的模型代码，host/models.py

```python
from hippo_api.utils.models import BaseModel,models
from users.models import User

class HostCategory(BaseModel):
    """主机类别"""
    class Meta:
        db_table = "hp_host_category"
        verbose_name = "主机类别"
        verbose_name_plural = verbose_name  # 取消提示文字中关于英文复数+s的情况

class Host(BaseModel):
    # 真正在数据库中的字段实际上叫 category_id，而category则代表了关联的哪个分类模型对象
    category = models.ForeignKey('HostCategory', on_delete=models.DO_NOTHING, verbose_name='主机类别', related_name='hc', null=True, blank=True)
    ip_addr = models.CharField(blank=True, null=True, max_length=500, verbose_name='连接地址')
    port = models.IntegerField(verbose_name='端口')
    username = models.CharField(max_length=50, verbose_name='登录用户')
    users = models.ManyToManyField(User)

    class Meta:
        db_table = "hp_host"
        verbose_name = "主机信息"
        verbose_name_plural = verbose_name
    def __str__(self):
        return self.name + ':' + self.ip_addr

# 全局密钥和共钥，所有用户都使用这个一对
class PkeyModel(BaseModel):
    name    = models.CharField(max_length=500, unique=True) # 名称
    private = models.TextField(verbose_name="私钥")
    public  = models.TextField(verbose_name="公钥")

    def __repr__(self):
        return f'<Pkey {self.name}>'
```

数据迁移，终端下执行：

```bash
python manage.py makemigrations --merge
python manage.py makemigrations
python manage.py migrate
```

合并选中的多行代码的快捷键：Ctrl+shift+J



序列化器

host/serializers.py，代码：

```python
from rest_framework import serializers
from . import models

class HostCategoryModelSeiralizer(serializers.ModelSerializer):
    """主机分类的序列化器"""
    class Meta:
        model = models.HostCategory
        fields = ['id', 'name']


class HostModelSerializers(serializers.ModelSerializer):
    """主机信息的序列化器"""
    category_name = serializers.CharField(source='category.name', read_only=True)
    password = serializers.CharField(max_length=32, write_only=True, label="登录密码")

    class Meta:
        model = models.Host
        fields = ['id', 'category', 'category_name', 'name', 'ip_addr', 'port', 'description', 'username', 'password']

    def validate(self, attrs):
        """当用户添加、编辑主机信息会自动执行这个方法"""
        ip_addr = attrs.get('ip_addr')
        port = attrs.get('port')
        username = attrs.get('username')
        password = attrs.get('password')

        # todo 验证主机信息是否正确

        return attrs


    # 添加host记录，如果第一次添加host记录，那么需要我们生成全局的公钥和私钥
    def create(self, validated_data):
        print('接受通过验证以后的数据字典:',validated_data)
        ip_addr = validated_data.get('ip_addr')
        port = validated_data.get('port')
        username = validated_data.get('username')
        password = validated_data.get('password')

        # todo 生成公私钥和管理主机的公私钥

        # 剔除密码字段，保存host记录
        password = validated_data.pop('password')
        instance = models.Host.objects.create(
            **validated_data
        )
        return instance
```

视图代码：

```python
from rest_framework.generics import ListAPIView,CreateAPIView
from rest_framework.viewsets import ModelViewSet
from .models import HostCategory,Host
from .serializers import HostCategoryModelSeiralizer,HostModelSerializers
from rest_framework.permissions import IsAuthenticated

class HostCategoryListAPIView(ListAPIView, CreateAPIView):
    """主机类别"""
    queryset = HostCategory.objects.filter(is_show=True, is_deleted=False).order_by("orders","-id").all()
    serializer_class = HostCategoryModelSeiralizer
    permission_classes = [IsAuthenticated]

class HostModelViewSet(ModelViewSet):
    """主机信息"""
    queryset = Host.objects.all()
    serializer_class = HostModelSerializers
    permission_classes = [IsAuthenticated]
```

路由，代码：

```python
from django.urls import path,re_path
from host import views

urlpatterns = [
  	path('categorys/', views.CategorysView.as_view()),  #主机分类数据
    path('list/', views.HostView.as_view({'get': 'list', 'post': 'create'})), #主机数据
]

```



##### 前端实现

主机页面展示(包含主机添加功能和展示功能)

src/components/Host.vue

```html
<template>
    <div class="host">
      <a-card size="small" :bordered="false">
        <a-row>
          <a-col :span="6">
            <a-form-item label="主机类别：" :label-col="formItemLayout.labelCol" :wrapper-col="formItemLayout.wrapperCol">
              <a-select style="width: 120px;" placeholder="请选择" @change="handleSelectChange" v-model="host_form.form.category">
                <a-select-option :value="value.id" v-for="(value, index) in categorys" :key="value.id">
                  {{value.name}}
                </a-select-option>
              </a-select>
            </a-form-item>
          </a-col>
          <a-col :span="6">
            <a-form-item :label-col="formItemLayout.labelCol" :wrapper-col="formItemLayout.wrapperCol" label="主机别名：">
              <a-input placeholder="请输入"/>
            </a-form-item>
          </a-col>
          <a-col :span="6">
            <a-form-item :label-col="formItemLayout.labelCol" :wrapper-col="formItemLayout.wrapperCol" label="连接地址：" >
              <a-input v-decorator="['nickname', { rules: [{ required: checkHost, message: 'Please input your nickname' }] }, ]" placeholder="请输入"/>
            </a-form-item>
          </a-col>
          <a-col :span="6">
            <router-link to="/workbench">
              <a-button type="primary" icon="sync" style="margin-top: 3px;">
                刷新页面
              </a-button>
            </router-link>
          </a-col>
        </a-row>

        <div class="add_host" style="margin-bottom: 15px;">
          <a-button type="primary" icon="plus" @click="showModal">
            新建
          </a-button>
          <a-button type="primary" icon="import" style="margin-left: 20px;">
            批量导入
          </a-button>
        </div>
        <a-modal
          :width="800"
          title="新建主机"
          :visible="visible"
          :confirm-loading="confirmLoading"

          @cancel="handleCancel"
        >
          <template slot="footer">
            <a-button key="back" @click="handleCancel">取消</a-button>
            <a-button key="submit" type="primary" :loading="loading" @click="onSubmit">验证</a-button>
          </template>
          <a-form-model ref="ruleForm" :model="host_form.form" :rules="host_form.rules" :label-col="host_form.labelCol" :wrapper-col="host_form.wrapperCol">

            <a-form-model-item label="主机类别" prop="zone">
              <a-row>
                <a-col :span="12">
                  <a-select v-model="host_form.form.category" placeholder="请选择主机类别/区域/分组">
                    <a-select-option :value="value.id" v-for="(value, index) in categorys" :key="value.id">
                    {{value.name}}
                    </a-select-option>
                  </a-select>
                </a-col>
                <a-col :span="5" :offset="2">
                  <button type="button" class="ant-btn ant-btn-link"><span>添加类别</span></button>
                </a-col>
                <a-col :span="5">
                  <button type="button" class="ant-btn ant-btn-link"><span>编辑类别</span></button>
                </a-col>
              </a-row>
            </a-form-model-item>
            <a-form-model-item ref="name" label="主机名称" prop="name">
              <a-row>
                <a-col :span="24">
                  <a-input placeholder="请输入主机名称" v-model="host_form.form.name"/>
                </a-col>
              </a-row>
            </a-form-model-item>

            <a-form-model-item ref="ip_addr" label="连接地址" prop="ip_addr">
              <a-row>
                <a-col :span="8">
                  <a-input placeholder="用户名" addon-before="ssh" v-model="host_form.form.username"/>
                </a-col>
                <a-col :span="8">
                  <a-input placeholder="ip地址" addon-before="@" v-model="host_form.form.ip_addr"/>
                </a-col>
                <a-col :span="8">
                  <a-input placeholder="端口号" addon-before="-p" v-model="host_form.form.port"/>
                </a-col>
              </a-row>
            </a-form-model-item>

            <a-form-model-item ref="password" label="连接密码" prop="password">
              <a-row>
                <a-col :span="24">
                  <a-input placeholder="请输入连接密码" v-model="host_form.form.password" type="password"/>
                </a-col>
              </a-row>
            </a-form-model-item>

            <a-form-model-item extra="默认使用全局密钥，如果上传了独立密钥则优先使用该密钥。" ref="name" label="独立秘钥" prop="pkey">
              <a-row>
                <a-col :span="24">
                  <a-upload name="file" :multiple="true" action="上传文件的地址" :headers="upload_pkey_headers" @change="handleFileChange">
                    <a-button>
                      <a-icon type="upload"/>
                      点击上传
                    </a-button>
                  </a-upload>
                </a-col>
              </a-row>
            </a-form-model-item>
            <a-form-model-item ref="description" label="备注信息" prop="description">
              <a-row>
                <a-col :span="24">
                  <a-textarea v-model="host_form.form.description" placeholder="请输入主机备注信息" :auto-size="{ minRows: 3, maxRows: 5 }"/>
                </a-col>
              </a-row>
            </a-form-model-item>

            <a-form-model-item>
              <a-row>
                <a-col :span="24" :offset="10">
                  <span>
                    <a-icon type="warning" style="color:yellow;"/>
                    首次验证时需要输入登录用户名对应的密码，但不会存储该密码。
                  </span>
                </a-col>
              </a-row>
            </a-form-model-item>
          </a-form-model>
        </a-modal>

        <a-table :columns="columns" :data-source="data" rowKey="id">
          <a slot="name" slot-scope="text">{{ text }}</a>
          <template v-slot:action>
            <a href="javascript:;">编辑</a> |
            <a href="javascript:;">删除</a> |
            <a href="javascript:;">Console</a>
          </template>
        </a-table>
      </a-card>
    </div>
</template>

<script>
  const formItemLayout = {
    labelCol: {span: 8},
    wrapperCol: {span: 12},
  };

    const columns = [
    {
      title: '类别',
      dataIndex: 'category_name',
      key: 'category_name',
    },
    {
      title: '主机名称',
      dataIndex: 'name',
      key: 'name',
      sorter: true,

    },
    {
      title: '连接地址',
      dataIndex: 'ip_addr',
      key: 'ip_addr',
      ellipsis: true,
      sorter: true,
      width: 200,
    },
    {
      title: '端口',
      dataIndex: 'port',
      key: 'port',
      ellipsis: true,
    },
    {
      title: '备注信息',
      dataIndex: 'description',
      key: 'description',
      ellipsis: true,
    },

    {
      title: '操作',
      key: 'action',
      width: 200,
      scopedSlots: {customRender: 'action'},
    },
  ];

  export default {
    name: "Host",
    data(){
      return {
        loading: false,
        formItemLayout,   // formItemLayout: formItemLayout,
        checkHost: false, // 是否验证信息
        visible: false,   // 是否显示添加主机的弹窗
        confirmLoading: false,
        categorys: [     // 主机类别

        ],
        data: [
          // {"id":1, "category_name":"数据库服务器","name":"iZbp1b1jw4l12ho53ivhkkZ","ip_addr":"47.98.130.212","port":22,"description":""},
          // {"id":2, "category_name":"数据库服务器","name":"iZbp1b1jw4l12ho53ivhkkZ","ip_addr":"47.98.130.212","port":22,"description":""},
          // {"id":3, "category_name":"数据库服务器","name":"iZbp1b1jw4l12ho53ivhkkZ","ip_addr":"47.98.130.212","port":22,"description":""},
          // {"id":4, "category_name":"数据库服务器","name":"iZbp1b1jw4l12ho53ivhkkZ","ip_addr":"47.98.130.212","port":22,"description":""},
        ],
        columns:columns, // 表格的表头信息
        // 上传文件的配置参数
        upload_pkey_headers: {
          authorization: 'authorization-text',
        },
        // 添加主机需要的数据属性
        host_form: {
          labelCol: {span: 6},
          wrapperCol: {span: 14},
          other: '',
          form: {
            name: '',
            category: '',
            ip_addr: '',
            username: '',
            port: '',
            description: '',
            password:'',
          },
          rules: {
            name: [
              {required: true, message: '请输入主机名称', trigger: 'blur'},
              {min: 3, message: '长度在3-20位之间', trigger: 'blur'},
            ],
            password: [
              {required: true, message: '请输入连接密码', trigger: 'blur'},
              {min: 3, max: 20, message: '长度在3-10位之间', trigger: 'blur'},
            ],
            category: [{required: true, message: '请选择类别', trigger: 'change'}],
            username: [
              {required: true, message: '请输入用户名', trigger: 'blur'},
              {min: 3, max: 20, message: '长度在3-10位', trigger: 'blur'},
            ],

            ip_addr: [
              {required: true, message: '请输入连接地址', trigger: 'blur'},
              {max: 50, message: '长度最大15位', trigger: 'blur'},
            ],

            port: [
              {required: true, message: '请输入端口号', trigger: 'blur'},
              {max: 5, message: '长度最大5位', trigger: 'blur'},
            ],
          },
        },
      }
    },
    created(){
        // ajax获取数据
        this.get_categorys()
        this.get_host_list()
    },
    methods:{
      get_host_list(){
        let token = sessionStorage.token || localStorage.token || "";
        // 获取主机列表
        this.$axios.get(`${this.$settings.host}/host/host`,{
          headers:{
            Authorization: "jwt " + token,
          }
        }).then(response=>{
          this.data = response.data
        }).catch(error=>{
          this.$message.error("主机列表获取失败！")
        })
      },
      get_categorys(){
        // 获取主机类别
        let token = sessionStorage.token || localStorage.token || "";
        this.$axios.get(`${this.$settings.host}/host/category`,{
          headers:{
            Authorization: "jwt " + token,
          }
        }).then(response=>{
          this.categorys = response.data
        }).catch(error=>{
          this.$message.error("主机类别获取失败！")
        })
      },
      handleSelectChange(value) {
        console.log(value);
      },
      showModal() {
        // 显示添加主机的表单窗口
        this.visible = true;
      },
      handleCancel(e) {
        // 表单取消
        this.resetForm(); //清空表单内容

        this.visible = false; // 关闭对话框
      },
      onSubmit(){
        this.$refs.ruleForm.validate(valid => {
          // 验证通过则发送请求
          if (valid) {
              let token = sessionStorage.token || localStorage.token || "";
              // 将数据提交到后台进行保存，但是先进行连接校验，验证没有问题，再保存
              this.$axios.post(`${this.$settings.host}/host/host/`,{
                    "name":this.host_form.form.name,
                    "category":this.host_form.form.category,
                    "ip_addr":this.host_form.form.ip_addr,
                    "description":this.host_form.form.description,
                    "port":this.host_form.form.port,
                    "username":this.host_form.form.username,
                    "password":this.host_form.form.password,
              },{
                headers:{
                  Authorization: "jwt " + token,
                }
              }).then(response=>{
                  // 在现有的主机列表，追加新增的主机列表
                  this.data.unshift(response.data);
                  this.handleCancel();
              }).catch(error=>{
                  this.$message.error("添加主机失败！");
              })

          } else {
            // 验证失败！
            return false;
          }
        });
      },
      handleFileChange(info){
        if (info.file.status !== 'uploading') {
          console.log(info.file, info.fileList);
        }
        if (info.file.status === 'done') {
          this.$message.success(`${info.file.name} 上传成功`);
        } else if (info.file.status === 'error') {
          this.$message.error(`${info.file.name} 上传失败`);
        }
      },
      resetForm(){
         // 重置添加主机的表单信息
         this.$refs.ruleForm.resetFields();
      }
    }
  }
</script>
```



#### paramiko模块

指纹记录

![指纹信息.png](6%E4%B8%BB%E6%9C%BA%E7%AE%A1%E7%90%86.assets/%E6%8C%87%E7%BA%B9%E4%BF%A1%E6%81%AF.png)



生成公私钥的指令实现免密登陆(ssh免密连接)

```python
 第一步： 执行ssh-keygen    # ~/.ssh/  id_rsa  id_rsa.pub 两个文件  .pub的为公钥文件
 第二步： 将公钥文件信息上传到需要被管理的主机上，以后再通过ssh链接该主机进行主机管理的时候，就不需要输入密码了，这就是免密登陆，远程服务器中的公钥保存目录就在该服务器的家目录下~/.ssh/authorized_keys
	指令： ssh-copy-id root@47.98.130.212
    
```



Paramiko是SSHv2协议的Python（2.7，3.4+）实现，同时提供了客户端和服务器功能。尽管Paramiko利用Python C扩展进行了低级加密（[Cryptography](https://cryptography.io/)），但它本身是围绕SSH网络概念的纯Python接口，通过paramiko我们可以完成远程主机连接，指令执行、上传下载文件等操作。下面学习具体用法

官方网址： http://www.paramiko.org/

详细api接口文档：http://docs.paramiko.org/en/stable/

- SSHClient的作用类似于Linux的ssh命令，是对SSH会话的封装，该类封装了传输(Transport)，通道(Channel)及SFTPClient建立的方法(open_sftp)，通常用于执行远程命令。
- SFTPClient的作用类似与Linux的sftp命令，是对SFTP客户端的封装，用以实现远程文件操作，如文件上传、下载、修改文件权限等操作。



ssh连接并执行指令，我们使用paramiko，paramiko依赖于pycrypto模块，所以我们先安装pycrypto

```python
pip install pycrypto
pip install paramiko
```

Paramiko中的几个概念：

- Client：ssh客户端短连接模式
- Transport：可以建立ssh会话长连接模式
  - Channel：是一种类Socket，一种安全的SSH传输通道;
  - Transport：是一种加密的会话，使用时会同步创建了一个加密的Tunnels(通道)，这个Tunnels叫做Channel;需要open_session来完成长连接对话。
  - Session：是client与Server保持连接的对象，用connect()/start_client()/start_server()开始会话。

##### 简单示例

示例1： client模式，直接执行指令，类似于 `ssh root@47.98.130.212 'pwd'`

建立连接，发送指令，拿到指令结果，断开连接

```python
import paramiko
import traceback
from paramiko.ssh_exception import AuthenticationException

if __name__ == '__main__':
    # 通过parammiko创建一个ssh短连接客户端实例对象
    ssh = paramiko.SSHClient()
    # 自动在本机第一次连接远程服务器时，记录主机指纹
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    try:
        # 1. 直接密码远程连接的方式
        ssh.connect(hostname='47.98.130.212', port=22, username='root', password='123', timeout=10)
        # 注意，如果你测试某个服务器的连接时，如果你本地已经配置了这个远程服务器的免密登录(公私钥模式)，那么就不能测试出密码是否正确了，因为首先会通过公私钥模式登录，不会使用你的密码的。

        # 2. 使用秘钥免密登录的方式
        # pkey = PkeyModel.objects.get(name='xxxxxxx').private
        # pkey = RSAKey.from_private_key(StringIO(pkey))
        # ssh.connect(hostname='47.98.130.212', port=22, username='root', pkey=pkey, timeout=10)

        # 连接成功以后，就可以发送操作指令
        # stdin 输入[本机发送给远程主机的信息]
        # stdout 输出[远程主机返回给本机的信息]
        # stderr 错误
        stdin, stdout, stderr = ssh.exec_command('ls -la')
        # 读取stdout对象中返回的内容，返回结果bytes类型数据
        result = stdout.read()
        print( result.decode() )
        # 关闭连接
        ssh.close()
    except AuthenticationException as e:
        print(e.message)
        print(traceback.format_exc())
        print("连接参数有误，请检查连接信息是否正确！~")
```



示例2： transport模式

```python
import paramiko
import traceback
from paramiko.ssh_exception import AuthenticationException

if __name__ == '__main__':
    # 通过parammiko创建一个ssh短连接客户端实例对象
    ssh = paramiko.SSHClient()
    # 自动在本机第一次连接远程服务器时，记录主机指纹
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())

    try:
        # 1. 直接密码远程连接的方式
        ssh.connect(hostname='47.98.130.212', port=22, username='root', password='123', timeout=10)
        # 注意，如果你测试某个服务器的连接时，如果你本地已经配置了这个远程服务器的免密登录(公私钥模式)，那么就不能测试出密码是否正确了，因为首先会通过公私钥模式登录，不会使用你的密码的。

        # 2. 使用秘钥免密登录的方式
        # pkey = PkeyModel.objects.get(name='xxxxxxx').private
        # pkey = RSAKey.from_private_key(StringIO(pkey))
        # ssh.connect(hostname='47.98.130.212', port=22, username='root', pkey=pkey, timeout=10)

        while True:
            # 保存本次ssh的连接的回话状态
            cli = ssh.get_transport().open_session()
            # 设置回话超时时间
            cli.settimeout(120)

            command = input("请输入您要发送的指令：")
            if command == "exit":
                break
            # 发送指令
            cli.exec_command(command)
            # 接受操作指令以后，远程主机返回的结果
            stdout = cli.makefile("rb", -1)
            # 读取结果并转换编码
            content = stdout.read().decode()
            print(content)
            # 关闭连接
            ssh.close()
    except AuthenticationException as e:
        print(e.message)
        print(traceback.format_exc())
```

预备两台测试主机

```python
第一台：
  hostname:lmyyz
  8.129.90.123
  root
  Lxw951102..
第二台：
  ssh root@39.102.132.191
  root
  123
```



##### 通过paramiko封装操作类

`hippo/utils/ssh.py`，代码：

```python
from paramiko.client import SSHClient, AutoAddPolicy
from paramiko.config import SSH_PORT
from paramiko.rsakey import RSAKey
from paramiko.ssh_exception import AuthenticationException, SSHException
from io import StringIO

class SSH(object):
    def __init__(self,hostname, port=SSH_PORT, username='root', pkey=None, password=None, connect_timeout=30):
        if pkey is None and password is None:
            raise SSHException('私钥或者密码必须有一个不为空')

        self.client = None

        self.arguments = {
            'hostname': hostname,
            'port'    : port,
            'username': username,
            'password': password,
            'pkey'    : RSAKey.from_private_key(StringIO(pkey)) if isinstance(pkey, str) else pkey,
            'timeout' : connect_timeout,
        }

        # print(self.arguments)

    @staticmethod
    def generate_key():
        # 生成公私钥键值对
        key_obj = StringIO()
        key = RSAKey.generate(2048) # 生成长度为2024的秘钥对
        key.write_private_key(key_obj)
        # 返回值是一个元祖，两个成员分别是私钥和公钥
        return key_obj.getvalue(), 'ssh-rsa ' + key.get_base64()

    # 将公钥上传到对应主机
    def add_public_key(self, public_key):
        # 700 是文档拥有可读可写可执行，同一组用户或者其他用户都不具有操作权限
        # 600 是文件拥有者可读可写，不可执行，同一组用户或者其他用户都不具有操作权限
        command = f'mkdir -p -m 700 ~/.ssh && \
        echo {public_key!r} >> ~/.ssh/authorized_keys && \
        chmod 600 ~/.ssh/authorized_keys'
        code, out = self.exec_command(command)
        print(f"code={code},out={out},command={command}")
        if code != 0:
            raise SSHException(f'添加公钥失败: {out}')

    def exec_command(self, command, timeout=1800, environment=None):
        # 设置执行指令过程，一旦遇到错误/异常，则直接退出操作，不再继续执行。
        command = 'set -e\n' + command
        with self as cli:
            chan = cli.get_transport().open_session()
            chan.settimeout(timeout)
            chan.set_combine_stderr(True)  # 正确和错误输出都在一个管道对象里面输出出来
            # if environment:
            #     str_env = ' '.join(f"{k}='{v}'" for k, v in environment.items())
            #     command = f'export {str_env} && {command}'
            chan.exec_command(command)
            stdout = chan.makefile("rb", -1)
            return chan.recv_exit_status(), self._decode(stdout.read())

    def _decode(self, out: bytes):
        # 解码方法[把bytes类型数据转换成普通字符]
        try:
            return out.decode()
        except UnicodeDecodeError:
            return out.decode('GBK')

    # 检测连接并获取连接
    def ping(self):
        """ping远程主机，连接成功则返回True"""

        with self: # self 实际上就是 self.get_client() 的 返回值
            print("ping......")
            return True

    def put_file(self, local_path, remote_path, callback=None):
        """
        根据本地路径上传文件到远程主机
        """
        with self as cli:
            sftp = cli.open_sftp()
            sftp.put(local_path, remote_path, callback=callback)
            sftp.close()

    def put_file_by_fl(self, fl, remote_path, callback=None):
        """
        上传文件到远程主机
        fl:文件对象(文件句柄或类文件句柄)
        remote_path: 远程主机中存储当前文件的路径
        callback: 上传文件以后的回调方法
        """
        with self as cli:
            sftp = cli.open_sftp()
            # 这里之所以上传的是文件对象的主要原因是我们api服务器上传到远程主机的文件，往往来自于客户端上传过来的。
            # 所以我们api服务器中得到的本来就是一个文件对象，因此没必要保存到api服务器，直接转发给远程主机即可
            sftp.putfo(fl, remote_path, callback=callback)
            sftp.close()

    # 从远程主机下载文件到本地
    def download_file(self, local_path, remote_path):
        """
        local_path: 指定保存下载文件的本地地址
        remote_path: 要下载文件在远程主机的路径
        """
        with self as cli:
            sftp = cli.open_sftp()
            sftp.get(remote_path, local_path)

    # 获取指定目录路径下的文件和文件夹列表详细信息,结果为列表，列表里面的每一项是from paramiko.sftp_attr import SFTPAttributes  类的对象，通过对象.属性可以获取对应的数据，比如获取修改时间用对象.st_mtime
    def list_dir_attr(self, remote_path):
        with self as cli:
            sftp = cli.open_sftp()
            return sftp.listdir_attr(remote_path)

    # 根据指定路径删除对应文件,没有对应文件会报错，有返回None
    def remove_file(self, remote_path):
        with self as cli:
            sftp = cli.open_sftp()
            sftp.remove(remote_path)

    # 删除远程主机上的目录
    def remove_dir(self, remote_path):
        with self as cli:
            sftp = cli.open_sftp()
            sftp.rmdir(remote_path)

    # 获取文件详情
    def file_stat(self, remote_path):
        with self as cli:
            sftp = cli.open_sftp()
            return sftp.stat(remote_path)

    # 直接获取连接
    def get_client(self):
        if self.client is not None:
            return self.client
        try:
            # 创建客户端连接对象
            self.client = SSHClient()
            # 在本机第一次连接远程主机时记录指纹信息
            self.client.set_missing_host_key_policy(AutoAddPolicy)
            # 建立连接
            self.client.connect(**self.arguments)
        except AuthenticationException as e:
          return None

        return self.client

    # with self: 先执行__enter__方法
    def __enter__(self):
        if self.client is not None:
            # 告知当前执行上下文，self.client已经实例化
            raise RuntimeError('已经建立连接了！！！')

        return self.get_client()
        # with self: 语句体内容结束后执行如下方法 先执行__enter__方法

    def __exit__(self, Type, value, traceback):
        self.client.close()
        self.client = None
```



#### 主机管理与免密登陆

前面我们已经完成了主机列表展示和添加了，我们实现添加主机时，新添加主机需要填写连接主机的用户名和密码，我们接下来就需要通过密码来进行主机连接验证，如果用户名和密码没有问题，那么添加到主机列表中，以后对这个主机的操作都能够完成免密操作，所以我们有两件事情要做：

1、在添加主机信息时连接一次远程主机 

2、配置公私钥进行免密登录

![image-20210116154703129](6%E4%B8%BB%E6%9C%BA%E7%AE%A1%E7%90%86.assets/image-20210116154703129.png)

模型类中新增一个方法，实现

host/models.py，代码：

```python
from hippo_api.utils.models import BaseModel,models
from users.models import User
from hippo_api.utils.ssh import SSH

class HostCategory(BaseModel):
    """主机类别"""
    class Meta:
        db_table = "hp_host_category"
        verbose_name = "主机类别"
        verbose_name_plural = verbose_name  # 取消提示文字中关于英文复数+s的情况

class Host(BaseModel):
    # 真正在数据库中的字段实际上叫 category_id，而category则代表了关联的哪个分类模型对象
    category = models.ForeignKey('HostCategory', on_delete=models.DO_NOTHING, verbose_name='主机类别', related_name='hc', null=True, blank=True)
    ip_addr = models.CharField(blank=True, null=True, max_length=500, verbose_name='连接地址')
    port = models.IntegerField(verbose_name='端口')
    # pkey = models.TextField(null=True, blank=True, default="", verbose_name="独立私钥")
    username = models.CharField(max_length=50, verbose_name='登录用户')
    users = models.ManyToManyField(User)

    class Meta:
        db_table = "hp_host"
        verbose_name = "主机信息"
        verbose_name_plural = verbose_name
    def __str__(self):
        return self.name + ':' + self.ip_addr

    def get_ssh(self, pkey=None):
        # 获取ssh连接对象
        # pkey = pkey or self.pkey
        return SSH(self.ip_addr, self.port, self.username, pkey)

# 全局密钥和共钥，所有用户都使用这个一对
class PkeyModel(BaseModel):
    name    = models.CharField(max_length=500, unique=True) # 名称
    private = models.TextField(verbose_name="私钥")
    public  = models.TextField(verbose_name="公钥")

    def __repr__(self):
        return f'<Pkey {self.name}>'
```

对PkeyModel的操作，我们简单封装2个方法用于存储和读取公私钥，方便后续操作

/utils/key.py

```python
from functools import lru_cache
from host.models import PkeyModel

class AppSetting(object):
    keys = ('public_key', 'private_key',)
    # 由于我们可能经常会执行这个get操作，所以我们使用了django的缓存机制，对方法的结果进行缓存，
    # 第二次调用 get()方法 时，并没有真正执行方法，而是直接返回缓存的结果，
    # 参数maxsize为最多缓存的次数，如果为None，则无限制，设置为2n时，性能最佳
    @classmethod
    @lru_cache(maxsize=64)
    def get(cls, name):
        info = PkeyModel.objects.filter(name=name).first()
        if not info:
            raise KeyError(f'没有这个 {name!r} 秘钥对')

        # 以元组格式，返回公私钥
        return (info.private, info.public)

    @classmethod
    def set(cls, name, private_key, public_key, description=None):
        """保存公私钥"""
        PkeyModel.objects.update_or_create(name=name, defaults={
            'private': private_key,
            'public': public_key,
            'description': description
        })
```

为了方便校验用户输入过来的主机连接信息是否正确，我们封装一个函数用来测试。

/utils/check_ssh.py

```python
from .ssh import SSH

# 用户第一次创建连接某台主机时，校验连接信息的
def valid_ssh(hostname, port, username, password=None):
    try:
        print(hostname, port, username, password)
        _cli = SSH(hostname, port, username, password=str(password))
        _cli.ping() #测试该链接是否能够使用

    except Exception:
        return False
    return True
```

序列化器，`host/serializers.py`，代码：

```python
from rest_framework import serializers
from . import models
from hippo_api.utils.check_ssh import valid_ssh
from hippo_api.utils.ssh import SSH
from hippo_api.utils.key import AppSetting
from django.conf import settings

class HostCategoryModelSeiralizer(serializers.ModelSerializer):
    """主机分类的序列化器"""
    class Meta:
        model = models.HostCategory
        fields = ['id', 'name']


class HostModelSerializers(serializers.ModelSerializer):
    """主机信息的序列化器"""
    category_name = serializers.CharField(source='category.name', read_only=True)
    password = serializers.CharField(max_length=32, write_only=True, label="登录密码")

    class Meta:
        model = models.Host
        fields = ['id', 'category', 'category_name', 'name', 'ip_addr', 'port', 'description', 'username', 'password']

    def validate(self, attrs):
        """当用户添加、编辑主机信息会自动执行这个方法"""
        ip_addr = attrs.get('ip_addr')
        port = attrs.get('port')
        username = attrs.get('username')
        password = attrs.get('password')

        # 验证主机信息是否正确
        ret = valid_ssh(ip_addr, port, username, password)
        if not ret:
            raise serializers.ValidationError('参数校验失败，请检查输入的主机信息!')

        return attrs


    # 添加host记录，如果第一次添加host记录，那么需要我们生成全局的公钥和私钥
    def create(self, validated_data):
        ip_addr = validated_data.get('ip_addr')
        port = validated_data.get('port')
        username = validated_data.get('username')
        password = validated_data.get('password')

        # 生成公私钥和管理主机的公私钥
        # 创建公私钥之前，我们先看看之前是否已经创建过公私钥了
        _cli = SSH(ip_addr, port, username, password=str(password))
        try:
            # 尝试从数据库中提取公私钥
            private_key, public_key = AppSetting.get(settings.DEFAULT_KEY_NAME)
        except KeyError as e:
            # 没有公私钥存储到数据库中，则生成公私钥
            private_key, public_key = _cli.generate_key()
            # 将公钥和私钥保存到数据库中
            AppSetting.set(settings.DEFAULT_KEY_NAME, private_key, public_key, 'ssh全局秘钥对')

        # 上传公钥到服务器中
        try:
            _cli.add_public_key(public_key)
        except Exception as e:
            raise serializers.ValidationError('添加远程主机失败，请检查输入的主机信息!')

        raise serializers.ValidationError('测试!')
        # 剔除密码字段，保存host记录
        validated_data.pop('password')
        instance = models.Host.objects.create(
            **validated_data
        )
        return instance
```

我们使用上面的演示parmiko工具类的例子1来测试上面是否已经建立了免密登陆。

`paramiko1.py`，代码：

```python
# 因为接下来，我们需要调用django中的模型代码，所以再此对django引入并初始化
import django, os
from django.conf import settings
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'hippo_api.settings.dev')
django.setup()

import paramiko
import traceback
from paramiko.ssh_exception import AuthenticationException
from host.models import PkeyModel
from paramiko.rsakey import RSAKey
from io import StringIO


if __name__ == '__main__':


    # 通过parammiko创建一个ssh短连接客户端实例对象
    ssh = paramiko.SSHClient()
    # 自动在本机第一次连接远程服务器时，记录主机指纹
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    try:
        # 1. 直接密码远程连接的方式
        # ssh.connect(hostname='47.98.130.212', port=22, username='root', password='123', timeout=10)
        # 注意，如果你测试某个服务器的连接时，如果你本地已经配置了这个远程服务器的免密登录(公私钥模式)，那么就不能测试出密码是否正确了，因为首先会通过公私钥模式登录，不会使用你的密码的。

        # 2. 使用秘钥免密登录的方式
        pkey = PkeyModel.objects.get(name=settings.DEFAULT_KEY_NAME).private
        pkey = RSAKey.from_private_key(StringIO(pkey))
        ssh.connect(hostname='47.98.130.212', port=22, username='root', pkey=pkey, timeout=10)

        # 连接成功以后，就可以发送操作指令
        # stdin 输入[本机发送给远程主机的信息]
        # stdout 输出[远程主机返回给本机的信息]
        # stderr 错误
        stdin, stdout, stderr = ssh.exec_command('ls -la')
        # 读取stdout对象中返回的内容，返回结果bytes类型数据
        result = stdout.read()
        print( result.decode() )
        # 关闭连接
        ssh.close()
    except AuthenticationException as e:
        print(e.message)
        print(traceback.format_exc())
```



#### 批量导入主机数据

等我们写完下面的页面效果之后，应该添加一个模板文件下载的按钮

```html
<a href="../../static/file/主机导入模板.xls" download="主机导入模板.xls">主机导入模板.xlsx</a>
download='自定义下载文件的名称'
```

在前端项目的static/file目录下存放我们的一个模板.xlsx文件，在我们该笔记的项目所需静态资源文件夹中了

##### 前端实现批量上传主机列表的界面

components/Host.vue，代码：

```vue
<template>
    <div class="host">
      <a-card size="small" :bordered="false">
        <a-row>
          <a-col :span="6">
            <a-form-item label="主机类别：" :label-col="formItemLayout.labelCol" :wrapper-col="formItemLayout.wrapperCol">
              <a-select style="width: 120px;" placeholder="请选择" @change="handleSelectChange" v-model="host_form.form.category">
                <a-select-option :value="value.id" v-for="(value, index) in categorys" :key="value.id">
                  {{value.name}}
                </a-select-option>
              </a-select>
            </a-form-item>
          </a-col>
          <a-col :span="6">
            <a-form-item :label-col="formItemLayout.labelCol" :wrapper-col="formItemLayout.wrapperCol" label="主机别名：">
              <a-input placeholder="请输入"/>
            </a-form-item>
          </a-col>
          <a-col :span="6">
            <a-form-item :label-col="formItemLayout.labelCol" :wrapper-col="formItemLayout.wrapperCol" label="连接地址：" >
              <a-input v-decorator="['nickname', { rules: [{ required: checkHost, message: 'Please input your nickname' }] }, ]" placeholder="请输入"/>
            </a-form-item>
          </a-col>
          <a-col :span="6">
            <router-link to="/workbench">
              <a-button type="primary" icon="sync" style="margin-top: 3px;">
                刷新页面
              </a-button>
            </router-link>
          </a-col>
        </a-row>

        <div class="add_host" style="margin-bottom: 15px;">
          <a-button type="primary" icon="plus" @click="showModal">
            新建
          </a-button>
          <a-button type="primary" icon="import" @click="showExcelModal" style="margin-left: 20px;">
            批量导入
          </a-button>
        </div>
        <!-- 新增主机 -->
        <a-modal
          :width="800"
          title="新建主机"
          :visible="visible"
          :confirm-loading="confirmLoading"

          @cancel="handleCancel"
        >
          <template slot="footer">
            <a-button key="back" @click="handleCancel">取消</a-button>
            <a-button key="submit" type="primary" :loading="loading" @click="onSubmit">验证</a-button>
          </template>
          <a-form-model ref="ruleForm" :model="host_form.form" :rules="host_form.rules" :label-col="host_form.labelCol" :wrapper-col="host_form.wrapperCol">

            <a-form-model-item label="主机类别" prop="zone">
              <a-row>
                <a-col :span="12">
                  <a-select v-model="host_form.form.category" placeholder="请选择主机类别/区域/分组">
                    <a-select-option :value="value.id" v-for="(value, index) in categorys" :key="value.id">
                    {{value.name}}
                    </a-select-option>
                  </a-select>
                </a-col>
                <a-col :span="5" :offset="2">
                  <button type="button" class="ant-btn ant-btn-link"><span>添加类别</span></button>
                </a-col>
                <a-col :span="5">
                  <button type="button" class="ant-btn ant-btn-link"><span>编辑类别</span></button>
                </a-col>
              </a-row>
            </a-form-model-item>
            <a-form-model-item ref="name" label="主机名称" prop="name">
              <a-row>
                <a-col :span="24">
                  <a-input placeholder="请输入主机名称" v-model="host_form.form.name"/>
                </a-col>
              </a-row>
            </a-form-model-item>

            <a-form-model-item ref="ip_addr" label="连接地址" prop="ip_addr">
              <a-row>
                <a-col :span="8">
                  <a-input placeholder="用户名" addon-before="ssh" v-model="host_form.form.username"/>
                </a-col>
                <a-col :span="8">
                  <a-input placeholder="ip地址" addon-before="@" v-model="host_form.form.ip_addr"/>
                </a-col>
                <a-col :span="8">
                  <a-input placeholder="端口号" addon-before="-p" v-model="host_form.form.port"/>
                </a-col>
              </a-row>
            </a-form-model-item>

            <a-form-model-item ref="password" label="连接密码" prop="password">
              <a-row>
                <a-col :span="24">
                  <a-input placeholder="请输入连接密码" v-model="host_form.form.password" type="password"/>
                </a-col>
              </a-row>
            </a-form-model-item>

            <a-form-model-item extra="默认使用全局密钥，如果上传了独立密钥则优先使用该密钥。" ref="name" label="独立秘钥" prop="pkey">
              <a-row>
                <a-col :span="24">
                  <a-upload name="file" :multiple="true" action="上传文件的地址" :headers="upload_pkey_headers" @change="handleFileChange">
                    <a-button>
                      <a-icon type="upload"/>
                      点击上传
                    </a-button>
                  </a-upload>
                </a-col>
              </a-row>
            </a-form-model-item>
            <a-form-model-item ref="description" label="备注信息" prop="description">
              <a-row>
                <a-col :span="24">
                  <a-textarea v-model="host_form.form.description" placeholder="请输入主机备注信息" :auto-size="{ minRows: 3, maxRows: 5 }"/>
                </a-col>
              </a-row>
            </a-form-model-item>

            <a-form-model-item>
              <a-row>
                <a-col :span="24" :offset="10">
                  <span>
                    <a-icon type="warning" style="color:yellow;"/>
                    首次验证时需要输入登录用户名对应的密码，但不会存储该密码。
                  </span>
                </a-col>
              </a-row>
            </a-form-model-item>
          </a-form-model>
        </a-modal>
        <!-- 批量导入主机 -->
         <div class="excel_push_modal">
          <a-modal v-model="excel_model_visible" title="批量导入主机信息" on-ok="handleUploadExcel" width="800px">
            <template slot="footer">
              <a-button key="back" @click="handleUploadExcelCancel">取消</a-button>
              <a-button type="primary" :disabled="excel_fileList.length === 0" :loading="excel_uploading" style="margin-top: 16px" @click="handleExcelUpload">{{ excel_uploading ? '上传处理中...' : '开始上传' }}</a-button>
            </template>
            <div>
              <a-alert type="info" message="导入或输入的密码仅作首次验证使用，并不会存储密码。" banner closable/><br/>
              <a-form :form="upload_excel_form">
                <a-form-item :label-col="formItemLayout.labelCol" :wrapper-col="formItemLayout.wrapperCol" label="模板下载" help="请下载使用该模板填充数据后导入">
                <a href="../../static/主机导入模板.xls" download="主机导入模板.xls">主机导入模板.xls</a>
                </a-form-item>
                <a-form-item :label-col="formItemLayout.labelCol" :wrapper-col="formItemLayout.wrapperCol" label="默认密码" help="如果Excel中密码为空则使用该密码">
                <a-input v-model="default_password" placeholder="请输入默认主机密码"/></a-form-item>
                <a-form-item :label-col="formItemLayout.labelCol" :wrapper-col="formItemLayout.wrapperCol" label="导入数据">
                  <div class="clearfix">
                    <a-upload :file-list="excel_fileList" :remove="handleExcelRemove" :before-upload="beforeExcelUpload" v-decorator="[ 'host_excel', { rules: [{ required: true, message: '请上传文件' }] }, ]">
                      <a-button><a-icon type="upload"/>选择上传的文件</a-button>
                    </a-upload>
                  </div>
                </a-form-item>
              </a-form>
            </div>
          </a-modal>
        </div>
        <!-- 主机列表 -->
        <a-table :columns="columns" :data-source="data" rowKey="id">
          <a slot="name" slot-scope="text">{{ text }}</a>
          <template v-slot:action>
            <a href="javascript:;">编辑</a> |
            <a href="javascript:;">删除</a> |
            <a href="javascript:;">Console</a>
          </template>
        </a-table>
      </a-card>
    </div>
</template>

<script>
  const formItemLayout = {
    labelCol: {span: 8},
    wrapperCol: {span: 12},
  };

    const columns = [
    {
      title: '类别',
      dataIndex: 'category_name',
      key: 'category_name',
    },
    {
      title: '主机名称',
      dataIndex: 'name',
      key: 'name',
      sorter: true,

    },
    {
      title: '连接地址',
      dataIndex: 'ip_addr',
      key: 'ip_addr',
      ellipsis: true,
      sorter: true,
      width: 200,
    },
    {
      title: '端口',
      dataIndex: 'port',
      key: 'port',
      ellipsis: true,
    },
    {
      title: '备注信息',
      dataIndex: 'description',
      key: 'description',
      ellipsis: true,
    },

    {
      title: '操作',
      key: 'action',
      width: 200,
      scopedSlots: {customRender: 'action'},
    },
  ];

  export default {
    name: "Host",
    data(){
      return {
        loading: false,
        formItemLayout,   // formItemLayout: formItemLayout,
        checkHost: false, // 是否验证信息
        visible: false,   // 是否显示添加主机的弹窗
        confirmLoading: false,
        categorys: [     // 主机类别

        ],
        data: [
          // {"id":1, "category_name":"数据库服务器","name":"iZbp1b1jw4l12ho53ivhkkZ","ip_addr":"47.98.130.212","port":22,"description":""},
          // {"id":2, "category_name":"数据库服务器","name":"iZbp1b1jw4l12ho53ivhkkZ","ip_addr":"47.98.130.212","port":22,"description":""},
          // {"id":3, "category_name":"数据库服务器","name":"iZbp1b1jw4l12ho53ivhkkZ","ip_addr":"47.98.130.212","port":22,"description":""},
          // {"id":4, "category_name":"数据库服务器","name":"iZbp1b1jw4l12ho53ivhkkZ","ip_addr":"47.98.130.212","port":22,"description":""},
        ],
        columns:columns, // 表格的表头信息
        // 上传文件的配置参数
        upload_pkey_headers: {
          authorization: 'authorization-text',
        },
        // 添加主机需要的数据属性
        host_form: {
          labelCol: {span: 6},
          wrapperCol: {span: 14},
          other: '',
          form: {
            name: '',
            category: '',
            ip_addr: '',
            username: '',
            port: '',
            description: '',
            password:'',
          },
          rules: {
            name: [
              {required: true, message: '请输入主机名称', trigger: 'blur'},
              {min: 3, message: '长度在3-20位之间', trigger: 'blur'},
            ],
            password: [
              {required: true, message: '请输入连接密码', trigger: 'blur'},
              {min: 3, max: 20, message: '长度在3-10位之间', trigger: 'blur'},
            ],
            category: [{required: true, message: '请选择类别', trigger: 'change'}],
            username: [
              {required: true, message: '请输入用户名', trigger: 'blur'},
              {min: 3, max: 20, message: '长度在3-10位', trigger: 'blur'},
            ],

            ip_addr: [
              {required: true, message: '请输入连接地址', trigger: 'blur'},
              {max: 50, message: '长度最大15位', trigger: 'blur'},
            ],

            port: [
              {required: true, message: '请输入端口号', trigger: 'blur'},
              {max: 5, message: '长度最大5位', trigger: 'blur'},
            ],
          },
        },
        excel_model_visible: false, // 批量导入主机的窗口显示和隐藏
        excel_fileList: [],  // 等待上传的xls文件列表
        excel_uploading: false, // 显示当前上传文件组件是否属于上传文件过程中的状态
        default_password: "",   // 默认上传的主机列表的通用登录密码
        upload_excel_form: this.$form.createForm(this, {name: 'coordinated'}),
      }
    },
    created(){
        // ajax获取数据
        this.get_categorys()
        this.get_host_list()
    },
    methods:{
      showExcelModal(){
        // 显示批量上传主机的窗口
        this.excel_model_visible = true
      },
      handleUploadExcelCancel() {
        // 关闭批量上传主机的窗口
        this.excel_model_visible = false;
      },
      beforeExcelUpload(file){
        // 当用户选择上传文件以后，需要手动把当前文件添加到待上传文件列表this.excel_fileList中
        this.excel_fileList = [...this.excel_fileList, file];
        return false;
      },
      handleExcelRemove(file){
        // 当用户要删除待上传文件列表中指定的文件时
        const index = this.excel_fileList.indexOf(file);
        const newFileList = this.excel_fileList.slice();
        newFileList.splice(index, 1);
        this.excel_fileList = newFileList;
      },
      handleExcelUpload(e){
        // 上传execl文件的处理函数
        console.log("excel_fileList =", this.excel_fileList)
        // 整理要上传到服务端的数据对象[上传文件列表和默认密码]
        const formData = new FormData();
        this.excel_fileList.forEach(file => {
            formData.append('host[]', file);
        });
        formData.append("default_password", this.default_password)
        this.excel_uploading = true;
        // ajax提交
        let token = sessionStorage.token || localStorage.token;
        this.$axios.post(`/host/host_excel`,formData,{
            headers:{
              Authorization: "jwt "+token
            }
        }).then(response=>{
          console.log(response.data)
        }).catch(error=>{
          console.log(error)
        })
      },
      get_host_list(){
        let token = sessionStorage.token || localStorage.token || "";
        // 获取主机列表
        this.$axios.get(`/host/host`,{
          headers:{
            Authorization: "jwt " + token,
          }
        }).then(response=>{
          this.data = response.data
        }).catch(error=>{
          this.$message.error("主机列表获取失败！")
        })
      },
      get_categorys(){
        // 获取主机类别
        let token = sessionStorage.token || localStorage.token || "";
        this.$axios.get(`/host/category`,{
          headers:{
            Authorization: "jwt " + token,
          }
        }).then(response=>{
          this.categorys = response.data
        }).catch(error=>{
          this.$message.error("主机类别获取失败！")
        })
      },
      handleSelectChange(value) {
        console.log(value);
      },
      showModal() {
        // 显示添加主机的表单窗口
        this.visible = true;
      },
      handleCancel(e) {
        // 表单取消
        this.resetForm(); //清空表单内容

        this.visible = false; // 关闭对话框
      },
      onSubmit(){
        this.$refs.ruleForm.validate(valid => {
          // 验证通过则发送请求
          if (valid) {
              let token = sessionStorage.token || localStorage.token || "";
              // 将数据提交到后台进行保存，但是先进行连接校验，验证没有问题，再保存
              this.$axios.post(`${this.$settings.host}/host/host/`,{
                    "name":this.host_form.form.name,
                    "category":this.host_form.form.category,
                    "ip_addr":this.host_form.form.ip_addr,
                    "description":this.host_form.form.description,
                    "port":this.host_form.form.port,
                    "username":this.host_form.form.username,
                    "password":this.host_form.form.password,
              },{
                headers:{
                  Authorization: "jwt " + token,
                }
              }).then(response=>{
                  // 在现有的主机列表，追加新增的主机列表
                  this.data.unshift(response.data);
                  this.handleCancel();
              }).catch(error=>{
                  this.$message.error("添加主机失败！");
              })

          } else {
            // 验证失败！
            return false;
          }
        });
      },
      handleFileChange(info){
        if (info.file.status !== 'uploading') {
          console.log(info.file, info.fileList);
        }
        if (info.file.status === 'done') {
          this.$message.success(`${info.file.name} 上传成功`);
        } else if (info.file.status === 'error') {
          this.$message.error(`${info.file.name} 上传失败`);
        }
      },
      resetForm(){
         // 重置添加主机的表单信息
         this.$refs.ruleForm.resetFields();
      }
    }
  }
</script>

<style scoped>

</style>
```

因为上传文件处理的时间会比较长，所以我们不能设置ajax的请求超时为2.5秒了。否则很容易导致ajax上传文件时因为超时而中断。main.js，代码：

```javascript
import axios from "axios"
axios.defaults.withCredentials = false;     // 是否在ajax请求时允许携带cookie到服务端
axios.defaults.baseURL = settings.host;     // 设置服务端api的域名
axios.defaults.timeout = 30000;             // 请求超时的时间
```

##### 后端实现批量导入主机列表并验证入库

host/urls.py

```python
    path("host_excel", views.HostExcelView.as_view()),
```

我们需要借助python操作excel的模块

```python
pip install xlrd xlwt #  xlrd 读取excel xlwt 写入excel
```

Host/views.py

```python
from rest_framework.views import APIView
from rest_framework.response import Response
from io import BytesIO
from .utils import read_host_excel_data
class HostExcelView(APIView):
    permission_classes = [IsAuthenticated]
    def post(self,request):
        """批量导入主机列表"""
        # 接受客户端上传的数据
        host_excel = request.data.get("host[]")
        default_password = request.data.get("default_password")

        # 把上传文件全部写入到字节流，就不需要保存到服务端硬盘了。
        sio = BytesIO()
        for i in host_excel:
            sio.write(i)

        data = read_host_excel_data(sio, default_password)

        return Response(data)
```

我们封装一个host数据excel文件读取的函数，host/utils.py

```python
import xlrd
from .models import HostCategory
from .serializers import HostModelSerializers

def read_host_excel_data(host_excel_file_path, default_password=''):
    """
    从excel中读取主机列表信息
    host_excel_file_path: 主机列表的字节流
    default_password: 主机的默认登录密码
    """
    # 打开xls文件
    data = xlrd.open_workbook(file_contents=host_excel_file_path.getvalue())
    # 根据索引获取第一个sheet工作簿
    sheet = data.sheet_by_index(0)
    # 获取当前工作博的数据的总行数
    rows_count = sheet.nrows
    # 查询出数据库现有的所有分类数据[ID，name]
    category_list = HostCategory.objects.values_list('id', 'name')

    # 主机列表
    host_info_list = []

    for row_number in range(1, rows_count): # 从第二行(下标为1)开始读取xls数据，因为首行是表头信息
        one_row_dict = {} # 单个主机信息
        # print(sheet.cell(row_number, 0))  # 单元格的数据类型和数据值一起获取，  参数：(行号，列号)
        # print(sheet.cell_type(row_number, 0))  # 获取单元格的数据类型，       参数：(行号，列号)
        # print(sheet.cell_value(row_number, 0)) # 获取单元格的数据值
        category = sheet.cell_value(row_number, 0)

        # 由于拿到的是分类名称，所以我们要找到对应名称的分类id，才能去数据库里面存储
        for category_data in category_list:
            # print(category_data[1],type(category_data[1]),category,type(category))
            if category_data[1].strip() == category.strip():
                one_row_dict['category'] = category_data[0]
                break

        # 注意：数据列要对应
        one_row_dict['name'] = sheet.cell_value(row_number, 1)      # 主机别名
        one_row_dict['ip_addr'] = sheet.cell_value(row_number, 2)   # 主机地址
        one_row_dict['port'] = int(sheet.cell_value(row_number, 3)) # 主机端口号
        one_row_dict['username'] = sheet.cell_value(row_number, 4)  # 登录账户名

        excel_pwd = sheet.cell_value(row_number, 5)
        try:
            pwd = str(excel_pwd)      # 这样强转容易报错，最好捕获一下异常，并记录单元格位置，给用户保存信息时，可以提示用户哪个单元格的数据有问题
        except:
            pwd = default_password

        if not pwd.strip():
            pwd = default_password

        one_row_dict['password'] = pwd
        one_row_dict['description'] = sheet.cell_value(row_number, 6)

        host_info_list.append(one_row_dict)

    # 校验主机数据
    # 将做好的主机信息字典数据通过我们添加主机时的序列化器进行校验
    res_data = {}  # 存放上传成功之后需要返回的主机数据和某些错误信息数据
    serializers_host_res_data = []
    res_error_data = []

    for k, host_data in enumerate(host_info_list):
        # 反序列化校验每一个主机信息
        serailizer = HostModelSerializers(data=host_data)
        if serailizer.is_valid():
            new_host_obj = serailizer.save()
            serializers_host_res_data.append(new_host_obj)
        else:
            # 报错，并且错误信息中应该体验错误的数据位置
            res_error_data.append({'error': f'该{k + 1}行数据有误,其他没有问题的数据，已经添加成功了，请求失败数据改完之后，重新上传这个错误数据，成功的数据不需要上传了'})

    # 再次调用序列化器进行数据的序列化，返回给客户端
    serializer = HostModelSerializers(instance=serializers_host_res_data, many=True)
    res_data['data'] = serializer.data
    res_data['error'] = res_error_data

    return res_data
```

##### 客户端接收服务端返回结果并显示到页面

`components/Host.vue`，代码：

```javascript
handleExcelUpload(e){
        // 上传execl文件的处理函数
        console.log("excel_fileList =", this.excel_fileList)
        // 整理要上传到服务端的数据对象[上传文件列表和默认密码]
        const formData = new FormData();
        this.excel_fileList.forEach(file => {
            formData.append('host[]', file);
        });
        formData.append("default_password", this.default_password)
        this.excel_uploading = true;
        // ajax提交
        let token = sessionStorage.token || localStorage.token;
        this.$axios.post(`/host/host_excel`,formData,{
            headers:{
              Authorization: "jwt "+token
            }
        }).then(response=>{
          // 把本地的主机列表数组和服务端返回的数组列表进行合并产生一个新的主机列表数组
          this.data = this.data.concat(response.data.data);
          this.excel_uploading = false; // 退出登录处理状态
          this.$message.success('上传成功');
          if (response.data.error.length > 0){
              this.$message.error('上传的数据有存在错误！');
          }else{
              this.excel_model_visible = false;
          }
        }).catch(error=>{
            this.excel_uploading = false;
            this.$message.error('上传文件处理失败！');
        })
      },
```



#### 导出Excel主机列表数据

##### 前端vue实现

下载文件在客户端中就是a标签的效果就可以完成。给a标签的href指定下载文件的地址，并通过download来设置下文件的文件名即可。

```html
        <div class="add_host" style="margin-bottom: 15px;">
          <a-button type="primary" icon="plus" @click="showModal">
            新建
          </a-button>
          <a-button type="primary" icon="import" @click="showExcelModal" style="margin-left: 20px;">
            批量导入
          </a-button>
          <a-button type="primary" icon="export" :href="`${$settings.host}/host/host_excel`" download="主机列表数据.xls" style="margin-left: 20px;">
            批量导出
          </a-button>
        </div>
```

##### 服务端实现主机列表数据的导出

host/urls.py

```python
urlpatterns = [
		....
    path("host_excel", views.HostExcelView.as_view()),
]
```

host/views.py

```python
# Create your views here.
from rest_framework.generics import ListAPIView,CreateAPIView
from rest_framework.viewsets import ModelViewSet
from .models import HostCategory,Host
from .serializers import HostCategoryModelSeiralizer,HostModelSerializers
from rest_framework.permissions import IsAuthenticated

class HostCategoryListAPIView(ListAPIView, CreateAPIView):
    queryset = HostCategory.objects.filter(is_show=True, is_deleted=False).order_by("orders","-id").all()
    serializer_class = HostCategoryModelSeiralizer
    permission_classes = [IsAuthenticated]

class HostModelViewSet(ModelViewSet):
    queryset = Host.objects.all()
    serializer_class = HostModelSerializers
    permission_classes = [IsAuthenticated]


import xlwt
from rest_framework.views import APIView
from rest_framework.response import Response
from io import BytesIO
from .utils import read_host_excel_data
from django.http.response import HttpResponse
from django.utils.encoding import escape_uri_path

class HostExcelView(APIView):
    permission_classes = [IsAuthenticated]
	# 中间代码省略....

    def get(self,request):
        # 1 读取数据库数据
        all_host_data = Host.objects.all().values('id', 'category', 'name', 'ip_addr', 'port', 'username',
                                                         'description')

        # 2 写入excel并保存
        # 创建excel
        xls = xlwt.Workbook(encoding='utf-8')
        # 创建工作簿
        sheet = xls.add_sheet('主机数据列表')
        # 给工作簿首行写入表头
        sheet.write(0, 0, 'id')
        sheet.write(0, 1, 'category')
        sheet.write(0, 2, 'name')
        sheet.write(0, 3, 'ip_addr')
        sheet.write(0, 4, 'port')
        sheet.write(0, 5, 'username')
        sheet.write(0, 6, 'description')

        # 写入数据，从第一行开始
        excel_row = 1 # 因为表头已经占据了下标为1的首行，所以此处从下标1开始写入主机数据
        for host_obj in all_host_data:
            sheet.write(excel_row, 0, host_obj.get('id'))
            sheet.write(excel_row, 1, host_obj.get('category'))
            sheet.write(excel_row, 2, host_obj.get('name'))
            sheet.write(excel_row, 3, host_obj.get('ip_addr'))
            sheet.write(excel_row, 4, host_obj.get('port'))
            sheet.write(excel_row, 5, host_obj.get('username'))
            sheet.write(excel_row, 6, host_obj.get('description'))
            excel_row += 1

        # 将数据写入io数据流，不用在本地生成excel文件，不然效率就低了
        sio = BytesIO()
        xls.save(sio)
        sio.seek(0)

        # 3 将excel数据响应回客户端
        response = HttpResponse(sio.getvalue(), content_type='application/vnd.ms-excel')

        # 3.1 文件名称中文设置
        response['Content-Disposition'] = 'attachment; filename={}'.format(escape_uri_path('主机列表数据.xls'))
        response.write(sio.getvalue())  # 必须要给response写入一下数据，不然不生效
        return response
```



#### console功能实现

![image-20210118163940082](6%E4%B8%BB%E6%9C%BA%E7%AE%A1%E7%90%86.assets/image-20210118163940082.png)

前端的终端效果我们使用xterm.js来完成。

##### Xterm.js的安装和使用

vue中使用xterm，要在客户端项目根目录下进行安装

```shell
npm install xterm
```

xterm.js初始化

在main.js文件中加上如下内容

```js
import 'xterm/css/xterm.css'
import 'xterm/lib/xterm'
```

在Host.vue中，主机列表后面的console对应的地址，实现参数跳转。

```vue
        <!-- 主机列表 -->
        <a-table :columns="columns" :data-source="data" rowKey="id">
          <span slot="action" slot-scope="record">
            <a href="javascript:;">编辑</a> |
            <a href="javascript:;">删除</a> |
            <router-link :to="`/hippo/console/${record.id}`">Console</router-link>
          </span>
        </a-table>
```

创建Console.vue组件

```vue
<template>
  <div class="console">
    <div id="terminal"></div>
  </div>
</template>

<script>
import { Terminal } from 'xterm'
export default {
  name: "Console",
  mounted() {
    this.show_terminal()
  },
  methods:{
    show_terminal(){
      // 初始化terminal窗口
       var term = new Terminal({
           rendererType: "canvas", //渲染类型
           rows: 40, //行数
           convertEol: true, // 启用时，光标将设置为下一行的开头
           scrollback: 100,   // 终端中的回滚量
           disableStdin: false, //是否应禁用输入。
           cursorStyle: 'underline', //光标样式
           cursorBlink: true, //光标闪烁
           theme: {
             foreground: '#ffffff', //字体
             background: '#060101', //背景色
             cursor: 'help',//设置光标
           }
       });

       term.open(document.getElementById('terminal'));

    }
  }
}
</script>

<style scoped>

</style>
```

路由注册，代码：

```javascript
import Host from '@/components/Host'
import Console from '@/components/Console'

const router = new Router({
  mode: "history",
  routes: [
    {
      path: '/',
      name: 'Login',
      component: Login,
    },
    {
      path: '/hippo',
      name: 'Base',
      component: Base,
      children: [
        {
          path: 'workbench',  // 访问路径： 父级路由 + 当前路由
          name: 'ShowCenter',
          component: ShowCenter,
        },
        {
          path: 'host',
          name: 'Host',
          component: Host,
        },
        {
          path: 'console/:id',
          name: 'Console',
          component: Console,
        },
      ]
    },

  ]
})
```



##### 服务端接收websocket请求(channels)

django没有原生支持的websocket模块，所以我们通过dwebsocket或者channels来完成。

安装channels

```shell
pip install channels==2.3.1
pip install channels-redis==2.4.1

注意版本要低于3.8版本，因为我们现在使用的django2.2版本，所以在集成channels的时候，python是3.6以下。
并非python3.8不支持chanenls，而是channels在新版本中不支持django2.2版本。
conda create -n hippo2 python=3.6
conda install pymysql -c conda-forge
pip install --upgrade pip
pip install django djangorestframework djangorestframework-jwt django-cors-headers pillow xlrd xlwt django-simpleui paramiko pycrypto  -i https://pypi.douban.com/simple

修复错误：
1. host.PkeyModel.name: (mysql.E001) MySQL does not allow unique CharFields to have a max_length > 255.
   max_length > 255
   错误信息如果出现了这个内容，则表示我们设置的模型的字符串字段长度必须在255以内。
   
   
2. 'str' object has no attribute 'decode'
   找到最后报错的文件的这个decode改成encode
   /home/moluo/anaconda3/envs/hippo/lib/python3.6/site-packages/django/db/backends/mysql/operations.py
   # query = query.decode(errors='replace')
   query = query.encode(errors='replace')
```

配置channel

```python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',

    'users',

    'rest_framework',
    'channels',

    'xadmin',
    'crispy_forms',
    'reversion',
    'corsheaders',

]

# 配置channel的通道层
CHANNEL_LAYERS = {
    'default': {
        'BACKEND': 'channels_redis.core.RedisChannelLayer',
        'CONFIG': {
            "hosts": [('127.0.0.1', 6379)], #需修改
        },
    },
}

# 在host应用下面创建一个routing.py文件
ASGI_APPLICATION = 'host.routing.application'
```

host/routing.py文件  `请求来之后的第一步`

```python
from channels.routing import ProtocolTypeRouter, ChannelNameRouter


# ProtocolTypeRouter 根据不同的请求协议，分发到不同的协议处理系统，如果是websocket协议，那么自动找routing.ws_router进行路由转发，如果是channel，那么通过executors.SSHExecutor路由进行转发，如果是http协议，那么还是按照之前的方式进行分发
# from consumer import routing # 这里类似原来的http编写代码时的路由，只是当时的路由信息，填写在了urls,而接下来，我们要编写websocket的路由，则写在routing，模块下

application = ProtocolTypeRouter({
    # 'websocket': routing.ws_router
})
```

我们单独创建一个应用来存放我们的业务处理文件

```python
cd hippo_api/apps
python ../../manage.py startapp consumer
```

配置应用

```python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'host.apps.HostConfig',
    'users',
    'consumer',

    'rest_framework',
    'channels',

    'xadmin',
    'crispy_forms',
    'reversion',
    'corsheaders',

]
```

在consumer应用下面我们创建一个路由文件，consumer/routing.py  。

```python
from django.urls import path
from channels.routing import URLRouter
from consumer.middleware import AuthMiddleware
from consumer.consumers import *

# 由于我们可能会对websocket请求进行一些验证或者身份认证，所以我们在consumer应用下面在创建一个middleware文件，里面可以配置一些认证规则
ws_router = AuthMiddleware(
    URLRouter([
        # path('ws/exec/<str:token>/', ExecConsumer),
        path('ws/ssh/<int:id>/', SSHConsumer),
    ])
)


```

可以创建一个中间件，用于判断和识别用户身份并完成一些权限相关的操作。

consumer/middleware.py   `请求来之后的第二步`

```python
class AuthMiddleware:
    def __init__(self, application): # 在用户请求进入路由分发之前自动执行，项目刚启动
        self.application = application
        print('AuthMiddleware>>>>>>', self.application)
        print(self)

    def __call__(self, scope): # 每一次客户端请求都会经过这里。可以用户验证用户的权限
        print('AuthMiddleware>>>>>>call方法执行了', scope)
        # scope中封装了本次请求的所有信息
        return self.application(scope)
```

上面的SSHConsumer是我们的websocket请求处理类，也可以理解是websocket的视图类，我们写到下面的文件中

consumer/consumers.py

```python
# websocket的视图类代码
# channels中所有的webscoetk视图类，都必须直接或间接继承于WebsocketConsumer
from channels.generic.websocket import WebsocketConsumer
from host.models import Host
from threading import Thread
from hippo_api.utils.key import AppSetting
from django.conf import settings

class SSHConsumer(WebsocketConsumer):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.id = self.scope['url_route']['kwargs']['id']
        # websocket通讯的管道对象
        self.chan = None
        # 这就是基于paramiko连接远程服务器时的ssh操作对象
        self.ssh = None

    # 3 接受连接返回结果并返回给客户端    # 5 接受主机指令的执行结果，并返回给客户端
    def loop_read(self):

        while True:
            data = self.chan.recv(32 * 1024)
            if not data:
                self.close(3333)
                break
            self.send(data.decode())

    #4 结果客户端发送过来的指令，并发送给主机执行指令
    def receive(self, text_data=None, bytes_data=None):
        data = text_data or bytes_data
        print('receive:  xxxxxx',data,type(data))
        if data:
            self.chan.send(data+'\r\n')

    def disconnect(self, code):
        """websocket断开连接以后，服务端这边也要和远程主机关闭ssh通信"""
        self.chan.close()
        self.ssh.close()
        print('Connection close')

    # 1 请求来了自动触发父类connect方法，我们继承拓展父类的connect方法，因为我们和客户端建立连接的同时，就可以和客户端想要操作的主机建立一个ssh连接通道。
    def connect(self):
        print('connect连接来啦')
        self.accept()  # 建立websocket连接，进行连接的三次握手
        self._init()   # 建立和主机的ssh连接

    # 2 建立和主机的ssh连接
    def _init(self):
        # self.send(bytes_data=b'Connecting ...\r\n')
        self.send('Connecting ...\r\n')
        host = Host.objects.filter(pk=self.id).first()
        if not host:
            self.send(text_data='Unknown host\r\n')
            self.close()
        try:
            primary_key, public_key = AppSetting.get(settings.DEFAULT_KEY_NAME)
            self.ssh = host.get_ssh(primary_key).get_client()

        except Exception as e:
            self.send(f'Exception: {e}\r\n')
            self.close()
            return


        self.chan = self.ssh.invoke_shell(term='xterm') # invoke_shell激活shell终端模式，也就是长连接模式，exec_command()函数是将服务器执行完的结果一次性返回给你；invoke_shell()函数类似shell终端，可以将执行结果分批次返回，所以我们接受数据时需要循环的取数据

        self.chan.transport.set_keepalive(30)  # 连接中没有任何信息时，该连接能够维持30秒

        # 和主机的连接一旦建立，主机就会将连接信息返回给服务端和主机的连接通道中，并且以后我们还要在这个通道中进行指令发送和指令结果的读取，所以我们开启单独的线程，去连接中一直等待和获取指令执行结果的返回数据
        Thread(target=self.loop_read).start()
```

最后，把host.routing下面注释的内容打开。第4行和第7行打开注释。

```python
from channels.routing import ProtocolTypeRouter, ChannelNameRouter

# ProtocolTypeRouter 根据不同的请求协议，分发到不同的协议处理系统，如果是websocket协议，那么自动找routing.ws_router进行路由转发，如果是channel，那么通过executors.SSHExecutor路由进行转发，如果是http协议，那么还是按照之前的方式进行分发
from consumer import routing # 这里类似原来的http编写代码时的路由，只是当时的路由信息，填写在了urls,而接下来，我们要编写websocket的路由，则写在routing，模块下

application = ProtocolTypeRouter({
    'websocket': routing.ws_router
})
```



#### 主机管理之文件管理器

![image-20210118185431284](6%E4%B8%BB%E6%9C%BA%E7%AE%A1%E7%90%86.assets/image-20210118185431284.png)



##### 头部展示主机信息

因为在此之前，我们曾经使用了ModelViewSet进行主机信息管理，提供了5基本的API接口包含了根据ID查询一个主机信息。所以我们直接修改客户端的请求即可。服务端访问：http://api.hippo.cn:8000/host/host/2/

前端主机信息展示

```html
<template>
  <div class="console">
    <div class="console_header">
      <div class="info">
        {{host_info.name}} | {{host_info.username}}@{{host_info.ip_addr}}:{{host_info.port}}
      </div>
      <div class="file_part">
        <button type="button" class="ant-btn ant-btn-primary" @click="showDrawer">
          <a-icon type="folder-open"/>
          文件管理器
        </button>
      </div>
    </div>
    <div id="terminal"></div>
  </div>
</template>

<script>
import { Terminal } from 'xterm'
export default {
  name: "Console",
  data(){
    return {
      host_info: {
        id: 0,
      },
    }
  },
  mounted() {
    this.show_terminal()
  },
  methods:{
    showDrawer(){
       // 显示或隐藏文件管理器
    },
    show_terminal(){
      // 获取当前本次操作的远程主机信息
      let pk = this.$route.params.id;
      let token = sessionStorage.token || localStorage.token;
      this.$axios.get(`/host/host/${pk}/`,{
        headers:{
          Authorization: `jwt ${token}`,
        }
      }).then((response) => {
        this.host_info = response.data;
        console.log(this.host_info)
      })

      // 初始化terminal窗口
       var term = new Terminal({
           rendererType: "canvas", //渲染类型
           rows: 40, //行数
           convertEol: true, // 启用时，光标将设置为下一行的开头
           scrollback: 100,   // 终端中的回滚量
           disableStdin: false, //是否应禁用输入。
           cursorStyle: 'underline', //光标样式
           cursorBlink: true, //光标闪烁
           theme: {
             foreground: '#ffffff', //字体
             background: '#060101', //背景色
             cursor: 'help',//设置光标
           }
       });
       // 建立websocket
       let ws = new WebSocket(`ws://api.hippo.cn:8000/ws/ssh/${this.$route.params.id}/`);
       var keyWord = '';  // 拼接用户输入的内容
       let msg = ""
      // 监听接收来自服务端响应的数据
       ws.onmessage = function (event) {
        if (!keyWord){
          //所要执行的操作
          term.write(event.data);
        }else {
          keyWord=''
          // 对响应回来的数据进行一些加工处理，筛选出结果内容部分
          let a = event.data.replace(event.data.split('\r\n',1)[0],'');
          let b = a.split('\r\n',-1).slice(0,-1).join('\r\n');
          term.write('\r\n'+b)
        }
      }

      term.prompt = () => {
        term.write('\r\n');
        // term.write('\r\n$ ')
        msg = '';
      }

      term.onKey(e => {
        console.log(e)
        const ev = e.domEvent
        const printable = !ev.altKey && !ev.altGraphKey && !ev.ctrlKey && !ev.metaKey

        console.log('>>>>',ev.keyCode);
        if (ev.keyCode === 13) {
          // console.log(keyWord);
          // 按下回车键进行指令的发送
          ws.send(keyWord);

        } else if (ev.keyCode === 8) {
          // Do not delete the prompt
          if (term._core.buffer.x > 2) {
            term.write('\b \b')
          }
        } else if (printable) {
          term.write(e.key);
          keyWord += e.key
        }
      })


       term.open(document.getElementById('terminal'));


    }
  }
}
</script>

<style scoped>
.console_header{
  height: 60px;
  line-height: 60px;
}
.info{
  float: left;
}
.file_part{
  float: right;
  margin-right: 18px;
}
</style>
```



##### 展示文件管理目录

后端部分

host/urls.py

```python
from django.urls import path,re_path
from . import views

urlpatterns = [
    path("category", views.HostCategoryListAPIView.as_view()),
    path("host_excel", views.HostExcelView.as_view()),
    re_path('^file/(?P<pk>\d+)/$', views.HostFileView.as_view({'get': 'get_folders','post': 'upload_file', 'delete': 'delete_file'})),
]

from rest_framework.routers import DefaultRouter
router = DefaultRouter()
router.register("host", views.HostModelViewSet, basename="host"),

urlpatterns +=router.urls
```

Host/views.py

```python
from rest_framework.generics import ListAPIView,CreateAPIView
from rest_framework.viewsets import ModelViewSet
from .models import HostCategory,Host
from .serializers import HostCategoryModelSeiralizer,HostModelSerializers
from rest_framework.permissions import IsAuthenticated

class HostCategoryListAPIView(ListAPIView, CreateAPIView):
    queryset = HostCategory.objects.filter(is_show=True, is_deleted=False).order_by("orders","-id").all()
    serializer_class = HostCategoryModelSeiralizer
    permission_classes = [IsAuthenticated]

class HostModelViewSet(ModelViewSet):
    queryset = Host.objects.all()
    serializer_class = HostModelSerializers
    permission_classes = [IsAuthenticated]

import xlwt
from rest_framework.views import APIView
from rest_framework.response import Response
from io import BytesIO
from .utils import read_host_excel_data
from django.http.response import HttpResponse
from django.utils.encoding import escape_uri_path

class HostExcelView(APIView):
    permission_classes = [IsAuthenticated]
    def post(self,request):
        """批量导入主机列表"""
        # 接受客户端上传的数据
        host_excel = request.data.get("host[]")
        default_password = request.data.get("default_password")

        # 把上传文件全部写入到字节流，就不需要保存到服务端硬盘了。
        sio = BytesIO()
        for i in host_excel:
            sio.write(i)

        data = read_host_excel_data(sio, default_password)

        return Response(data)

    def get(self,request):
        # 1 读取数据库数据
        all_host_data = Host.objects.all().values('id', 'category', 'name', 'ip_addr', 'port', 'username',
                                                         'description')

        # 2 写入excel并保存
        # 创建excel
        xls = xlwt.Workbook(encoding='utf-8')
        # 创建工作簿
        sheet = xls.add_sheet('主机数据列表')
        # 给工作簿首行写入表头
        sheet.write(0, 0, 'id')
        sheet.write(0, 1, 'category')
        sheet.write(0, 2, 'name')
        sheet.write(0, 3, 'ip_addr')
        sheet.write(0, 4, 'port')
        sheet.write(0, 5, 'username')
        sheet.write(0, 6, 'description')

        # 写入数据，从第一行开始
        excel_row = 1 # 因为表头已经占据了下标为1的首行，所以此处从下标1开始写入主机数据
        for host_obj in all_host_data:
            sheet.write(excel_row, 0, host_obj.get('id'))
            sheet.write(excel_row, 1, host_obj.get('category'))
            sheet.write(excel_row, 2, host_obj.get('name'))
            sheet.write(excel_row, 3, host_obj.get('ip_addr'))
            sheet.write(excel_row, 4, host_obj.get('port'))
            sheet.write(excel_row, 5, host_obj.get('username'))
            sheet.write(excel_row, 6, host_obj.get('description'))
            excel_row += 1

        # 将数据写入io数据流，不用在本地生成excel文件，不然效率就低了
        sio = BytesIO()
        xls.save(sio)
        sio.seek(0)

        # 3 将excel数据响应回客户端
        response = HttpResponse(sio.getvalue(), content_type='application/vnd.ms-excel')

        # 3.1 文件名称中文设置
        response['Content-Disposition'] = 'attachment; filename={}'.format(escape_uri_path('主机列表数据.xls'))
        response.write(sio.getvalue())  # 必须要给response写入一下数据，不然不生效
        return response


from rest_framework.viewsets import ViewSet
from hippo_api.utils.key import AppSetting
from django.conf import settings
from rest_framework import status
class HostFileView(ViewSet):
    # 方法分发之前，先实例化ssh连接，获取要操作的主机id和链接
    def dispatch(self, request, *args, **kwargs):
        # 获取url路径中的pk值
        pk = kwargs.get('pk')
        host_obj = Host.objects.get(pk=pk)
        primary_key, public_key = AppSetting.get(settings.DEFAULT_KEY_NAME)
        cli = host_obj.get_ssh(primary_key)
        self.cli = cli
        ret = super().dispatch(request, *args, **kwargs)

        return ret

    def get_folders(self, request, pk):
        """获取远程主机的目录列表"""
        cmd = request.query_params.get('cmd')
        res_code, res_data = self.cli.exec_command(cmd)
        print(f"res_code={res_code}, res_data={res_data}")

        return Response([res_code, res_data])

    def upload_file(self,request,pk):
        """上传文件到远程服务器"""
        # 上传的存储目录路径
        folder_path = request.query_params.get('folder_path')
        # 上传文件
        file_obj = request.FILES.get('file')
        folder_path += f'/{file_obj.name}'

        try:
            self.cli.put_file_by_fl(file_obj, folder_path, self.file_upload_callback)
        except:
            return Response({'error': '文件上传失败,请联系管理员或者查看一下用户权限'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        return Response({"msg":"上传文件成功"})

    def file_upload_callback(self,n,k):
        print('>>>>>>>>>>>', n, k)

    def delete_file(self,request,pk):
        """删除远程服务器的文件"""
        return Response({"msg": "ok"})

```



前端实现远程服务器的目录展示和上传文件。

```html
<template>
  <div class="console">
    <div class="console_header">
      <div class="info">
        {{host_info.name}} | {{host_info.username}}@{{host_info.ip_addr}}:{{host_info.port}}
      </div>
      <div class="file_part">
        <button type="button" class="ant-btn ant-btn-primary" @click="showDrawer">
          <a-icon type="folder-open"/>
          文件管理器
        </button>
      </div>
    </div>

    <div class="file_show">

      <div>

        <a-drawer
          title="文件管理器"
          :width="900"
          :visible="visible"
          :body-style="{ paddingBottom: '80px' }"
          @close="onClose"
        >
          <div class="file_nav">
            <div>
              <a-breadcrumb>
                <a-breadcrumb-item>
                  <a-icon @click="back_folder('/',1)" type="home"/>
                </a-breadcrumb-item>

                <a-breadcrumb-item v-for="(folder_path,f_index) in path" :key="f_index" v-show="folder_path!=='/'">
                  <span style="cursor: pointer;" @click="back_folder(folder_path,f_index)">{{folder_path}}</span>
                </a-breadcrumb-item>
              </a-breadcrumb>
            </div>
            <div style="display: flex; align-items: center;">
              <span>显示隐藏文件：</span>
              <a-switch @change="switch_on_off" checked-children="开" un-checked-children="关"/>
              <div style="margin-left: 10px">
                <a-upload
                  name="file"
                  :multiple="true"
                  :action="visit_url+'?folder_path=' + folder_path_str"
                  :headers="headers"
                  @change="handleChange"
                >
                  <a-button type="primary">
                    <a-icon type="upload"/>
                    上传文件
                  </a-button>
                </a-upload>
              </div>

            </div>


          </div>
          <div>
            <a-table
              :columns="columns"
              :data-source="data"
              :pagination="false"
              :scroll="{ y: 400 }"
            >

              <a slot="name" slot-scope="text,record"> <!-- record表示该条记录，是个字典 -->
                <span @click="join_folder(text)" v-if="record.file_attr.substr(0,1)==='d'">
                  <a-icon type="folder"/>
                {{ text }}
                </span>
                <span v-else>
                  <a-popconfirm placement="top" ok-text="下载" cancel-text="取消" @confirm="confirm(text)">
                    <template slot="title">
                      <p>确认下载该文件吗？</p>
                      <p>{{ text }}</p>
                    </template>

                      <a-icon type="file"/>
                      {{ text }}

                  </a-popconfirm>
                </span>
              </a>
            </a-table>
          </div>
        </a-drawer>
      </div>
    </div>


    <div id="terminal"></div>
  </div>
</template>

<script>
import { Terminal } from 'xterm'


  const columns = [

    {
      title: '名称',
      dataIndex: 'file_name',
      width: 300,
      scopedSlots: {customRender: 'name'},
    },
    {
      title: '大小',
      dataIndex: 'file_size',

    },
    {
      title: '修改时间',
      dataIndex: 'file_modify_time',
      width: 200,
    },
    {
      title: '属性',
      dataIndex: 'file_attr',
      width: 150,
      scopedSlots: {customRender: 'file_attr'},
    },
    {
      title: '操作',
      dataIndex: 'action',
    },
  ];


export default {
  name: "Console",
  data(){
    return {
      visible: false, // 控制抽屉的显示隐藏
      host_info: {
        id: 0,
      },
      headers: {
        authorization: 'authorization-text',
      },
      data: [],
      columns,
      path: ['/',], // 默认是根路径，获取根路径下所有的文件和文件夹 ls-l /
      ls_cmd: "\\ls -l -h --time-style '+%Y/%m/%d %H:%M:%S'",
      folder_path_str: '/',
      visit_url:'',
    }
  },
  mounted() {
    this.show_terminal()
  },
  methods:{
    // 拼接访问的目录路径
    join_folder(text) {
      this.file_folder_list = [];
      if (text === '/') {
        this.path = ['/',]
      } else {
        this.path.push(text);
      }

      let folder_path = this.path.join('/');
      // folder_path = '/'
      if (this.path.length > 1) {
        folder_path = folder_path.slice(1);
      }

      this.folder_path_str = folder_path;

      this.send_show_folder_cmd(this.folder_path_str, this.ls_cmd);

    },

    // 发送ls指令
    send_show_folder_cmd(folder_path, cmd) {
        this.$axios.get(this.visit_url, {
          params: {
            cmd: `${cmd} ${folder_path}`,
          }
        }).then((response) => {
          console.log('>>>>>>',this.folder_path_str);
          console.log('>>>>>>',response);
          this.data = [];
          let data = response.data;
          // console.log(data);
          let data_l = data[1].split('\n').slice(1);

          // console.log('///',data_l);
          data_l.forEach((file_info, file_index) => {
            // console.log(v);
            if (file_info) {
              // console.log(file_info,file_index);
              //["drwxr-xr-x", "2", "root", "root", "4096", "2020/09/14", "17:34:06", "bin"]
              let files_list = file_info.trim().split(/\s+/);
              // console.log(files_list);
              let a_list = files_list.slice(5, 7);
              let timer = a_list.join(' ');

              this.data.push({
                key: `${files_list[7] + 1}`,
                file_name: files_list[7],  //[-1]， 不支持负数索引
                file_size: files_list[4],
                file_modify_time: timer,
                file_attr: files_list[0],
              })
            }
          })
          // this.file_folder_list = this.file_folder_list.concat(data_l_2);
        }).catch((error) => {
          console.log('报错啦！！！');
        })
      },

      // 显示隐藏文件和隐藏显示文件
      switch_on_off(e) {
        // console.log('>>>',e);  // true\false
        if (e) {
          // 开启显示隐藏文件
          this.ls_cmd = `\\ls -l -h -a --time-style '+%Y/%m/%d %H:%M:%S'`
          this.send_show_folder_cmd(this.folder_path_str, this.ls_cmd);
        } else {
          // 关闭显示隐藏文件
          this.ls_cmd = `\\ls -l -h --time-style '+%Y/%m/%d %H:%M:%S'`
          this.send_show_folder_cmd(this.folder_path_str, this.ls_cmd);
        }
      },
    back_folder(text, f_index){
      // 返回上级目录
      // this.path = this.path.slice(0,f_index+1);
      this.path = this.path.slice(0, f_index);
      this.join_folder(text);
    },
    showDrawer(){
       // 显示文件管理器的抽屉
      this.visible = true;
      this.visit_url = `${this.$settings.host}/host/file/${this.$route.params.id}/`;
      this.join_folder('/');
    },
    onClose() {
      // 关闭抽屉
      this.visible = false;
    },

    handleChange(info) {
        if (info.file.status !== 'uploading') {
          // console.log(info.file, info.fileList);

        }
        if (info.file.status === 'done') {
          this.send_show_folder_cmd(this.folder_path_str, this.ls_cmd);
          this.$message.success(`${info.file.name} file uploaded successfully`);
        } else if (info.file.status === 'error') {
          this.$message.error(`${info.file.name} file upload failed.${info.file.response.error}`);
        }
    },
    show_terminal(){
      // 获取当前本次操作的远程主机信息
      let pk = this.$route.params.id;
      let token = sessionStorage.token || localStorage.token;
      this.$axios.get(`/host/host/${pk}/`,{
        headers:{
          Authorization: `jwt ${token}`,
        }
      }).then((response) => {
        this.host_info = response.data;
        console.log(this.host_info)
      })

      // 初始化terminal窗口
       var term = new Terminal({
           rendererType: "canvas", //渲染类型
           rows: 40, //行数
           convertEol: true, // 启用时，光标将设置为下一行的开头
           scrollback: 100,   // 终端中的回滚量
           disableStdin: false, //是否应禁用输入。
           cursorStyle: 'underline', //光标样式
           cursorBlink: true, //光标闪烁
           theme: {
             foreground: '#ffffff', //字体
             background: '#060101', //背景色
             cursor: 'help',//设置光标
           }
       });
       // 建立websocket
       let ws = new WebSocket(`ws://api.hippo.cn:8000/ws/ssh/${this.$route.params.id}/`);
       var keyWord = '';  // 拼接用户输入的内容
       let msg = ""
      // 监听接收来自服务端响应的数据
       ws.onmessage = function (event) {
        if (!keyWord){
          //所要执行的操作
          term.write(event.data);
        }else {
          keyWord=''
          // 对响应回来的数据进行一些加工处理，筛选出结果内容部分
          let a = event.data.replace(event.data.split('\r\n',1)[0],'');
          let b = a.split('\r\n',-1).slice(0,-1).join('\r\n');
          term.write('\r\n'+b)
        }
      }

      term.prompt = () => {
        term.write('\r\n');
        // term.write('\r\n$ ')
        msg = '';
      }

      term.onKey(e => {
        console.log(e)
        const ev = e.domEvent
        const printable = !ev.altKey && !ev.altGraphKey && !ev.ctrlKey && !ev.metaKey

        console.log('>>>>',ev.keyCode);
        if (ev.keyCode === 13) {
          // console.log(keyWord);
          // 按下回车键进行指令的发送
          ws.send(keyWord);

        } else if (ev.keyCode === 8) {
          // Do not delete the prompt
          if (term._core.buffer.x > 2) {
            term.write('\b \b')
          }
        } else if (printable) {
          term.write(e.key);
          keyWord += e.key
        }
      })

       term.open(document.getElementById('terminal'));

    }
  }
}
</script>

<style scoped>
.console_header{
  height: 60px;
  line-height: 60px;
}
.info{
  float: left;
}
.file_part{
  float: right;
  margin-right: 18px;
}
</style>
```



好，资产管理，我们暂时说道这里。包含目录切换、上传文件等功能，其他功能由大家自行拓展