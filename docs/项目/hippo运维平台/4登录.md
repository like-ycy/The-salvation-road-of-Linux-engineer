## 登录功能

### 登录处理

Django默认已经提供了认证系统Auth模块，我们认证的时候，会使用auth模块里面给我们提供的表。认证系统包含：

- 用户管理
- 权限
- 用户组
- 密码哈希系统
- 用户登录或内容显示的表单和视图
- 一个可插拔的后台系统 admin

我们可以在终端下通过命令创建一个管理员账号，并登陆到admin站点中。

```bash
python manage.py migrate
python manage.py createsuperuser
```



Django默认用户的认证机制依赖Session机制，我们在项目中将引入JWT认证机制，将用户的身份凭据存放在Token中，然后对接Django的认证系统，帮助我们来实现：

- 用户的数据模型
- 用户密码的加密与验证
- 用户的权限系统



#### Django用户模型类

django.contrib.auth.models.py中定义的用户模型，字段声明在AbstractUser，AbstractBaseUser中。

Django认证系统中提供了用户模型类User保存用户的数据，默认的User包含以下常见的基本字段：

| 字段名             | 字段描述                                                     |
| ------------------ | ------------------------------------------------------------ |
| `username`         | 必选。150个字符以内。 用户名可能包含字母数字，`_`，`@`，`+` `.` 和`-`个字符。 |
| `first_name`       | 可选（`blank=True`）。 少于等于30个字符。                    |
| `last_name`        | 可选（`blank=True`）。 少于等于30个字符。                    |
| `email`            | 可选（`blank=True`）。 邮箱地址。                            |
| `password`         | 必选。 密码的哈希加密串。 （Django 不保存原始密码）。 原始密码可以无限长而且可以包含任意字符。 |
| `groups`           | 与`Group` 之间的多对多关系。                                 |
| `user_permissions` | 与`Permission` 之间的多对多关系。                            |
| `is_staff`         | 布尔值。 设置用户是否可以访问Admin 站点。                    |
| `is_active`        | 布尔值。 指示用户的账号是否激活。 它不是用来控制用户是否能够登录，而是描述一种帐号的使用状态。 |
| `is_superuser`     | 是否是超级用户。超级用户具有所有权限。                       |
| `last_login`       | 用户最后一次登录的时间。                                     |
| `date_joined`      | 账户创建的时间。 当账号创建时，默认设置为当前的date/time。   |

上面缺少一些字段，所以后面我们会对当前内置的用户模型进行改造，比如说它里面没有手机号字段，后面我们需要加上。

##### 常用模型对象方法：

- `set_password`(*raw_password*)

  设置用户的密码为给定的原始字符串，并负责密码的。 不会保存`User` 对象。当`None`为`raw_password` 时，密码将设置为一个不可用的密码。

- `check_password`(*raw_password*)

  如果给定的raw_password是用户的真实密码，则返回True，可以在校验用户密码时使用。

##### 常用管理器方法：

管理器方法即可以通过`User.objects.` 进行调用的方法。

- `create_user`(*username*, *email=None*, *password=None*, **\*extra_fields*)

  创建、保存并返回一个`User`对象。

- `create_superuser`(*username*, *email*, *password*, **\*extra_fields*)

  与`create_user()` 相同，但是设置`is_staff` 和`is_superuser` 为`True`。



#### 创建用户模块的子应用

```shell
python ../../manage.py startapp users
```

在settings/dev.py文件中注册子应用。

```python
INSTALLED_APPS = [
		...
  	'users',
]
```

子路由，users.urls.py，代码：

```python
from django.urls import path
from . import views
urlpatterns = [

]
```

总路由注册users子路由，hippo_api.urls.py，代码：

```python
from django.contrib import admin
from django.urls import path,include

urlpatterns = [
    path('admin/', admin.site.urls),
    path("", include("home.urls")),
    path("users/", include("users.urls")),
]
```



#### 创建自定义的用户模型类

Django认证系统中提供的用户模型类及方法很方便，我们可以使用这个模型类，但是字段有些无法满足项目需求，如本项目中需要保存用户的手机号，需要给模型类添加额外的字段。

Django提供了`django.contrib.auth.models.AbstractUser`用户抽象模型类允许我们继承，扩展字段来使用Django认证系统的用户模型类。

**我们可以在apps中创建Django应用users，并在配置文件中注册users应用。**

在创建好的应用models.py中定义用户的用户模型类。

```python
from django.db import models
from django.contrib.auth.models import AbstractUser
# Create your models here.
class User(AbstractUser):
    mobile = models.CharField(max_length=15, unique=True, verbose_name='手机号码')
    # upload_to 表示上传文件的存储子路由，需要在settings配置中，配置上传文件的支持
    avatar = models.ImageField(upload_to='avatar', verbose_name='用户头像', null=True, blank=True)
    class Meta:
        db_table = 'hippo_user'
        verbose_name = '用户信息'
        verbose_name_plural = verbose_name

// 下面的3个表现不用创建，留着以后使用
class Menu(models.Model):
    """
    一级菜单表
    """
    title = models.CharField(max_length=12)
    weight = models.IntegerField(default=0)
    icon = models.CharField(max_length=16, null=True, blank=True)

    def __str__(self):
        return self.title

    class Meta:
        db_table = 'hippo_menu'
        verbose_name = '一级菜单表'
        verbose_name_plural = verbose_name
        unique_together = ('title', 'weight')


class Permission(models.Model):
    url = models.CharField(max_length=32)
    title = models.CharField(max_length=32)
    menus = models.ForeignKey('Menu',on_delete=models.CASCADE , null=True, blank=True)
    parent = models.ForeignKey('self',on_delete=models.CASCADE ,  null=True, blank=True)

    url_name = models.CharField(max_length=32, unique=True)

    def __str__(self):
        return self.title
    class Meta:
        db_table = 'hippo_permission'
        verbose_name = '权限表'
        verbose_name_plural = verbose_name

class Role(models.Model):
    name = models.CharField(max_length=12)
    permissions = models.ManyToManyField(to='Permission')

    def __str__(self):
        return self.name

    class Meta:
        db_table = 'hippo_role'
        verbose_name = '角色表'
        verbose_name_plural = verbose_name
```

我们自定义的用户模型类还不能直接被Django的认证系统所识别，需要在配置文件中告知Django认证系统使用我们自定义的模型类。

在配置文件中进行设置,`settings.dev.py`，代码：

```python
#设置Auth认证模块使用的用户模型为我们自己定义的用户模型
# 格式：“子应用目录名.模型类名”
AUTH_USER_MODEL = 'users.User'
```

`AUTH_USER_MODEL` 参数的设置以`点.`来分隔，表示`应用名.模型类名`。

**注意：Django建议我们对于AUTH_USER_MODEL参数的设置一定要在第一次数据库迁移之前就设置好，否则后续使用可能出现未知错误。**

接下来，因为我们新建的用户模型需要同步到数据库中。所有需要数据迁移。同时当前用户模型中，我们声明了头像字段需要进行图片处理的。所以我们安装Pillow模块。

```bash
# 安装Pillow模块
pip install pillow

# 数据迁移
python manage.py makemigrations
python manage.py migrate
```

因为我们自定义用户模型之前曾经进行了一次数据迁移，所以mysql中为原来的用户表与django其他的数据进行关联。所以此时我们再次数据迁移，因为修改了用户表，所以会出现外键关联报错。

解决方法如下：

```
1. 删除数据库中所有的数据表[如果数据表中有重要数据，必须先导出备份]
2. 删除当前users子应用中的migrations目录下所有以数字开头的python文件
3. 删除源码中django.contrib.auth和django.contrib.admin中的migrations目录下所有以数字开头的python文件
4. 重新执行数据迁移
   python manage.py makemigrations
   python manage.py migrate
5. 把上面备份的数据通过终端重新恢复
```



#### simpleui的安装和使用

simpleui是Django的第三方扩展，比使用Django的admin站点更强大也更方便，更好看。

文档：https://simpleui.72wo.com/docs/simpleui/

GitHub地址：https://github.com/happybeta/simpleui

##### 安装

通过如下命令安装simpleui的最新版，它文档里面的安装方法好久没有更新了，会导致你安装不成功，所以我们使用下面的网址进行安装

```shell
pip install django-simpleui -i https://pypi.douban.com/simple
```

在配置文件中注册如下应用，`settings.dev`，代码：

```python
INSTALLED_APPS = [
    'simpleui',  # 必须写在django.contrib.admin之前
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',
    'corsheaders',

    'home',
    'users',
]

# 修改使用中文界面
LANGUAGE_CODE = 'zh-Hans'

# 修改时区
TIME_ZONE = 'Asia/Shanghai'
```

xadmin也是一个早期django2.0版本中常用的站点美化模块，有需要的同学，可以下载对应的视频笔记。跟着修复一下。

```
链接：https://pan.baidu.com/s/11l4hx3YjeAbgDKfSAIT8zQ
提取码：ucpc
--来自百度网盘超级会员V4的分享
```



### Django REST framework JWT

在用户注册或登录后，我们想记录用户的登录状态，或者为用户创建身份认证的凭证。我们不再使用Session认证机制，而使用Json Web Token认证机制。

很多公司开发的一些移动端可能不支持cookie，并且我们通过cookie和session做接口登录认证的话，效率其实并不是很高，我们的接口可能提供给多个客户端，session数据保存在服务端，那么就需要每次都调用session数据进行验证，比较耗时，所以引入了token认证的概念，我们也可以通过token来完成，我们来看看jwt是怎么玩的。

```
Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。
```



#### JWT的构成

JWT就一段字符串，由三段信息构成的，将这三段信息文本用`.`链接一起就构成了Jwt字符串。就像这样:

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
```

第一部分我们称它为头部（header),第二部分我们称其为载荷（payload, 类似于飞机上承载的物品)，第三部分是签证（signature).



#### header

jwt的头部承载两部分信息：

- 声明类型，这里是jwt
- 声明加密的算法 通常直接使用 HMAC SHA256

完整的头部就像下面这样的JSON：

```
{
  'typ': 'JWT',
  'alg': 'HS256'
}
```

然后将头部进行base64.b64encode()编码，构成了第一部分.

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
```

python中base64加密解密

```python
import base64,json
data = {
  'typ': 'JWT',
  'alg': 'HS256'
}

header = base64.b64encode(json.dumps(data).encode()).decode()

# 各个语言中都有base64加密解密的功能，所以我们jwt为了安全，需要配合第三段加密
```



#### payload

载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息可以存放下面三个部分信息。

- 标准声明
- 公共声明
- 私有声明

**标准声明** (建议但不强制使用) ：

- **iss**: jwt签发者

- **sub**: jwt所面向的用户

- **aud**: 接收jwt的一方

- **exp**: jwt的过期时间，这个过期时间必须要大于签发时间

- **nbf**: 定义在什么时间之前，该jwt都是不可用的.

- **iat**: jwt的签发时间

- **jti**: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。

  以上是JWT 规定的7个官方字段，供选用

**公共声明** ： 公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端直接可以查看.

**私有声明** ： 私有声明是服务端和客户端所共同定义的声明，一般使用了ace算法进行对称加密和解密的，意味着该部分信息可以归类为明文信息。

定义一个payload，json格式的数据:

```
{
  "sub": "1234567890",
  "exp": "3422335555", #时间戳形式
  "name": "John Doe",
  "admin": true,
  "info": "232323ssdgerere3335dssss"  # ACE算法加密
}
```

然后将其进行base64.b64encode() 编码，得到JWT的第二部分。

```
eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9
```

```python
import base64,json
data = {
  "sub": "1234567890",
  "exp": "3422335555",
  "name": "John Doe",
  "admin": True,
  "info": "232323ssdgerere3335dssss"
}

preload = base64.b64encode(json.dumps(data).encode()).decode()

# 各个语言中都有base64编码和解码，所以我们jwt为了安全，需要配合第三段签证来进行加密保证jwt不会被人篡改。
```



#### signature

JWT的第三部分是一个签证信息，这个签证信息由三部分组成：

- header (base64后的)
- preload (base64后的)
- secret 密钥

这个部分需要base64加密后的header和base64加密后的payload使用`.`连接组成的字符串，然后通过header中声明的加密方式进行加盐`secret`组合加密，然后就构成了jwt的第三部分。

python，代码：

```python
import base64, json, hashlib

if __name__ == '__main__':
    # 头部
    data = {'typ': 'JWT', 'alg': 'HS256'}
    header = base64.b64encode(json.dumps(data).encode()).decode()

    # 载荷
    data = {"sub": "1234567890", "exp": "3422335555", "name": "John Doe", "admin": True,
            "info": "232323ssdgerere3335dssss"}
    preload = base64.b64encode(json.dumps(data).encode()).decode()

    # 签证
    # from django.conf import settings
    # secret = settings.SECRET_KEY
    secret = 'django-insecure-(_+qtd5edmhm%2rdsg+qc3wi@s_k*3cbk-+k2gpg3@qx)z6r+p'
    sign = f"{header}.{preload}.{secret}"

    hs256 = hashlib.sha256()
    hs256.update(sign.encode())
    signature = hs256.hexdigest()

    jwt = f"f{header}.{preload}.{signature}"
    print(jwt)
```

将这三部分用`.`连接成一个完整的字符串,构成了最终的jwt:

```
feyJ0eXAiOiAiSldUIiwgImFsZyI6ICJIUzI1NiJ9.eyJzdWIiOiAiMTIzNDU2Nzg5MCIsICJleHAiOiAiMzQyMjMzNTU1NSIsICJuYW1lIjogIkpvaG4gRG9lIiwgImFkbWluIjogdHJ1ZSwgImluZm8iOiAiMjMyMzIzc3NkZ2VyZXJlMzMzNWRzc3NzIn0=.374b156a33e579c780eb1594a5738c580a13ea0f905487dc66c15856b6110ebf
```

**注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。**

```
jwt的优点：
1. 实现分布式的单点登陆非常方便
2. 数据实际保存在客户端，所以我们可以分担服务端的存储压力
3. JWT不仅可用于认证，还可用于信息交换。善用JWT有助于减少服务器请求数据库的次数，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的。

jwt的缺点：
1. 数据保存在了客户端，我们服务端只认jwt，不识别客户端。
2. jwt可以设置过期时间，但是因为数据保存在了客户端，所以对于过期时间不好调整。# secret_key轻易不要改，一改所有客户端都要重新登录
```

认证流程图

![1626513913826.png](4%E7%99%BB%E5%BD%95.assets/1626513913826.png)

**关于签发和核验JWT，我们可以使用Django REST framework JWT扩展来完成。**

文档网站 ; https://jpadilla.github.io/django-rest-framework-jwt/



#### 安装配置JWT

安装

```shell
pip install djangorestframework-jwt -i https://mirrors.aliyun.com/pypi/simple/
```

配置(github网址：https://github.com/jpadilla/django-rest-framework-jwt)

```python
REST_FRAMEWORK = {
    # 自定义异常处理
    'EXCEPTION_HANDLER': 'hippo_api.utils.exceptions.custom_exception_handler',
    # 自定义认证
    'DEFAULT_AUTHENTICATION_CLASSES': (
        # jwt认证
        'rest_framework_jwt.authentication.JSONWebTokenAuthentication',
        # session认证
        'rest_framework.authentication.SessionAuthentication',

        'rest_framework.authentication.BasicAuthentication',
    ),
}


import datetime
JWT_AUTH = {
    # jwt的有效时间
    'JWT_EXPIRATION_DELTA': datetime.timedelta(weeks=1),
}
```

- JWT_EXPIRATION_DELTA 指明token的有效期



我们django创建项目的时候，在settings配置文件中直接就给生成了一个serect_key，我们直接可以使用它作为我们jwt的serect_kek，其实djangorestframework-jwt默认配置中就使用的它。



#### 手动生成jwt（我们暂时用不到）

Django REST framework JWT 扩展的说明文档中提供了手动签发JWT的方法

```python
from rest_framework_jwt.settings import api_settings

jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER # 生成载荷的函数
jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER   # 生成token的函数

payload = jwt_payload_handler(user) # user用户模型对象
token = jwt_encode_handler(payload) # 生成jwt的token(令牌，代表的就是一段字符串)
```

在用户注册或登录成功后，在序列化器中返回用户信息以后同时返回token即可。



#### 后端生成token

Django REST framework JWT提供了登录获取token的视图，可以直接给这视图指定url路由即可使用。

在users子应用路由urls.py中

```python
from rest_framework_jwt.views import obtain_jwt_token

urlpatterns = [
    path('login/', obtain_jwt_token),
]
```

在主路由中，引入当前子应用的路由文件

```python
urlpatterns = [
		...
    path('user/', include("users.urls")),
]
```

接下来，我们可以通过postman来测试下功能，但是jwt是通过username和password来进行登录认证处理的，所以我们要给真实数据，jwt会去我们配置的user表中去查询用户数据的。

![](4%E7%99%BB%E5%BD%95.assets/1626514627320.png)

得到的载荷信息，我们可以通过js内置的base64编码函数来读取里面内容。举例代码：

```javascript
let token = "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoxLCJ1c2VybmFtZSI6InJvb3QiLCJleHAiOjE2MjcxMTkzODQsImVtYWlsIjoiIn0.Xz_QJ5BPSOsjIB-EymwHaptgG-v1Ic8Aa0FhYhcEErE"
let data = token.split(".")
let user_info = JSON.parse(atob(data[1]))

// atob()   // base64解码
// btoa()   // base64编码
```



#### 客户请求登录获取token并保存到本地

客户端保存token，我们使用的是sessionStorage(临时存储，浏览器关闭自动清除)或者localStorage(永久存储)

```javascript
// javascript中原生提供的2个保存本地数据的本地存储对象，2者存储的时间不同，但是操作方法一模一样。
// sessionStorage 会话存储，数据保存浏览器中，关闭浏览器以后数据丢失
// localStorage   永久存储，数据保存浏览器中，除非手动删除，否则永不丢失

// 添加/修改数据
sessionStorage.setItem("变量名","变量值")   // 简写： sessionStorage.变量名 = 变量值

// 读取数据
sessionStorage.getItem("变量名")   // 简写： sessionStorage.变量名

// 删除数据
sessionStorage.removeItem("变量名") // 删除指定数据
sessionStorage.clear() // 清空当前域名在浏览器中保存的数据，慎用
```

客户端代码：

```vue
<template>
	<div class="login box">
		<img src="../assets/login.jpg" alt="">
		<div class="login">
			<div class="login-title">
				<img src="../assets/login3.jpeg" alt="">
				<p>Hippo!</p>
			</div>
			<div class="login_box">
				<div class="title">
					<span>登录</span>
				</div>
				<div class="inp">
					<input v-model="username" type="text" placeholder="用户名" class="user">
					<input v-model="password" type="password" class="pwd" placeholder="密码">
					<div class="rember">
						<p>
							<input type="checkbox" class="no" v-model="remember"/>
							<span>记住密码</span>
						</p>

					</div>
					<button class="login_btn" @click="login">登录</button>

				</div>

			</div>
		</div>
	</div>
</template>

<script>
export default {
  name: "Login",
  data(){
    return {
        remember: false, // 是否记住登录
        username:"",
        password:"",
    }
  },
  methods:{
    login(){
      this.$axios.post(`/users/login`,{
        username: this.username,
        password: this.password,
      }).then((response)=>{
        // locatStorage或者sessionStorage中存储token
        // 先清空原有的token
        localStorage.removeItem("token");
        sessionStorage.removeItem("token");

        if(this.remember){
          // 记住登录
          localStorage.token = response.data.token;
        }else{
          sessionStorage.token = response.data.token;
        }
        // 跳转到首页
        let self=this;
        this.$success({
            title: 'hippo系统提示',
            content: `登录成功！`,
            onOk(){
              self.$router.push("/hippo");
            }
          })
        // 下一个页面，首页加载时验证token有效性
      }).catch(error=>{
          this.$message.error('用户名或者密码有误，请重新输入！');
      });
    },
  },
}
</script>
```

拿到token以后，我们发送任何需要登录之后才能发送的请求，都需要先对token的有效性进行认证，然后将token携带到请求头中，来通过后台接口的 token的校验。



#### 验证token的有效性

在restframework_jwt中除了提供生成jwt-token的登录视图以外，还提供了验证和刷新token的视图，所以我们在用户登录进入hippo系统以后，就可以使用系统内置的刷新验证token来完成用户的身份识别以及防翻墙功能。

users.urls，代码：

```python
from rest_framework_jwt.views import obtain_jwt_token, verify_jwt_token, refresh_jwt_token
from django.urls import path
from . import views

urlpatterns = [
    path("login", obtain_jwt_token),
    # path("verify", verify_jwt_token), # 验证token是否过期了
    path('refresh', refresh_jwt_token), #校验并生成新的token，要开启该功能，还必须配置JWT_ALLOW_REFRESH配置
]
```

刷新token除了配置上面的refresh_jwt_token之外，还需要在配置文件中加上如下配置

settings.dev，代码：

```python
# jwt配置项
import datetime
JWT_AUTH = {
    # jwt的有效时间
    'JWT_EXPIRATION_DELTA': datetime.timedelta(days=1),
    'JWT_ALLOW_REFRESH': True,  #这个参数要改True，才能刷新token
}
```



客户都每次操作页面时，基于路由的导航守卫，在页面跳转时，验证除了Login以外的页面，用户的token是否还有效。

src/router/index.js，代码：

```js
import Vue from 'vue'
import Router from 'vue-router'

Vue.use(Router)
import Base from "../components/Base";
import Login from "../components/Login";
import ShowCenter from "../components/ShowCenter";
import Host from '@/components/Host'

const router = new Router({
  mode: "history",
  routes: [
    {
      path: '/',
      name: 'Login',
      component: Login,
    },
    {
      path: '/hippo',
      name: 'Base',
      component: Base,
      children: [
        {
          path: 'workbench',  // 访问路径： 父级路由 + 当前路由
          name: 'ShowCenter',
          component: ShowCenter,
        },
        {
          path: 'host',
          name: 'Host',
          component: Host,
        },
      ]
    },

  ]
})

// 路由守卫[导航守卫]
import axios from "axios"
import settings from "../settings.js"
router.beforeEach((to, from, next) => {
  if(to.name === 'Login'){
    next()
    return
  }
  let token = sessionStorage.token || localStorage.token;
  // 验证jwt token
  axios.post(`${settings.host}/users/refresh`,{
    token, // token: token,
  }).then(response=>{
      // 保存返回的新token
      sessionStorage.token = response.data.token;
      next()
  }).catch(error=>{
      // alert("对不起，您尚未登录或登录已超时，请重新登录！")
      next("/")
  })

})

export default router
```

