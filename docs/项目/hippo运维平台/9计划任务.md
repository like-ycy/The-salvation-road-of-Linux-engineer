

## 计划任务

效果：

![image-20210312194844276](9%E7%9B%91%E6%8E%A7%E9%A2%84%E8%AD%A6.assets/image-20210312194844276.png)



创建应用

```python
cd hippo_api/apps/
python ../../manage.py startapp schedule
```



配置应用，settings.dev，代码：

```python
INSTALLED_APPS = [
    ...
    'schedule',
		...
]
```

在应用中创建urls.py文件，`schedule.urls`，代码：

```python
from django.urls import path,re_path
from . import views

urlpatterns = [
    
]
```

总路由，`hippo_api.urls`，代码：

```python
    path('schedule/', include('schedule.urls')),
```

创建模型类，保存任务计划

```python
from django.db import models
from host.models import Host

# 任务记录表
class TaskSchedule(models.Model):
    period_way_choices = (
        ('1', '普通周期'),
        ('2', '一次性任务'),
        ('3', 'cron任务'),
    )
    status_choices = (
        ('1', '激活'),
        ('2', '停止'),
        ('3', '报错'),

    )
		
    period_beat = models.IntegerField(verbose_name='django-celery-beat任务id', help_text='方便我们通过这个id值来控制celery的任务状态', null=True,blank=True)
    task_name = models.CharField(max_length=32, unique=True, verbose_name='任务名称')
    task_cmd = models.TextField(verbose_name='任务指令')
    #是否通知
    #通知方式
    #通知内容
    period_way = models.CharField(max_length=32,choices=period_way_choices, default='1', verbose_name='任务周期方式')
    period_content = models.CharField(max_length=32,verbose_name='周期计划')  #10秒、*****cron方式，datetime时间等
    period_status = models.CharField(max_length=32,default='1', choices=status_choices)

# 任务和主机的关系表
class TaskHost(models.Model):
    tasks = models.ForeignKey('TaskSchedule',on_delete=models.CASCADE,verbose_name='执行的任务')
    hosts = models.ForeignKey(Host,on_delete=models.CASCADE,verbose_name='任务执行主机')

```

![1629604514147](9%E7%9B%91%E6%8E%A7%E9%A2%84%E8%AD%A6.assets/1629604514147.png)

### celery定时计划

安装依赖库

```python
pip install celery==4.4.7
pip install django-celery-beat==2.0.0  
pip install django-celery-results
pip install django-redis==3.5.2
```



项目配置文件中配置django-celery-beat，`stttings.dev`，代码：

```python
INSTALLED_APPS = [
    'django.contrib.admin',
    ...
    'app01',
    'django_celery_beat',
]

LANGUAGE_CODE = 'zh-hans'  # 使用中国语言
TIME_ZONE = 'Asia/Shanghai'  # 设置Django使用中国上海时间
# 如果USE_TZ设置为True时，Django会使用系统默认设置的时区，此时的TIME_ZONE不管有没有设置都不起作用
# 如果USE_TZ 设置为False,TIME_ZONE = 'Asia/Shanghai', 则使用上海的UTC时间。
USE_TZ = False  # 如果用的sqlit数据库，那么改为True，sqlit数据库不支持
```

我们当前celery要使用redis作为消息队列，所以要记得查看下，redis是否正常启动了。

OK，安装完成相关的模块以后，我们接下来要使用celery。

首先，需要在hippo_api服务端项目根目录下创建一个保存celery代码的包目录celery_tasks。

在celery_tasks包目录下创建几个python文件，用于对celery进行初始化配置。

main.py(celery初始化) 、config.py(配置文件) 、  tasks.py(任务文件，文件名必须叫tasks.py)

main.py

```python
import os
from celery import Celery
from . import config


# 为celery设置django相关的环境变量，方便将来在celery中调用django的代码
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'hippo_api.settings.dev')
# 创建celery实例对象[可以以项目名作为名称，或者以项目根目录名也可以]
app = Celery('hippo_api')
# 从配置文件中加载celery的相关配置
app.config_from_object(config)

# 设置app自动加载任务
app.autodiscover_tasks([
    'celery_tasks', # celery会自动得根据列表中对应的目录下的tasks.py 进行搜索注册
])
```

config.py

```python
import os
# 为celery设置django相关的环境变量，方便将来在celery中调用django的代码
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'hippo_api.settings.dev')
from django.conf import settings
# 设置celery接受任务的队列
broker_url = 'redis://127.0.0.1:6379/14'
# 设置celery保存任务执行结果的队列
result_backend = 'redis://127.0.0.1:6379/15'
# celery 的启动工作数量设置[进程数量]
CELERY_WORKER_CONCURRENCY = 20
# 任务预取功能，就是每个工作的进程／线程在获取任务的时候，会尽量多拿 n 个，以保证获取的通讯成本可以压缩。
WORKER_PREFETCH_MULTIPLIER = 20
# 非常重要,有些情况下可以防止死锁
CELERYD_FORCE_EXECV = True
# celery 的 worker 执行多少个任务后进行重启操作
CELERY_WORKER_MAX_TASKS_PER_CHILD = 100
# 禁用所有速度限制，如果网络资源有限，不建议开足马力。
worker_disable_rate_limits = True

# celery beat配置
CELERY_ENABLE_UTC = False
settings.USE_TZ = True
timezone = settings.TIME_ZONE
# 保存定时任务记录的驱动类，使用mysql数据库来进行定时任务
CELERY_BEAT_SCHEDULER = 'django_celery_beat.schedulers:DatabaseScheduler'
```

tasks.py

```python
from .main import app

# 经过@app.task装饰过，就会被celery识别为任务，否则就是普通的函数
@app.task
def task1(a, b, c):
    print("任务1函数正在执行....")
    return a + b + c

@app.task
def task2():
    print("任务2函数正在执行....")

```

上述配置做完之后，我们需要执行数据库迁移指令，去生成django_celery_beat应用的表

```python
cd ../..
python manage.py makemigrations
python manage.py migrate
```



完成了数据迁移以后，我们接下来就要启动celery和celery_beat，让celery正常工作起来。

```shell
# 命令必须在manage.py的父目录下执行
# 启动定时任务首先需要有一个work执行异步任务，然后再启动一个定时器触发任务。
celery -A celery_tasks.main worker -l info

# 启动定时器触发 beat  (注意：下面是一条完整指令)
celery -A celery_tasks.main beat -l info --scheduler  django_celery_beat.schedulers:DatabaseScheduler
```

接下来，我们还没有提供客户端的操作界面，所以我们要测试celery的定时任务，可以先在django的终端下进行测试。

普通周期任务

```python
# 进入django提供的shell终端，执行如下指令
python manage.py shell

from django_celery_beat.models import PeriodicTask, IntervalSchedule
# executes every 10 seconds.
# 从定时器数据表中获取一个10秒的计时器信息，如果没有则先创建一个再读取出来。
schedule, _ = IntervalSchedule.objects.get_or_create(
  		every=10,
  		period=IntervalSchedule.SECONDS, # 单位，下面有说明
)
"""
   # 可以看到上面固定间隔的时间是采用秒 period=IntervalSchedule.SECONDS，
   # 如果你还想要固定其他的时间单位，可以设置其他字段参数，如下：
   IntervalSchedule.DAYS 固定间隔天数
   IntervalSchedule.HOURS 固定间隔小时数
   IntervalSchedule.MINUTES 固定间隔分钟数
   IntervalSchedule.SECONDS 固定间隔秒数
   IntervalSchedule.MICROSECONDS 固定间隔微秒

   # 可以从源码中进行查看
   # from django_celery_beat.models import PeriodicTask, IntervalSchedule                                                                                                  
   # IntervalSchedule.PERIOD_CHOICES                                                                                                                                       
   # 能够看到单位选项：
   (
      ('days', 'Days'),
      ('hours', 'Hours'),
      ('minutes', 'Minutes'),
      ('seconds', 'Seconds'),
      ('microseconds', 'Microseconds')
   )
"""
# 执行定时任务，带参数的
import json
from datetime import datetime, timedelta
# 带参数的任务写法：
period_obj = PeriodicTask.objects.create(
     interval=schedule,                  # we created this above.
     name='task23',                       # 唯一的任务名称，名字不能重复
     task='celery_tasks.tasks.task1',    # 任务的导包路径
     args=json.dumps([5, 10, 15]),  # 异步任务有参数时，可以通过args或者kwargs来设置
     #kwargs=json.dumps({
     #   'be_careful': True,
     #}),
     expires=datetime.utcnow() + timedelta(seconds=30), # 任务的持续时间
)

# 不带参数的任务写法：
period_obj1 = PeriodicTask.objects.create(
     interval=schedule,                  # we created this above.
     name='task30',                       # 唯一的任务名称，名字不能重复
     task='celery_tasks.tasks.task2',    # 任务的导包路径
     expires=datetime.utcnow() + timedelta(seconds=30), # 任务的持续时间
)

# 可以查看所有计划任务
PeriodicTask.objects.all()
# 所有任务执行都是ok的，只要数据库改变了，那么beat任务会自动调用执行，因为celery一直处于轮询状态。

# 暂停执行两个周期性任务
task = PeriodicTask.objects.get(name="task1")
task.enabled = False # 把执行状态改成False，就可以暂停了。                       
task.save() 

# 把暂停的任务，重启激活。设置任务的 enabled 为 True 即可：
task = PeriodicTask.objects.get(name="task1")
task.enabled = True                                     
task.save()

# 删除任务
task = PeriodicTask.objects.get(name="task2")
task.delete()

# 注意：如果celery中的任务文件代码发生改变，例如tasks.py中的任务逻辑修改了，都需要重启beat和worker  
```



基于 crontab 的周期性任务

```python
import pytz  
# 创建周期
# https://docs.celeryproject.org/en/v4.4.7/userguide/periodic-tasks.html#crontab-schedules
from django_celery_beat.models import CrontabSchedule, PeriodicTask
schedule, _ = CrontabSchedule.objects.get_or_create( 
     minute='*', 
     hour='*', 
     day_of_week='*', 
     day_of_month='*', 
     month_of_year='*', 
     timezone=pytz.timezone('Asia/Shanghai') 
)

# 查看crontab数据表的中所有crontab定时器
CrontabSchedule.objects.all()  


# 执行周期任务
PeriodicTask.objects.create(  
     crontab=schedule, # 上面创建的 crontab 对象 * * * * *，表示每分钟执行一次
     name='my_task2_crontab', # 设置任务的name值，还是一样，name必须唯一
     task='celery_tasks.tasks.task2',  # 指定需要周期性执行的任务，任务也可以通过args或kwargs添加参数
)

# 返回值
# <PeriodicTask: my_task2_crontab: * * * * * (m/h/d/dM/MY) Asia/Shanghai>
```





后端编写计划任务的异步任务注册celery中。

celery_tasks/tasks.py

```python
from .main import app

# 经过@app.task装饰过，就会被celery识别为任务，否则就是普通的函数
@app.task
def task1(a, b, c):
    print("任务1函数正在执行....")
    return a + b + c

"""
import json
from datetime import datetime, timedelta
period_obj = PeriodicTask.objects.create(
     interval=schedule,                  # we created this above.
     name='task23',                       # 唯一的任务名称，名字不能重复
     task='celery_tasks.tasks.task1',    # 任务的导包路径
     args=json.dumps([5, 10, 15]),  # 异步任务有参数时，可以通过args或者kwargs来设置
     #kwargs=json.dumps({
     #   'be_careful': True,
     #}),
     expires=datetime.utcnow() + timedelta(seconds=30), # 任务的持续时间
)
"""

@app.task
def task2():
    print("任务2函数正在执行....")

"""
period_obj1 = PeriodicTask.objects.create(
     interval=schedule,                  # we created this above.
     name='task30',                       # 唯一的任务名称，名字不能重复
     task='celery_tasks.tasks.task2',    # 任务的导包路径
     expires=datetime.utcnow() + timedelta(seconds=30), # 任务的持续时间
)
"""

# hippo计划任务
import json
from host.models import Host
from django.conf import settings
from hippo_api.utils.key import AppSetting
@app.task(name='schedule_task')
def schedule_task(cmd, hosts_ids):
    """计划任务"""
    hosts_objs = Host.objects.filter(id__in=hosts_ids)
    result_data = []
    private_key, public_key = AppSetting.get(settings.DEFAULT_KEY_NAME)
    for host_obj in hosts_objs:
        cli = host_obj.get_ssh(private_key)
        code, result = cli.exec_command(cmd)
        result_data.append({
            'host_id': host_obj.id,
            'host': host_obj.ip_addr,
            'status': code,
            'result': result
        })
        print('>>>>', code, result)

    return json.dumps(result_data)
```

Schedule/views.py

```python
import json
import random
from datetime import datetime, timedelta

from django_celery_beat.models import IntervalSchedule, PeriodicTask
from rest_framework.response import Response
from rest_framework.views import APIView
from .models import TaskSchedule, TaskHost


class PeriodView(APIView):
    # 获取计划任务的周期类型数据返回给客户端
    def get(self,request):
        data = TaskSchedule.period_way_choices
        return Response(data)


class TaskView(APIView):
    def get(self,request):
        # 1. 获取任务列表数据返回给客户端
        # 2. 去redis中获取每个任务的执行结果展示给客户端
        pass

    def post(self,request):
        task_data = request.data
        period_way = request.data.get('period_way') # 计划任务的周期类型
        hosts_ids = request.data.get('hosts')       # 计划任务的执行的远程主机列表
        task_cmd = request.data.get('task_cmd')     # 计划任务要执行的任务指令
        period_content = request.data.get('period_content') # 计划任务的周期的时间值
        task_name = request.data.get('task_name')   # 任务名称，注意不能重复
        try:
            PeriodicTask.objects.get(name=task_name)
            task_name = f"{task_name}-{str(random.randint(1000,9999))}"
        except:
            pass

        if period_way == '1':  # 普通周期任务,默认单位为秒数，可以选择修改
            schedule, created = IntervalSchedule.objects.get_or_create(
                every=int(period_content),
                period=IntervalSchedule.SECONDS,
            )
            period_obj = PeriodicTask.objects.create(
                interval=schedule,  # we created this above.
                name=task_name,  # simply describes this periodic task.
                task='schedule_task',  # name of task.
                # task='my_task2',  # name of task.
                args=json.dumps([task_cmd, hosts_ids]),
                expires=datetime.utcnow() + timedelta(seconds=30)
            )
            period_beat = period_obj.id
        elif period_way == '2':   # 一次性任务
            period_beat = 1
            pass
        else:  # cron任务
            period_beat = 1
            pass


        # 保存任务
        task_schedule_obj = TaskSchedule.objects.create(**{
            'period_beat':period_beat, # celery-beat的任务id值
            'period_way':period_way,
            'task_cmd':task_cmd,
            'period_content':period_content,
            'task_name':task_name,
            'period_status':'1' , # 默认为激活状态
        })

        for host_id in hosts_ids:

            TaskHost.objects.create(**{
                'tasks_id': task_schedule_obj.id,
                'hosts_id': host_id,
            })

        return Response({'errormsg': 'ok'})

```

schedule/urls.py

```python
from django.urls import path
from . import views

urlpatterns = [
    path('periods/', views.PeriodView.as_view()),
    path('tasks/', views.TaskView.as_view()),
]
```

前端实现

components/Schedule.vue，代码：

```html
<template>
  <div class="schedule">
    <h1>任务计划</h1>

    <a-form-model
      ref="ruleForm"
      :model="form"
      :rules="rules"
      :label-col="labelCol"
      :wrapper-col="wrapperCol"
    >
      <a-form-model-item ref="task_name" label="任务名称：" prop="task_name">
        <a-input
          v-model="form.task_name"
          @blur="
          () => {
            $refs.task_name.onFieldBlur();
          }
        "
        />
      </a-form-model-item>
      <a-form-model-item label="请选择主机：" prop="hosts">
        <a-select
          mode="multiple"
          :value="form.hosts"
          style="width: 100%"
          placeholder="请选择主机"
          @change="handleHostChange"
        >
          <a-select-option v-for="(host_value,host_index) in host_list" :key="host_index" :value="host_value.id">
           {{host_value.ip_addr}}--{{host_value.hostname}}
          </a-select-option>
        </a-select>


      </a-form-model-item>
      <a-form-model-item label="请选择周期方式：" prop="hosts">
        <a-select style="width: 120px" @change="handlePeriodChange">
          <a-select-option v-for="(period_value,period_index) in period_way_choices" :value="period_value[0]" :key="period_index">
            {{period_value[1]}}
          </a-select-option>

        </a-select>


      </a-form-model-item>

      <a-form-model-item ref="period_content" label="任务周期值：" prop="period_content">
        <a-input v-model="form.period_content" />
      </a-form-model-item>

      <a-form-model-item ref="period_content" label="任务指令：" prop="period_content">
        <editor v-model="form.task_cmd" @init="editorInit" lang="html" theme="chrome" width="500" height="300"></editor>
      </a-form-model-item>

      <a-form-model-item :wrapper-col="{ span: 14, offset: 4 }">
        <a-button type="primary" @click="onSubmit">
          添加任务
        </a-button>
        <a-button style="margin-left: 10px;" @click="resetForm">
          重置任务
        </a-button>
      </a-form-model-item>
    </a-form-model>
  </div>
</template>
<script>
  export default {
    name: 'Schedule',
    data() {
      return {
        labelCol: {span: 4},
        wrapperCol: {span: 14},
        other: '',
        // selectedItems:[], // 选择的主机id数据
        period_way_choices:[],  // 所有周期类型数据
        host_list:[], // 主机列表数据
        form: {
          task_name: '',
          hosts: [],
          period_way:'1',
          task_cmd:'',
          period_content:'',
        },
        rules: {
          task_name: [
            {required: true, message: '请输入任务名称', trigger: 'blur'},
          ],


        },
      };
    },
    components: {
      editor: require('vue2-ace-editor'),
    },
    created() {
      // 获取所有主机数据
      this.get_host_list();
      // 获取计划任务的周期类型选项数据
      this.get_period_data();
    },

    methods: {
      get_period_data(){
        this.$axios.get(`${this.$settings.host}/schedule/periods/`)
        .then((res)=>{
          this.period_way_choices = res.data;
          console.log(this.period_way_choices);
        }).catch((error)=>{
        })
      },

      get_host_list() {
        let token = sessionStorage.token || localStorage.token;
        this.$axios.get(`${this.$settings.host}/host/host/`,{
          headers:{
            Authorization: "jwt " + token
          }
        })
          .then((res) => {
            this.host_list = res.data;
          })

      },

      editorInit: function () {
        require('brace/ext/language_tools') //language extension prerequsite...
        require('brace/mode/html')
        require('brace/mode/javascript')    //language
        require('brace/mode/less')
        require('brace/theme/chrome')
        require('brace/snippets/javascript') //snippet
      },

      handlePeriodChange(value) {
        console.log(`selected ${value}`);
        this.form.period_way = value;
      },

      handleHostChange(value) {
        this.form.hosts = value;
        // console.log(typeof value);
        // console.log(value[1]);
        console.log(`selected hosts ${this.form.hosts}`);
      },

      onSubmit() {
        this.$refs.ruleForm.validate(valid => {
          if (valid) {
            console.log(this.form);
            this.$axios.post(`${this.$settings.host}/schedule/tasks/`,this.form)
            .then((res)=>{
              console.log(res.data);
            })

          } else {
            console.log('error submit!!');
            return false;
          }
        });
      },
      resetForm() {
        this.$refs.ruleForm.resetFields();
      },
    },
  };
</script>


<style scoped>

</style>
```



router/index.js

```js
// ..
import Schedule from '@/components/Schedule'

// ....
        {
          path: 'schedule',
          name: 'Schedule',
          component: Schedule,
        },
      ]
    },

  ]
})

```
