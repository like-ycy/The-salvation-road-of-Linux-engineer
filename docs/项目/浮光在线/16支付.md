发起支付

支付的实现一般我们开发中都是通过第三方支付平台来实现的！ 

目前国内外比较常见的第三方支付平台：

```
小额支付
1. 国内
   微信，支付宝，京东支付，百度钱包，贝宝[paypal中文版]
2. 国外
   apple pay，paypal，万事达信用卡
   
大额支付
   银联支付
```



## 支付宝

### 支付宝开发平台登录

官网：https://open.alipay.com/platform/home.htm

公司以企业账号进行支付签约：https://b.alipay.com/signing/productDetailV2.htm?productId=I1011000290000001000

目前我们是作为开发者给项目测试支付功能，所以我们先采用支付平台提供的测试服务端使用测试账号进行功能测试。将来等企业账号申请支付签约通过以后，则可以直接修改代码中的配置信息，就可以在线上运营使用了。

![image-20210809091621044](16%E6%94%AF%E4%BB%98.assets/image-20210809091621044-16382743851961.png)

### 沙箱环境

- 是支付宝提供给开发者的模拟支付的环境
- 沙箱环境跟真实环境是分开的，项目上线时必须切换对应的配置服务器地址和开发者ID和密钥。
- **沙箱文档**：https://opendocs.alipay.com/support/01razc
- **沙箱接口**：https://opendocs.alipay.com/open/200/105311#沙箱支持产品
- **沙箱账号**：https://openhome.alipay.com/platform/appDaily.htm?tab=info

```
真实的支付宝网关: https://openapi.alipay.com/gateway.do
沙箱的支付宝网关: https://openapi.alipaydev.com/gateway.do
```



### 支付宝开发者文档

- **电脑网站支付产品介绍**：https://opendocs.alipay.com/open/270

### 电脑网站支付流程

时序图[ 时间顺序流程图 ]

![电脑网站支付流程图](16%E6%94%AF%E4%BB%98.assets/%E7%94%B5%E8%84%91%E7%BD%91%E7%AB%99%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B%E5%9B%BE-16382743851972.png)

![](16%E6%94%AF%E4%BB%98.assets/%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B%E6%97%B6%E5%BA%8F%E5%9B%BE-16382743851983.png)



### 开发支付功能

```
git add .
git commit -m "下单过程中的积分抵扣"
git push

git checkout -b feature/payments

cd fuguangapi/apps
python ../../manage.py startapp payments
```

注册子应用，settings/dev.py，代码：

```python
INSTALLED_APPS = [
	。。。。
    'payments',
]
```

子应用路由，`payments.urls`，代码：

```python
from django.urls import path,re_path
from . import views
urlpatterns = [

]
```

总路由，`fuguangapi.urls`，代码：

```python
    path("payments/", include("payments.urls")),
```



### 配置秘钥

```
RSA2算法：非对称加密算法。一般加密的密钥是成对出现的。
私钥用于解密，自己保存，
公钥用于加密，提供给别人。
目前所有的第三方支付基本都是使用RSA2算法加密。所以要开发支付宝这种第三方支付平台的支付接口基本都有2对密钥。
支付宝密钥对：支付宝公钥，支付宝密钥。
商户（应用）密钥对：应用公钥，应用私钥。

往往我们需要从支付宝的官网上获取支付宝的公钥，把自己的应用公钥填写到支付宝官网。
```



#### 1. 生成应用的私钥和公钥

##### 支付宝公钥

获取支付宝公钥：https://openhome.alipay.com/platform/appDaily.htm?tab=info

第一次需要启用RSA2秘钥( 公钥模式 )

![image-20210928173730216](16%E6%94%AF%E4%BB%98.assets/image-20210928173730216-16382743851984.png)

点击**启用**了以后，就可以新窗口下看到支付宝提供的公钥。

![image-20210928173916579](16%E6%94%AF%E4%BB%98.assets/image-20210928173916579-16382743851985.png)

得到了公钥以后，复制保存到fuguangapi/apps/payments/keys/alipay_public_key.pem，这个pem文件一般就直接保存到当前子应用目录下的keys目录下。

内容格式如下：

```
-----BEGIN PUBLIC KEY-----
公钥信息[不能手动调整，复制下来就原样不动]
-----END PUBLIC KEY-----
```

效果如下：

![image-20210928174342691](16%E6%94%AF%E4%BB%98.assets/image-20210928174342691-16382743851986.png)



##### 应用公钥和私钥

应用的公钥和私钥，理论上是需要开发者自己的通过工具/命令来生成的。但是往往很多开发者没有这个能力，所以支付宝提供了至少3种方式给开发者生成秘钥对。

有3种常用方式可以生成秘钥对：

1. 界面工具生成，直接打开网页https://miniu.alipay.com/keytool/create，在线上生成即可（记得，务必备份！！！）。

   下载对应系统的秘钥生成工具在本地安装工具生成:  https://doc.open.alipay.com/docs/doc.htm?treeId=291&articleId=105971&docType=1

2. 命令行生成，直接通过ssl证书生成工具来生成。必须当前操作系统要直接openssl模块，一般Linux或者MACOS默认内置了。windows系统需要通过微软官方下载openssl才能生成。

##### 在线生成

![image-20210809111722498](16%E6%94%AF%E4%BB%98.assets/image-20210809111722498-16382743851987.png)

##### 本地生成

Linux系统，生成如下:

```bash
cd payments/keys/
openssl
OpenSSL> genrsa -out app_private_key.pem 2048                         # 生成私钥到指定文件中
OpenSSL> rsa -in app_private_key.pem -pubout -out app_public_key.pem  # 导出公钥
OpenSSL> exit
```

应用公钥的内容要复制粘贴到支付宝网站页面中（如果测试沙箱环境下，不需要自己上传公钥，当时企业账号开通的支付应用就需要上传公钥：https://openhome.alipay.com/dev/workspace/key-manage）

注意：接下来的步骤属于在企业账号申请的正式支付应用时上传应用公钥的步骤。

![image-20210928175746580](16%E6%94%AF%E4%BB%98.assets/image-20210928175746580-16382743851988.png)

把生成的应用公钥粘贴到窗口下方，点击保存设置即可。

![image-20210928175820970](16%E6%94%AF%E4%BB%98.assets/image-20210928175820970-16382743851989.png)

完成了上面步骤以后，效果如下：

![image-20210928180034735](16%E6%94%AF%E4%BB%98.assets/image-20210928180034735-163827438519810.png)

如果是沙箱环境下的支付宝应用开发，是不需要我们自己手动生成应用的公钥私钥的。因为平台已经内置了一对公私钥给开发者了。非JAVA语言！

![image-20210928180351396](16%E6%94%AF%E4%BB%98.assets/image-20210928180351396-163827438519811.png)

因为我们现在就需要使用沙箱环境来开发支付应用，所以我们需要把沙箱应用提供的私钥保存到本地keys目录下，为了方便记录，所以也可以把应用公钥也保存下来（应用公钥不是必须保存到本地的）。

fuguangapi/apps/payments/keys/app_private_key.pem，代码：

```bash
-----BEGIN RSA PRIVATE KEY-----
MIIEpAIBAAKCAQEAyH1NvkT6cyobA03SkfLbhStd5/6zWHPUTlgT55MA6/duWpNEVLLZQ0mG1wVYvPjJXc3LZ/ckGDNUblr6AbLFBSajjqo7rLbVC30N/3aRYknaBY8sPVyGE/TLvGlEs1IWj+y8v4uK9Minz0gtdzfGGl6QHEZ0YI8fmxWSPos/h15OJ1jMT77Ym47kpXZj4vBzGD1uGN1iOp2o907/Yfk1fkV9+56Yipum5MV7pkyFg2/uEbJkNvWZw3uuY07HnZGgr72idF708g4YDygLYUD4DVaTqKCiiXUcsobfy4/YdOOer2z/2UYgS8fpd3IiYlmYCFkVj8jS6mLIe351CpkfDwIDAQABAoIBADXdtK2SStf2UBurJRAhd+lnpWtXe0gglsIV2AM3899yMywStSEsjEMP1jKfNSBQl4mkaSodtIzr/ZtIxjL+nQCtSPRjuHTHCqZzivdAG/+UaAdmWDSET2G9O5/7iIHFZFp2+J9eFo99+dgvREfrrEYZcg6mv03SJmO8f/Zd40uzCPzJFAiHYINSSb4ft0V7y8f1721Rj/cNYXVJAlnf2bjLvOmK9xsoa2jjxZg+CWcXCmDDFI0dvMoXpMcDrpZJ9IM9UfVL/ZgQU8IcG/eteuDTlb8WtYfPnnYH9w41AG0TC0dwCfIijPzCHBt8a1Uf7I5AGREWXMWyEBKxLRbolIECgYEA5Zk064Wny1tgCUM4Fi6Ks3etLFBGJjNdTYE6UwQvl3r7wxyBGEZ8ex23eDH0NF2veo5YCAFwIyQweel2mGxDAp5paz6O9/tJa15u7pCdY9CZCl+5/KIimsF4jSTOCqUyGAZ4S/CQ8xfQJYINLyObluAMFJIgDdKdlKo9yYOHkFkCgYEA34szzP5DlWlQ+oyPLWk3Unkb9IGCr91rCTDXCKzYzTnCJRpRtxNk+nFYeXOYJc4pzrQfx1QT6pYoNj149fBl1sB3YduzkPf2KtohtDJRqLuKnOcE0lsXy7eBR76od9PUh8l5gnIBX3WUii/kGFNl7s6OurjPw97pSouQdl9S/acCgYBy/mD69V4tA/79pKUatwTRDke1wh7gUymQAAFuQtJzVC10c3pU5jjCkQerM5nUAHg7Mb/1goLfluiQptW3UcHeNekmxZZlrX4AQLPe2J97tqZwA7HrTml2iSAP0TdBLawBTHxDzKFMn8iogJKJ4ZOz5VMnmmhjg/FY3EtF+pKTQQKBgQCwJEeU52TpfirIwaiv55An9DYK22HWoWmNvGYz9759N127TpnE4AtZK6bDTEo+v8xBi7zem2l2Fwtocde2Ms6MAOwQt8UuHbRi365fBqdBhUUbjQ1Hk2+UnevIVHr6sHdu51pPZvWd+lAo8sOQR2ayXSAqESXk+OhqTL5wB3ylUQKBgQDMgCVMw8w5k+VJoUqw7uYWZf/k7ha28qty1yfh2TQ6JuIf5rBcI4n69FPCLmm4cqnTl+mOCdKfirp68bIpjVfjsl7bpfZXCKkGwmHY65l/sCD5FQnSkYNhsfWoVOEN8lSR6gPyJT3wknQy4dGCOzi92yKlDDeDS8nM96Mt2NVa7Q==
-----END RSA PRIVATE KEY-----
```

效果如下：

![image-20210928180618251](16%E6%94%AF%E4%BB%98.assets/image-20210928180618251-163827438519812.png)

如果要保留公钥到本地将来作为备份，或者用着其他的支付方式，可以保存，但是不推荐。

fuguangapi/apps/payments/keys/app_public_key.pem，代码：

```
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAyH1NvkT6cyobA03SkfLbhStd5/6zWHPUTlgT55MA6/duWpNEVLLZQ0mG1wVYvPjJXc3LZ/ckGDNUblr6AbLFBSajjqo7rLbVC30N/3aRYknaBY8sPVyGE/TLvGlEs1IWj+y8v4uK9Minz0gtdzfGGl6QHEZ0YI8fmxWSPos/h15OJ1jMT77Ym47kpXZj4vBzGD1uGN1iOp2o907/Yfk1fkV9+56Yipum5MV7pkyFg2/uEbJkNvWZw3uuY07HnZGgr72idF708g4YDygLYUD4DVaTqKCiiXUcsobfy4/YdOOer2z/2UYgS8fpd3IiYlmYCFkVj8jS6mLIe351CpkfDwIDAQAB
-----END PUBLIC KEY-----
```

效果：

![image-20210928180832892](16%E6%94%AF%E4%BB%98.assets/image-20210928180832892-163827438519813.png)



#### 4. 使用支付宝的sdk开发支付接口

SDK：https://opendocs.alipay.com/open/54/103419

python版本的支付宝SDK文档：https://github.com/fzlee/alipay/blob/master/README.zh-hans.md

安装命令：

```
pip install python-alipay-sdk --upgrade
```

使用文档：https://github.com/fzlee/alipay/blob/master/docs/apis.zh-hans.md

调整原来下单的序列化器，不在序列化器中返回支付信息，而是由客户端根据订单号请求服务端生成支付信息。

orders/serializers.py，代码：

```python
import random, logging, constants
from django.db import transaction
from django.utils.decorators import method_decorator
from django_redis import get_redis_connection
from rest_framework import serializers
from .models import Order, OrderDetail
from courses.models import Course
from datetime import datetime
from coupon.models import CouponLog

logger = logging.getLogger("django")

class OrderModelSerializer(serializers.ModelSerializer):
    """订单序列化器"""
    user_coupon_id = serializers.IntegerField(write_only=True, default=-1)

    class Meta:
        model = Order
        fields = ["id", "pay_type", "order_number", "user_coupon_id", "credit"]
        read_only_fields = ["order_number",]
        extra_kwargs = {
            "pay_type": {"write_only": True},
        }

    def create(self, validated_data):
        """创建订单"""
        # 本次客户端的HTTP请求对象
        user = self.context["request"].user
        user_id = user.id
        # 判断用户如果使用了优惠券，则优惠券需要判断验证
        user_coupon_id = validated_data.get("user_coupon_id")
        # 本次下单时，用户使用的优惠券
        user_coupon = None
        if user_coupon_id != -1:
            user_coupon = CouponLog.objects.filter(pk=user_coupon_id, user_id=user_id).first()

        # 本次下单时使用的积分数量
        use_credit = validated_data.get("credit", 0)
        # 如果本次下单用户使用了抵扣积分，并且抵扣的积分数量 > 用户拥有的积分数量，则报错。
        if use_credit > 0 and use_credit > user.credit:
            raise serializers.ValidationError(detail="您拥有的积分不足以抵扣本次下单的积分，请重新下单！", code="credit")

        redis = get_redis_connection("cart")
        # 唯一订单号[基于时间、用户ID、随机数]
        # order_number = datetime.now().strftime("%Y%m%d%H%M%S") + ("%08d" % user_id) + "%08d" % random.randint(1,99999999)
        # 基于redis生成分布式唯一订单号
        order_number = datetime.now().strftime("%Y%m%d") + ("%08d" % user_id) + "%08d" % redis.incr("order_number")
        # 开启事务操作
        with transaction.atomic():
            # 设置事务的回滚点标记
            t1 = transaction.savepoint()
            try:
                # 创建订单基本信息的记录
                order = Order.objects.create(
                    name="课程购买",   # 订单标题
                    user_id=user_id, # 用户ID
                    total_price=0,   # 订单总价，先默认为0，后面计算了所有的课程价格以后。累加得出
                    real_price=0,    # 订单实价，先默认为0，后面计算了所有的课程价格以后。累加得出
                    order_number=order_number, # 订单号
                    pay_type=validated_data.get("pay_type"),  # 支付方式
                )

                # 记录本次下单的商品列表
                cart_hash = redis.hgetall(f"cart_{user_id}")
                if len(cart_hash) < 1:

                    raise serializers.ValidationError(detail="购物车中没有商品")

                # 提取购物车中所有勾选状态为b'1'的商品
                course_id_list = [int(course_id.decode()) for course_id, selected in cart_hash.items() if selected == b'1']

                # 添加订单与课程的关系
                course_list = Course.objects.filter(pk__in=course_id_list, is_delete=False, is_show=True).all()

                detail_list = []  # 订单详情的模型列表[避免出现在循环中执行IO操作]
                total_price = 0   # 订单总价
                real_price = 0    # 订单实价

                total_discount_price = 0  #
                max_discount_course = None  # 享受最大优惠的课程

                # 本次下单最多可以抵扣的积分
                max_use_credit = 0

                for course in course_list:
                    # 判断商品课程是否有优惠价格，有就转换数据类型
                    try:
                        discount_price = float(course.discount["price"])
                    except:
                        discount_price = 0

                    # 判断商品课程是否有优惠，有就记录优惠类型
                    try:
                        discount_name = course.discount["type"]
                    except:
                        discount_name = ""

                    detail_list.append(OrderDetail(
                        order=order,
                        course=course,
                        name=course.name,
                        price=course.price,
                        real_price=discount_price,
                        discount_name=discount_name,
                    ))

                    # 统计订单的总价和实付价格
                    total_price += float(course.price)
                    real_price += float(course.price) if discount_price == 0 else discount_price

                    # 在用户使用了优惠券，并且当前课程没有参与其他优惠活动时，找到最佳优惠课程
                    if user_coupon and discount_price is None:
                        if max_discount_course is None:
                            max_discount_course = course
                        else:
                            if course.price >= max_discount_course.price:
                                max_discount_course = course

                    # 添加每个课程的可用积分
                    if use_credit > 0:
                        max_use_credit += course.credit

                # 在用户使用了优惠券以后，根据循环中得到的最佳优惠课程进行计算最终抵扣金额
                if user_coupon:
                    # 优惠公式
                    sale = float(user_coupon.coupon.sale[1:])
                    if user_coupon.coupon.discount == 1:
                        """减免优惠券"""
                        total_discount_price = sale
                    elif user_coupon.coupon.discount == 2:
                        """折扣优惠券"""
                        total_discount_price = float(max_discount_course.price) * (1 - sale)

                # 在用户使用了积分抵扣以后
                if use_credit > 0:
                    # 如果本次下单最大可用积分数量 < 用户提交的抵扣数量，则报错
                    if max_use_credit < use_credit:
                        raise serializers.ValidationError(detail="本次使用的抵扣积分数额超过了限制！")

                    # 当前订单添加积分抵扣的数量
                    order.credit = use_credit
                    total_discount_price = float(use_credit / constants.CREDIT_TO_MONEY)

                    # todo 扣除用户拥有的积分，后续在订单超时未支付或用户取消下单时，则返还订单中对应数量的积分给用户。
                    #  如果订单成功支付，则添加一个积分流水记录。
                    user.credit = user.credit - use_credit
                    user.save()

                # 一次性批量添加本次下单的商品记录
                OrderDetail.objects.bulk_create(detail_list)

                # 保存订单的总价格和实付价格
                order.total_price = total_price
                order.real_price = float(real_price - total_discount_price)
                order.save()

                # 找出购物车中的没有被勾选的商品信息
                cart = {key: value for key, value in cart_hash.items() if value == b'0'}
                pipe = redis.pipeline()
                pipe.multi()
                # 删除原来的购物车
                pipe.delete(f"cart_{user_id}")
                # 重新把未勾选的商品记录到购物车中
                if len(cart) > 0:
                    pipe.hmset(f"cart_{user_id}", cart)
                pipe.execute()

                # 如果有使用了优惠券，则把优惠券和当前订单进行绑定
                if user_coupon:
                    redis = get_redis_connection("coupon")
                    user_coupon.order = order
                    user_coupon.save()
                    # 把优惠券从redis中移除
                    redis.delete(f"{user_id}:{user_coupon_id}")

                    # todo 将来订单状态发生改变，再修改优惠券的使用状态，如果订单过期，则再次还原优惠券到redis中

                return order
            except Exception as e:
                # 1. 事务回滚
                transaction.savepoint_rollback(t1)
                # 2. 日志记录
                logger.error(f"生成订单失败！{e}")
                # 3. 抛出异常
                raise serializers.ValidationError(detail="生成订单失败！")


```



### 后端提供发起支付的api接口

payments/views.py，代码:

```python
from django.conf import settings
from rest_framework.viewsets import ViewSet
from rest_framework.response import Response
from orders.models import Order
from alipay import AliPay
from alipay.utils import AliPayConfig


class AlipayAPIViewSet(ViewSet):
    """支付宝接口"""

    def link(self, request, order_number):
        """生成支付宝支付链接信息"""
        try:
            order = Order.objects.get(order_number=order_number)
            if order.order_status > 0:
                return Response({"message": "对不起，当前订单不能重复支付或订单已超时！"})
        except Order.DoesNotExist:
            return Response({"message": "对不起，当前订单不存在！"})

        app_private_key_string = open(settings.ALIPAY["app_private_key_path"]).read()
        alipay_public_key_string = open(settings.ALIPAY["alipay_public_key_path"]).read()

        # 创建alipay SDK操作对象
        alipay = AliPay(
            appid=settings.ALIPAY["appid"],
            app_notify_url=settings.ALIPAY["notify_url"],  # 默认全局回调 url
            app_private_key_string=app_private_key_string,
            # 支付宝的公钥，验证支付宝回传消息使用，不是你自己的公钥,
            alipay_public_key_string=alipay_public_key_string,
            sign_type=settings.ALIPAY["sign_type"],  # RSA2
            debug=settings.ALIPAY["debug"],  # 默认 False，沙箱模式下必须设置为True
            verbose=settings.ALIPAY["verbose"],  # 输出调试数据
            config=AliPayConfig(timeout=settings.ALIPAY["timeout"])  # 可选，请求超时时间，单位：秒
        )

        # 生成支付信息
        order_string = alipay.client_api(
            "alipay.trade.page.pay",  # 接口名称
            biz_content={
                "out_trade_no": order_number,             # 订单号
                "total_amount": float(order.real_price),  # 订单金额 单位：元
                "subject": order.name,                    # 订单标题
                "product_code": "FAST_INSTANT_TRADE_PAY", # 产品码，目前只能支持 FAST_INSTANT_TRADE_PAY
            },
            return_url=settings.ALIPAY["return_url"], # 可选，同步回调地址，必须填写客户端的路径
            notify_url=settings.ALIPAY["notify_url"]  # 可选，不填则使用采用全局默认notify_url，必须填写服务端的路径
        )

        # 拼接完整的支付链接
        link = f"{settings.ALIPAY['gateway']}?{order_string}"

        return Response({
            "pay_type": 0,
            "get_pay_type_display": "支付宝",
            "link": link
        })
```



#### 在配置文件中编辑支付宝的配置信息[实际的值根据自己的账号而定]

setttins/dev.py，代码：

```python
# 支付宝相关配置
ALIPAY = {
    # 'gateway': 'https://openapi.alipay.com/gateway.do',   # 真实网关地址
    'gateway': 'https://openapi.alipaydev.com/gateway.do',  # 沙箱网关地址
    'appid': '2016091600523592',  # 支付应用ID
    'sign_type': 'RSA2',  # 签证的加密算法
    'debug': True,  # 沙箱模式下必须设置为True
    'verbose': True,  # 是否在调试模式下输出调试数据
    'timeout': 15,  # 请求超时时间，单位：秒
    "app_private_key_path": BASE_DIR / "apps/payments/keys/app_private_key.pem",  # 应用私钥路径
    "alipay_public_key_path": BASE_DIR / "apps/payments/keys/alipay_public_key.pem",  # 支付宝公钥路径
    "return_url": "http://www.fuguang.cn:3000/alipay",  # 同步回调结果通知地址
    "notify_url": "http://api.fuguang.cn:8000/payments/alipay/notify",  # 异步回调结果通知地址
}

```

payments/urls.py，代码：

```python
from django.urls import path,re_path
from . import views
urlpatterns = [
    re_path("^alipay/(?P<order_number>[0-9]+)/$", views.AlipayAPIViewSet.as_view({"get":"link"})),
]
```



#### 前端生成订单以后，直接发起支付

`views/Order.vue`，代码：

```vue
<script setup>

// ... 代码省略
    
const commit_order = ()=>{
    // 生成订单
    let token = sessionStorage.token || localStorage.token;
    let user_coupon_id = -1;
    if(order.select !== -1){
        user_coupon_id = order.coupon_list[order.select].user_coupon_id;
    }
    order.create_order(user_coupon_id, token).then(response=>{
        // 成功提示
        ElMessage.success("下单成功！马上跳转到支付页面，请稍候~")
        // 扣除掉被下单的商品数量，更新购物车中的商品数量
        store.commit("set_cart_total", store.state.cart_total - cart.select_course_list.length);
        // 根据订单号到服务端获取支付链接，并打开支付页面。
        order.alipay_page_pay(response.data.order_number).then(response=>{
            window.open(response.data.link,"_blank");
        })
    })
}

// ... 代码省略

</script>
```

`src/api/order.js`，代码：

```javascript
import http from "../utils/http";
import {reactive} from "vue";

const order = reactive({
    // ... 代码省略
    alipay_page_pay(order_number){
        // 获取订单的支付宝支付链接信息
        return http.get(`/payments/alipay/${order_number}`)
    }
});

export default order;
```

完成了上面的功能以后,我们就可以在沙箱环境中进行支付宝的付款了,但是我们会接受到支付宝界面那边跳转回来的同步通知结果,跳转回到我们的客户端页面,

返回的结果.,我们不能保证一定是支付宝返回的,所以我们需要对照官方文档,查看这些参数的作用,

https://docs.open.alipay.com/api_1/alipay.trade.page.pay

```bash
http://www.fuguang.cn:3000/alipay?charset=utf-8&out_trade_no=202111300000000100000009&method=alipay.trade.page.pay.return&total_amount=2070.00&sign=ovBs5ltfrE0P35cD%2BTx20xWziCLM5Eajj24DxlRzYx9FUMJbomao1A6MCZq5sbKlt1ccR2VseyWMyepW%2B3IZbKOzhF%2BmMlNEvKWbIRAmripzKoREW%2FtiP2a3hdUsZeKgugM2oelJ4spocAAO%2F0nI0XO3g9SkqaURsU%2FuJIGZOLXV2ua8HZIviM298RfBBk9QhU6g5aBVJMzQI8QBFzPC8qFdluAR4Du3fPYZf%2BPtQAvnQczKUvc7eix96n57TeTfaImPdl8bdQphJDr6xQwLn1xVA1rxKfiBPJwIDoPPUuZ8o3P66SnpG9yamhvTCwyZzPsO6JnLCHR8ORWWRJwK4Q%3D%3D&trade_no=2021113022001439880503664521&auth_app_id=2016091600523592&version=1.0&app_id=2016091600523592&sign_type=RSA2&seller_id=2088102175868026&timestamp=2021-11-30+12%3A37%3A02
```



### 支付成功的模板

提供一个接受支付结果的页面，展示支付成功的信息。

views/AliPaySuccess.vue,代码:

```vue
<template>
  <div class="success">
    <Header/>
    <div class="main">
        <div class="title">
          <i class="el-icon-chat-dot-round"></i>
          <div class="success-tips">
              <p class="tips1">您已成功购买 1 门课程！</p>
              <p class="tips2">你还可以加入QQ群 <span>747556033</span> 学习交流</p>
          </div>
        </div>
        <div class="order-info">
            <p class="info1"><b>付款时间：</b><span>2019/04/02 10:27</span></p>
            <p class="info2"><b>付款金额：</b><span >0</span></p>
            <p class="info3"><b>课程信息：</b><span><span>《Pycharm使用秘籍》</span></span></p>
        </div>
        <div class="wechat-code">
          <img src="../assets/wechat.jpg" alt="" class="er">
          <p><i class="el-icon-warning"></i>重要！微信扫码关注获得学习通知&amp;课程更新提醒！否则将严重影响学习进度和课程体验！</p>
        </div>
        <div class="study">
          <span>立即学习</span>
        </div>
    </div>
    <Footer/>
  </div>
</template>

<script setup>
import Header from "../components/Header.vue"
import Footer from "../components/Footer.vue"
import {ElMessage} from "element-plus";
import order from "../api/order";

</script>
<style scoped>
.success{
  padding-top: 80px;
}
.main{
    height: 100%;
    padding-top: 25px;
    padding-bottom: 25px;
    margin: 0 auto;
    width: 1200px;
    background: #fff;
}
.main .title{
    display: flex;
    -ms-flex-align: center;
    align-items: center;
    padding: 25px 40px;
    border-bottom: 1px solid #f2f2f2;
}
.main .title .success-tips{
    box-sizing: border-box;
}
.title img{
    vertical-align: middle;
    width: 60px;
    height: 60px;
    margin-right: 40px;
}
.title .success-tips{
    box-sizing: border-box;
}
.title .tips1{
    font-size: 22px;
    color: #000;
}
.title .tips2{
    font-size: 16px;
    color: #4a4a4a;
    letter-spacing: 0;
    text-align: center;
    margin-top: 10px;
}
.title .tips2 span{
    color: #ec6730;
}
.order-info{
    padding: 25px 48px;
    padding-bottom: 15px;
    border-bottom: 1px solid #f2f2f2;
}
.order-info p{
    display: -ms-flexbox;
    display: flex;
    margin-bottom: 10px;
    font-size: 16px;
}
.order-info p b{
  font-weight: 400;
  color: #9d9d9d;
  white-space: nowrap;
}
.wechat-code{
    display: flex;
    -ms-flex-align: center;
    align-items: center;
    padding: 25px 40px;
    border-bottom: 1px solid #f2f2f2;
}
.wechat-code>img{
    width: 180px;
    height: 180px;
    margin-right: 15px;
}
.wechat-code p{
    font-size: 14px;
    color: #d0021b;
    display: -ms-flexbox;
    display: flex;
    -ms-flex-align: center;
    align-items: center;
}
.wechat-code p>img{
    width: 16px;
    height: 16px;
    margin-right: 10px;
}
.study{
  padding: 25px 52px;
}
.study span{
  display: block;
  width: 140px;
  height: 42px;
  text-align: center;
  line-height: 42px;
  cursor: pointer;
  background: #ffc210;
  border-radius: 6px;
  font-size: 16px;
  color: #fff;
}
.el-icon-warning{
  font-size: 22px;
  margin-right: 5px;
}
.el-icon-chat-dot-round{
  font-size: 122px;
  margin-right: 10px;
}
</style>
```

routers/index.js，路由代码:

```javascript
,
    {
      meta:{
        title: "支付成功",
        keepAlive: true
      },
      path: '/alipay',
      name: "PaySuccess",
      component: ()=> import("../views/AliPaySuccess.vue"),
    },
```

`src/api/order.js`，代码：

```javascript
import http from "../utils/http";
import {reactive} from "vue";

const order = reactive({
    // ... 代码省略
    // ... 代码省略
    // ... 代码省略
    course_list: [],     // 本次购买的商品课程列表
    real_price: 0,       // 付款金额
    pay_time: undefined, // 付款时间
    is_show: false,      // 是否展示支付成功的内容
    // ... 代码省略
    // ... 代码省略
    // ... 代码省略
    relay_alipay_result(query_string){
        // 把地址栏中的查询字符串(支付成功以后的同步回调通知)转发给服务端
        return http.get(`/payments/alipay/result/${query_string}`)
    }
});

export default order;
```

转发支付结果到服务端。AliPaySuccess.vue，代码：

```vue
<script setup>
import Header from "../components/Header.vue"
import Footer from "../components/Footer.vue"
import {ElMessage} from "element-plus";
import order from "../api/order";

let query_string = location.search; // 获取查询字符串的支付结果参数
order.relay_alipay_result(query_string).then(response=>{
  order.is_show = true;
  order.course_list = response.data.course_list;
  order.real_price  = response.data.real_price;
  order.pay_time    = response.data.pay_time;
}).catch(error=>{
  console.log(error);
})

</script>
```



### 服务端接收同步通知支付结果

支付宝会返回的参数如下列表：

```bash
http://www.fuguang.cn:3000/alipay?
charset=utf-8&
out_trade_no=202111300000000100000009&
method=alipay.trade.page.pay.return&
total_amount=2070.00&
sign=ovBs5ltfrE0P35cD%2BTx20xWziCLM5Eajj24DxlRzYx9FUMJbomao1A6MCZq5sbKlt1ccR2VseyWMyepW%2B3IZbKOzhF%2BmMlNEvKWbIRAmripzKoREW%2FtiP2a3hdUsZeKgugM2oelJ4spocAAO%2F0nI0XO3g9SkqaURsU%2FuJIGZOLXV2ua8HZIviM298RfBBk9QhU6g5aBVJMzQI8QBFzPC8qFdluAR4Du3fPYZf%2BPtQAvnQczKUvc7eix96n57TeTfaImPdl8bdQphJDr6xQwLn1xVA1rxKfiBPJwIDoPPUuZ8o3P66SnpG9yamhvTCwyZzPsO6JnLCHR8ORWWRJwK4Q%3D%3D&
trade_no=2021113022001439880503664521&
auth_app_id=2016091600523592&
version=1.0&
app_id=2016091600523592&
sign_type=RSA2&
seller_id=2088102175868026&
timestamp=2021-11-30+12%3A37%3A02
```



#### 服务端实现处理支付宝同步通知结果

因为我们需要多次对支付接口进行调用，所以我们可以在缩减重复代码的情况下，对原有代码进行封装。

`fuguangapi/utils/alipaysdk.py`，代码：

```python
from django.conf import settings
from alipay import AliPay
from alipay.utils import AliPayConfig
from datetime import datetime

class AliPaySDK(AliPay):
    """支付宝接口sdk工具类"""
    def __init__(self, config=None):
        if config is None:
            self.config = settings.ALIPAY
        else:
            self.config = config

        app_private_key_string = open(self.config["app_private_key_path"]).read()
        alipay_public_key_string = open(self.config["alipay_public_key_path"]).read()
        super().__init__(
            appid=self.config["appid"],
            app_notify_url=self.config["notify_url"],  # 默认全局回调 url
            app_private_key_string=app_private_key_string,
            # 支付宝的公钥，验证支付宝回传消息使用，不是你自己的公钥,
            alipay_public_key_string=alipay_public_key_string,
            sign_type=self.config["sign_type"],  # RSA 或者 RSA2
            debug=self.config["debug"],  # 默认 False，沙箱模式下必须设置为True
            verbose=self.config["verbose"],  # 输出调试数据
            config=AliPayConfig(timeout=self.config["timeout"])  # 可选，请求超时时间，单位：秒
        )

    def page_pay(self,order_number,real_price,order_name):
        """
        生成支付链接
        @parmas order_number: 商户订单号
        @parmas real_price: 订单金额
        @parmas order_name: 订单标题
        @return 支付链接
        """
        order_string = self.client_api(
            "alipay.trade.page.pay",
            biz_content={
                "out_trade_no": order_number,  # 订单号
                "total_amount": float(real_price),  # 订单金额
                "subject": order_name,  # 订单标题
                "product_code": "FAST_INSTANT_TRADE_PAY",
            },
            return_url=self.config["return_url"],  # 可选，同步回调地址，必须填写客户端的路径
            notify_url=self.config["notify_url"]  # 可选，不填则使用采用全局默认notify_url，必须填写服务端的路径
        )

        return f"{self.config['gateway']}?{order_string}"

    def check_sign(self, data):
        """
        验证返回的支付结果中的签证信息
        @params data: 支付平台返回的支付结果，字典格式
        """
        signature = data.pop("sign")
        success = self.verify(data, signature)
        return success

    def query(self,order_number):
        """
        根据订单号查询订单状态
        @params order_number: 订单号
        """
        return self.server_api(
            "alipay.trade.query",
            biz_content={
                "out_trade_no": order_number
            }
        )

    def refund(self,order_number, real_price):
        """
        原路退款
        @params order_number: 退款的订单号
        @params real_price: 退款的订单金额
        """
        self.server_api(
            "alipay.rade.refund",
            biz_content={
                "out_trade_no": order_number,
                "refund_amount": real_price
            }
        )

    def transfer(self, account,amount):
        """
        转账给个人
        @params account: 收款人的支付宝账号
        @params amount: 转账金额
        """
        return self.server_api(
            "alipay.fund.trans.toaccount.transfer",
            biz_content = {
                "out_biz_no": datetime.now().strftime("%Y%m%d%H%M%S"),
                "payee_type": "ALIPAY_LOGONID/ALIPAY_USERID",
                "payee_account": account,
                "amount": amount
            }
        )
```

#### 服务端完成支付成功后更新用户购买商品课程的记录

user/models.py，模型代码：

```python
from django.contrib.auth.models import AbstractUser
from django.utils.safestring import mark_safe
from fuguangapi.utils.models import BaseModel,models
from fuguangapi.settings import constants


class User(AbstractUser):
    name   = models.CharField(max_length=150, default="", null=True, blank=True, verbose_name='用户昵称')
    mobile = models.CharField(max_length=15, unique=True, verbose_name='手机号')
    money  = models.DecimalField(max_digits=9, default=0.0, decimal_places=2, verbose_name="钱包余额")
    credit = models.IntegerField(default=0, verbose_name="积分")
    avatar = models.ImageField(upload_to="avatar/%Y/", blank=True, null=True, default=constants.DEFAULT_USER_AVATAR, verbose_name="个人头像")
    study_time = models.IntegerField(default=0, verbose_name="总学习时长")

    class Meta:
        db_table = 'fg_users'
        verbose_name = '用户信息'
        verbose_name_plural = verbose_name

    def avatar_image(self):
        if self.avatar:
            return mark_safe( f'<img style="border-radius: 100%; max-width: 50px;" src="{self.avatar.url}">' )
        else:
            return mark_safe(f'<img style="border-radius: 100%; max-width: 50px;" src="/uploads/{constants.DEFAULT_USER_AVATAR}">')

    avatar_image.short_description = "个人头像"
    avatar_image.allow_tags = True
    avatar_image.admin_order_field = "avatar"

class Credit(BaseModel):
    """积分流水"""
    opera_choices = (
        (0, "业务增值"),
        (1, "购物消费"),
        (2, "系统赠送"),
    )
    operation = models.SmallIntegerField(choices=opera_choices, default=1, verbose_name="积分操作类型")
    number = models.IntegerField(default=0, verbose_name="积分数量", help_text="如果是扣除积分则需要设置积分为负数，如果消费10积分，则填写-10，<br>如果是添加积分则需要设置积分为正数，如果获得10积分，则填写10。")
    user = models.ForeignKey(User, related_name='user_credits', on_delete=models.CASCADE, verbose_name="用户")
    remark = models.CharField(max_length=500, null=True, blank=True, verbose_name="备注信息")
    class Meta:
        db_table = 'fg_credit'
        verbose_name = '积分流水'
        verbose_name_plural = verbose_name

    def __str__(self):
        if self.number > 0:
            oper_text = "获得"
        else:
            oper_text = "减少"
        return "[%s] %s 用户%s %s %s积分" % (self.get_operation_display(),self.created_time.strftime("%Y-%m-%d %H:%M:%S"), self.user.username, oper_text, abs(self.number))

from courses.models import Course,CourseChapter,CourseLesson
class UserCourse(BaseModel):
    """用户的课程"""
    user   = models.ForeignKey(User, related_name='user_courses', on_delete=models.CASCADE,verbose_name="用户", db_constraint=False)
    course = models.ForeignKey(Course, related_name='course_users', on_delete=models.CASCADE, verbose_name="课程名称", db_constraint=False)
    chapter = models.ForeignKey(CourseChapter, related_name="user_chapter", on_delete=models.DO_NOTHING, null=True, blank=True, verbose_name="章节信息", db_constraint=False)
    lesson = models.ForeignKey(CourseLesson, related_name="user_lesson", on_delete=models.DO_NOTHING, null=True, blank=True, verbose_name="课时信息", db_constraint=False)
    study_time = models.IntegerField(default=0, verbose_name="学习时长")

    class Meta:
        db_table = 'fg_user_course'
        verbose_name = '用户课程购买记录'
        verbose_name_plural = verbose_name
```

payments/views.py，代码：

```python
from django.conf import settings
from rest_framework.viewsets import ViewSet
from rest_framework.response import Response
from orders.models import Order
from alipaysdk import AliPaySDK


class AlipayAPIViewSet(ViewSet):
    """支付宝接口"""
    def link(self, request):
        """生成支付宝支付链接信息"""
        order_number = request.query_params.get("order_number")
        try:
            order = Order.objects.get(order_number=order_number)
            if order.order_status > 0:
                return Response({"message": "对不起，当前订单不能重复支付或订单已超时！"})
        except Order.DoesNotExist:
            return Response({"message": "对不起，当前订单不存在！"})

        alipay = AliPaySDK()
        # 拼接完整的支付链接
        link = alipay.page_pay(order_number, order.real_price, order.name)
        print(link)
        return Response(link)

    def return_result(self, request):
        """支付宝支付结果的同步通知处理"""
        data = request.query_params.dict()  # QueryDict
        alipay = AliPaySDK()
        success = alipay.check_sign(data)
        if not success:
            return Response({"errmsg": "通知结果不存在！"}, status=status.HTTP_400_BAD_REQUEST)
        
        order_number = data.get("out_trade_no")
        try:
            order = Order.objects.get(order_number=order_number)
            if order.order_status > 1:
                return Response({"errmsg": "订单超时或已取消！"}, status=status.HTTP_400_BAD_REQUEST)
        except Order.DoesNotExist:
            return Response({"errmsg": "订单不存在！"}, status=status.HTTP_400_BAD_REQUEST)
        
        # 获取当前订单相关的课程信息，用于返回给客户端
        order_courses = order.order_courses.all()
        course_list = [item.course for item in order_courses]
        courses_list = []
        for course in course_list:
            courses_list.append(UserCourse(course=course, user=order.user))
        
        if order.order_status == 0:
            # 如果订单状态为0，则表示未支付，根据订单号到支付宝查询当前订单的支付状态
            result = alipay.query(order_number)
            print(f"result-{result}")
            if result.get("trade_status", None) in ["TRADE_FINISHED", "TRADE_SUCCESS"]:
                """支付成功"""
                # todo 1. 修改订单状态
                # todo 2. 扣除个人积分，个人优惠券
                # todo 3. 用户和课程的关系绑定
                # todo 4. 取消订单超时

        # 返回客户端结果
        serializer = CourseInfoModelSerializer(course_list, many=True)
        return Response({
            "pay_time": order.pay_time.strftime("%Y-%m-%d %H:%M:%S"),
            "real_price": float(order.real_price),
            "course_list": serializer.data
        })
```

`payments/urls.py`，代码：

```python
from django.urls import path,re_path
from . import views
urlpatterns = [
    re_path("^alipay/(?P<order_number>[0-9]+)/$", views.AlipayAPIViewSet.as_view({"get": "link"})),
    path("alipay/result/", views.AlipayAPIViewSet.as_view({"get": "return_result"})),
]
```

数据迁移

```python
python manage.py makemigrations
python manage.py migrate
```

在订单结果处理的视图中把用户购买课程逻辑代码加上。

payments/views.py，代码：

```python
from django.db import transaction
from rest_framework import status
from rest_framework.viewsets import ViewSet
from rest_framework.response import Response

from coupon.models import CouponLog
from orders.models import Order
from alipaysdk import AliPaySDK
from datetime import datetime
from users.models import Credit, UserCourse
from courses.serializers import CourseInfoModelSerializer
import logging
logger = logging.getLogger("django")


class AlipayAPIViewSet(ViewSet):
    """支付宝接口"""

    def link(self, request, order_number):
        """生成支付宝支付链接信息"""
        try:
            order = Order.objects.get(order_number=order_number)
            if order.order_status > 0:
                return Response({"message": "对不起，当前订单不能重复支付或订单已超时！"})
        except Order.DoesNotExist:
            return Response({"message": "对不起，当前订单不存在！"})

        alipay = AliPaySDK()
        # 生成支付信息
        link = alipay.page_pay(order_number, order.real_price, order.name)

        return Response({
            "pay_type": 0,
            "get_pay_type_display": "支付宝",
            "link": link
        })

    def return_result(self, request):
        """支付宝支付结果的同步通知处理"""
        data = request.query_params.dict()  # QueryDict
        alipay = AliPaySDK()
        success = alipay.check_sign(data)
        if not success:
            return Response({"errmsg": "通知通知结果不存在！"}, status=status.HTTP_400_BAD_REQUEST)

        order_number = data.get("out_trade_no")
        try:
            order = Order.objects.get(order_number=order_number)
            if order.order_status > 1:
                return Response({"errmsg": "订单超时或已取消！"}, status=status.HTTP_400_BAD_REQUEST)
        except Order.DoesNotExist:
            return Response({"errmsg": "订单不存在！"}, status=status.HTTP_400_BAD_REQUEST)

        # 获取当前订单相关的课程信息，用于返回给客户端
        order_courses = order.order_courses.all()
        course_list = [item.course for item in order_courses]
        courses_list = []
        for course in course_list:
            courses_list.append(UserCourse(course=course, user=order.user))

        if order.order_status == 0:
            # 根据订单号到支付宝查询当前订单的支付状态
            result = alipay.query(order_number)
            if result.get("trade_status", None) in ["TRADE_FINISHED", "TRADE_SUCCESS"]:
                """支付成功"""
                with transaction.atomic():
                    save_id = transaction.savepoint()
                    try:
                        now_time = datetime.now()

                        # 1. 修改订单状态
                        order.order_status = 1
                        order.pay_time = now_time
                        order.save()
                        # 2. 扣除个人积分
                        if order.credit > 0:
                            Credit.objects.create(operation=1, number=order.credit, user=order.user)

                        # 3. 如果有使用了优惠券, 修改优惠券的使用记录
                        coupon_log = CouponLog.objects.filter(order=order).first()
                        if coupon_log:
                            coupon_log.use_time = now_time
                            coupon_log.use_status = 1  # 1 表示已使用
                            coupon_log.save()

                        # 4. 用户和课程的关系绑定
                        UserCourse.objects.bulk_create(courses_list)

                        # todo 4. 取消订单超时

                    except Exception as e:
                        logger.error(f"订单支付处理同步结果发生未知错误：{e}")
                        transaction.savepoint_rollback(save_id)
                        return Response({"errmsg": "！"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        # 返回客户端结果
        serializer = CourseInfoModelSerializer(course_list, many=True)
        return Response({
            "pay_time": order.pay_time.strftime("%Y-%m-%d %H:%M:%S"),
            "real_price": float(order.real_price),
            "course_list": serializer.data
        })
```

因为在处理同步通知结果的代码中，还进行了一次向支付宝查询订单支付结果的操作，所以有时候网络延迟的话，就会出现服务端成功，但是客户端无法获取结果的错误，此时可以设置axios的timeout为10秒，原来项目搭建时我们设置的是2.5秒。

utils/http.jss，代码：

```javascript
import axios from "axios"
const http = axios.create({
    // timeout: 10000,                         // 请求超时
    baseURL: "http://api.fuguang.cn:8000",  // 设置api服务端的默认地址
    withCredentials: false,                 // 是否允许客户端ajax请求时携带cookie
})
```



客户端展示支付处理后的结果。`views/AliPaySuccess.vue`，代码：

```vue
<template>
  <div class="success" v-if="order.is_show">
    <Header/>
    <div class="main">
        <div class="title">
          <i class="el-icon-chat-dot-round"></i>
          <div class="success-tips">
              <p class="tips1">您已成功购买 {{order.course_list?.length}} 门课程！</p>
              <p class="tips2">你还可以加入QQ群 <span>747556033</span> 学习交流</p>
          </div>
        </div>
        <div class="order-info">
            <p class="info1"><b>付款时间：</b><span>{{order.pay_time}}</span></p>
            <p class="info2"><b>付款金额：</b><span >{{order.real_price?.toFixed(2)}}</span></p>
            <p class="info3"><b>课程信息：</b>
              <span v-for="course in order.course_list">《{{course.name}}》</span>
            </p>
        </div>
        <div class="wechat-code">
          <img src="../assets/wechat.jpg" alt="" class="er">
          <p><i class="el-icon-warning"></i>重要！微信扫码关注获得学习通知&amp;课程更新提醒！否则将严重影响学习进度和课程体验！</p>
        </div>
        <div class="study">
          <router-link to="/user/study"><span>立即学习</span></router-link>
        </div>
    </div>
    <Footer/>
  </div>
</template>
```

```vue
<script setup>
import Header from "../components/Header.vue"
import Footer from "../components/Footer.vue"
import {ElMessage} from "element-plus";
import order from "../api/order";

import {useRouter} from "vue-router";
const router = useRouter()

let query_string = location.search; // 获取查询字符串的支付结果参数
order.relay_alipay_result(query_string).then(response=>{
    order.is_show = true;
    order.course_list = response.data.course_list;
    order.real_price  = response.data.real_price;
    order.pay_time    = response.data.pay_time;
}).catch(error=>{
    ElMessage.error(error.response.data.errmsg);
    router.push("/");
})

</script>
```



我们当前完成的项目具有一定特殊性，和传统卖实物商品不一样的是，我们卖的是虚拟商品，所以不存在多次购买同一款商品的，所以后续用户添加商品到购物车时， 要判断用户是否曾经购买了当前商品课程，如果在UserCourse中查询到购买记录，则不能添加商品到购物车！！

cart/views.py，代码：

```python
from django_redis import get_redis_connection
from rest_framework import status
from rest_framework.viewsets import ViewSet
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from courses.models import Course
from users.models import UserCourse


class CartViewSet(ViewSet):
    """购物车"""
    # 保证用户必须是登录状态才能调用当前视图
    permission_classes = [IsAuthenticated]

    def add_cart(self, request):
        """添加商品到购物车"""
        # 接收客户端的信息[用户ID，商品ID，勾选状态]
        user_id = request.user.id
        course_id = request.data.get("course_id")
        selected = 1

        # 验证数据
        try:
            Course.objects.get(is_delete=False, is_show=True,pk=course_id)
        except Course.DoesNotExist:
            return Response({"errmsg": "当前课程不存在！"}, status=status.HTTP_400_BAD_REQUEST)

        try:
            # 判断用户是否已经购买了
            UserCourse.objects.get(user_id=user_id, course_id=course_id)
            return Response({"errmsg": "对不起，您已经购买过当前课程！不需要重新购买了."}, status=status.HTTP_400_BAD_REQUEST)
        except:
            pass

        # 获取redis连接
        redis = get_redis_connection("cart")
        ret = redis.hexists(f"cart_{user_id}", course_id)
        cart_total = redis.hlen(f"cart_{user_id}")
        if ret:
            return Response({
                "errmsg": "当前商品课程已经被添加到购物车，请不要重复添加！",
                "cart_total": cart_total,
            })

        # 保存商品信息到购物车
        # hset <user_id> <course_id> <selected>
        redis.hset(f"cart_{user_id}", course_id, selected)
        """
        cart_1: {
           course_id: True,
           course_id: True,
           course_id: True,
        }
        
        cart_2: {
           ....
        }
        """

        # 返回操作结果，购物车中的商品总数
        # hlen <user_id>
        cart_total = redis.hlen(f"cart_{user_id}")

        # 5. 返回结果给客户端
        return Response({
            "errmsg": "成功添加商品课程到购物车！",
            "cart_total": cart_total
        }, status=status.HTTP_201_CREATED)

    # ... 代码省略
    # ... 代码省略
    # ... 代码省略
```



上面的支付结果处理都是基于支付平台返回的同步结果，是通过**页面跳转来完成通知**的。在项目运营过程中，很容易出现跳转页面过程中无法跳转或者跳转过程中被用户手动关闭页面的情况，这些情况都会导致服务端没法完成同步通知代码的执行，也就是说，我们不能单纯等待用户付款完成以后支付宝通过页面跳转的同步通知结果，还要结合用户的行为操作和支付宝的异步通知结果处理，才能**防止订单状态的丢失**。



### 提供支付倒计时功能

客户端订单页面中，添加一个倒计时的遮罩层，当用户关闭当前遮罩层则发送ajax请求查询当前订单的支付结果。

`views/Order.vue`，代码

```vue
<div class="loadding" v-if="order.loading" @click="check_order">
    <div class="box">
        <p class="time">{{fill0(parseInt(order.timeout/60))}}:{{ fill0(order.timeout%60)}}</p>
        <i class="el-icon-loading"></i><br>
        <p>支付完成！点击关闭当前页面</p>
    </div>
</div>  <!-- 这里添加到Footer上方即可 -->
<Footer/>
```

```vue
<script setup>
import Header from "../components/Header.vue"
import Footer from "../components/Footer.vue"
import {watch} from "vue"
import {useStore} from "vuex";
import cart from "../api/cart";
import order from "../api/order";
import {ElMessage} from "element-plus";
import {useRouter} from "vue-router";
import settings from "../settings";
import {fill0} from "../utils/func";

const store = useStore();
const router = useRouter();

const get_select_course = ()=>{
    // 获取购物车中的勾选商品列表
    let token = sessionStorage.token || localStorage.token;
    cart.get_select(token).then(response=>{
        cart.select_course_list = response.data.cart
        let sum = 0                // 计算本次购物的总价格
        let credit_course_list= [] // 可使用积分抵扣的课程列表
        let max_use_credit = 0     // 本次下单最多可以用于抵扣的积分

        response.data.cart.forEach((course,key)=>{
            if(course.discount.price > 0){
              sum+=course.discount.price
            }else{
              sum+=course.price
            }

            if(course.credit > 0){
                max_use_credit = max_use_credit + course.credit
                credit_course_list.push(course)
            }
        })
        cart.total_price = sum;
        order.credit_course_list = credit_course_list
        order.max_use_credit = max_use_credit // 本次下单最多可以用于抵扣的积分

    })
}
get_select_course();

const commit_order = ()=>{
    // 生成订单
    let token = sessionStorage.token || localStorage.token;
    let user_coupon_id = -1;
    if(order.select !== -1){
        user_coupon_id = order.coupon_list[order.select].user_coupon_id;
    }
    order.create_order(user_coupon_id, token).then(response=>{
        // 保存订单号
        order.order_number = response.data.order_number;
        // 支付倒计时提示
        order.loading = true                        // 显示遮罩层
        order.timeout = settings.order_timeout      // 订单超时的时间，为15分钟
        clearInterval(order.timer)  // 先清除原有定时器，保证整个页面中timer对应的定时器是唯一的。
        order.timer = setInterval(() => {
          if(order.timeout > 1){
              order.timeout=order.timeout - 1;
          }else{
              ElMessage.error("订单超时！如果您已经支付成功！请点击关闭当前弹窗！当前页面15秒后关闭！");
              clearInterval(order.timer);
              // 发送一个订单查询
              check_order();
              // 关闭页面
              setTimeout(()=>{
                  router.push("/user/order");
              }, 15000);
          }
        }, 1000);

        // 成功提示
        ElMessage.success("下单成功！马上跳转到支付页面，请稍候~")
        // 扣除掉被下单的商品数量，更新购物车中的商品数量
        store.commit("set_cart_total", store.state.cart_total - cart.select_course_list.length);
        // 根据订单号到服务端获取支付链接，并打开支付页面。
        order.alipay_page_pay(response.data.order_number).then(response=>{
            window.open(response.data.link,"_blank");
        })
    })
}

// 获取本次下单的可用优惠券
const get_enable_coupon_list = ()=>{
    let token = sessionStorage.token || localStorage.token;
    order.get_enable_coupon_list(token).then(response=>{
        order.coupon_list = response.data.coupon_list
        // 积分兑换比例
        order.credit_to_money = response.data.credit_to_money;
        // 用户拥有的积分数量
        order.has_credit      = response.data.has_credit;

        // 如果本次下单的最大抵扣积分数量 > 用户拥有的积分数量
        if(order.max_use_credit > order.has_credit){
            // 则本次下单的最大可用抵扣积分数量 为 用户拥有的积分数量
            order.max_use_credit = order.has_credit
        }
    })
}

get_enable_coupon_list()


// 积分兑换抵扣
const conver_credit = ()=>{
  order.discount_price = parseFloat( (order.credit / order.credit_to_money).toFixed(2) )
}
const max_conver_credit = ()=>{
  order.credit=order.max_use_credit
  conver_credit();
}


// 查询订单状态
const check_order = ()=>{
  let token = sessionStorage.token || localStorage.token
  order.query_order(order.order_number,token).then(response=>{
    order.loading = false;
    router.push("/user/order");
  }).catch(error=>{
    console.log(error);
    ElMessage.error(error.response.data.errmsg);
  })
}

// 监听用户选择的支付方式
watch(
    ()=>order.pay_type,
    ()=>{
      console.log(order.pay_type)
    }
)

// 监听用户选择的优惠券
watch(
    ()=>order.select,
    ()=>{
        // 如果没有选择任何的优惠券，则select 为-1，那么不用进行计算优惠券折扣的价格了
        order.discount_price = 0; // 最终得到的优惠券折扣价格
        if (order.select === -1) {
            return // 阻止代码继续往下执行
        }
        // 根据下表，获取当前选中的优惠券信息
        let current_coupon = order.coupon_list[order.select]
        // 针对折扣优惠券，找到最大优惠的课程
        let max_discount = -1;
        for(let course of cart.select_course_list) {  // 循环本次下单的勾选商品
            // 找到当前优惠券的可用课程
            if(current_coupon.enable_course === "__all__") { // 如果当前优惠券是通用优惠券
                if(max_discount !== -1){
                    if(course.price > max_discount.price){  // 在每次循环中，那当前循环的课程的价格与之前循环中得到的最大优惠课程的价格进行比较
                        max_discount = course
                    }
                }else{
                    max_discount = course
                }

            // 判断 当前优惠券如果包含了当前课程， 并 课程的价格 > 当前优惠券的使用门槛
            }else if((current_coupon.enable_course.indexOf(course.id) > -1) && (course.price >= parseFloat(current_coupon.condition))){
                // 只允许没有参与其他优惠券活动的课程使用优惠券，基本所有的平台都不存在折上折的。
                if( course.discount.price === undefined ) {
                    if(max_discount !== -1){
                      if(course.price > max_discount.price){
                        max_discount = course
                      }
                    }else{
                      max_discount = course
                    }
                }
            }
        }

        if(max_discount !== -1){
            if(current_coupon.discount === '1') { // 抵扣优惠券[抵扣的价格就是当前优惠券的价格]
                order.discount_price = parseFloat( Math.abs(current_coupon.sale) )
            }else if(current_coupon.discount === '2') { // 折扣优惠券]抵扣的价格就是(1-折扣百分比) * 课程原价]
                order.discount_price = parseFloat(max_discount.price * (1-parseFloat(current_coupon.sale.replace("*",""))) )
            }
        }else{
            order.select = -1
            order.discount_price = 0
            ElMessage.error("当前课程商品已经参与了其他优惠活动，无法再次使用当前优惠券！")
        }

    }
)

// 在切换不同的优惠类型，重置积分和优惠券信息
watch(
    ()=>order.discount_type,
    ()=>{
        order.select = -1
        order.credit = 0
        order.discount_price = 0
    }
)


// 底部订单总价信息固定浮动效果
window.onscroll = ()=>{
  let cart_body_table = document.querySelector(".cart-body-table")
  let offsetY = window.scrollY
  let maxY = cart_body_table.offsetTop+cart_body_table.offsetHeight
  order.fixed = offsetY < maxY
}
</script>
```

```vue
<style>
.loadding{
  width: 100%;
  height: 100%;
  margin: auto;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 999;
  background-color: rgba(0,0,0,.7);
}
.box{
  width: 300px;
  height: 150px;
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  margin: auto;
  font-size: 40px;
  text-align: center;
  padding-top: 50px;
  color: #fff;
}
.box .time{
  font-size: 22px;
}
</style>
```

`api/order.js`，代码：

```javascript
import http from "../utils/http";
import {reactive} from "vue";

const order = reactive({
    // ... 代码省略
    // ... 代码省略
    // ... 代码省略
    order_number: null,  // 订单号
    loading: false,      // 订单支付时的倒计时背景遮罩层
    timeout: 0,          // 订单支付超时倒计时
    timer: 0,            // 订单支付倒计时定时器的标记符
    // ... 代码省略
    // ... 代码省略
    // ... 代码省略
    query_order(token){
        // 查询订单结果
        return http.get(`/payments/alipay/query/${this.order_number}`,{
            headers:{
                Authorization: "jwt " + token,
            }
        })
    }
});

export default order;
```

src/settings.js，代码：

```javascript
export default {
    // api服务端所在地址
    host: "http://api.fuguang.cn:8000",
    // 防水墙验证码的应用ID
    captcha_app_id: "2019894193",
    // 订单超时时间[单位：秒]
    order_timeout: 15 * 60,
}
```



### 服务端提供查询订单的api接口

payments/urls.py，代码：

```python
from django.urls import path,re_path
from . import views
urlpatterns = [
    re_path("^alipay/(?P<order_number>[0-9]+)/$", views.AlipayAPIViewSet.as_view({"get": "link"})),
    path("alipay/result/", views.AlipayAPIViewSet.as_view({"get": "return_result"})),
    re_path("^alipay/query/(?P<order_number>[0-9]+)/$", views.AlipayAPIViewSet.as_view({"get":"query"})),
]
```

`payments/views.py`，代码：

```python
from django.db import transaction
from rest_framework import status
from rest_framework.views import APIView
from rest_framework.viewsets import ViewSet
from rest_framework.response import Response

from coupon.models import CouponLog
from orders.models import Order
from alipaysdk import AliPaySDK
from datetime import datetime
from users.models import Credit, UserCourse
from courses.serializers import CourseInfoModelSerializer
import logging
logger = logging.getLogger("django")


class AlipayAPIViewSet(ViewSet):
    """支付宝接口"""

    # // ... 代码省略
    # // ... 代码省略
    # // ... 代码省略

    def query(self, request, order_number):
        """主动查询订单支付的支付结果"""
        try:
            order = Order.objects.get(order_number=order_number)
            if order.order_status > 1:
                return Response({"errmsg": "订单超时或已取消！"}, status=status.HTTP_400_BAD_REQUEST)
        except Order.DoesNotExist:
            return Response({"errmsg": "订单不存在！"}, status=status.HTTP_400_BAD_REQUEST)

        # 获取当前订单相关的课程信息，用于返回给客户端
        order_courses = order.order_courses.all()
        course_list = [item.course for item in order_courses]
        courses_list = []
        for course in course_list:
            courses_list.append(UserCourse(course=course, user=order.user))

        if order.order_status == 0:
            alipay = AliPaySDK()
            # 根据订单号到支付宝查询当前订单的支付状态
            result = alipay.query(order_number)
            if result.get("trade_status", None) in ["TRADE_FINISHED", "TRADE_SUCCESS"]:
                """支付成功"""
                with transaction.atomic():
                    save_id = transaction.savepoint()
                    try:
                        now_time = datetime.now()

                        # 1. 修改订单状态
                        order.order_status = 1
                        order.pay_time = now_time
                        order.save()
                        # 2. 扣除个人积分
                        if order.credit > 0:
                            Credit.objects.create(operation=1, number=order.credit, user=order.user)

                        # 3. 如果有使用了优惠券, 修改优惠券的使用记录
                        coupon_log = CouponLog.objects.filter(order=order).first()
                        if coupon_log:
                            coupon_log.use_time = now_time
                            coupon_log.use_status = 1  # 1 表示已使用
                            coupon_log.save()

                        # 4. 用户和课程的关系绑定
                        UserCourse.objects.bulk_create(courses_list)

                        # todo 4. 取消订单超时

                    except Exception as e:
                        logger.error(f"订单支付处理同步结果发生未知错误：{e}")
                        transaction.savepoint_rollback(save_id)
                        return Response({"errmsg": "当前订单支付未完成！请联系客服工作人员！"},
                                        status=status.HTTP_500_INTERNAL_SERVER_ERROR)
            else:
                """当前订单未支付"""
                return Response({"errmsg": "当前订单未支付！"}, status=status.HTTP_400_BAD_REQUEST)

        return Response({"errmsg":"当前订单已支付！"})
```

虽然上面提供了支付倒计时进一步确认用户是否支付了。但是还是会存在用户不点击页面而是通过页面刷新来避开了倒计时。这样的话，我们还是存存在订单状态丢失的情况。



### 接受支付宝异步发送支付结果

文档：https://opendocs.alipay.com/open/270/105902

payments/views.py，代码：

```python
from django.db import transaction
from rest_framework import status
from rest_framework.views import APIView
from rest_framework.viewsets import ViewSet
from rest_framework.response import Response
from django.http.response import HttpResponse

from coupon.models import CouponLog
from orders.models import Order
from alipaysdk import AliPaySDK
from datetime import datetime
from users.models import Credit, UserCourse
from courses.serializers import CourseInfoModelSerializer
import logging
logger = logging.getLogger("django")


class AlipayAPIViewSet(ViewSet):
    """支付宝接口"""

    def link(self, request, order_number):
        """生成支付宝支付链接信息"""
        try:
            order = Order.objects.get(order_number=order_number)
            if order.order_status > 0:
                return Response({"message": "对不起，当前订单不能重复支付或订单已超时！"})
        except Order.DoesNotExist:
            return Response({"message": "对不起，当前订单不存在！"})

        alipay = AliPaySDK()
        # 生成支付信息
        link = alipay.page_pay(order_number, order.real_price, order.name)

        return Response({
            "pay_type": 0,
            "get_pay_type_display": "支付宝",
            "link": link
        })

    def return_result(self, request):
        """支付宝支付结果的同步通知处理"""
        data = request.query_params.dict()  # QueryDict
        alipay = AliPaySDK()
        success = alipay.check_sign(data)
        if not success:
            return Response({"errmsg": "通知通知教研失败！"}, status=status.HTTP_400_BAD_REQUEST)

        order_number = data.get("out_trade_no")

        try:
            order = Order.objects.get(order_number=order_number)
            if order.order_status > 1:
                return Response({"errmsg": "订单超时或已取消！"}, status=status.HTTP_400_BAD_REQUEST)
        except Order.DoesNotExist:
            return Response({"errmsg": "订单不存在！"}, status=status.HTTP_400_BAD_REQUEST)

        # 获取当前订单相关的课程信息，用于返回给客户端
        order_courses = order.order_courses.all()
        course_list = [item.course for item in order_courses]
        courses_list = []
        for course in course_list:
            courses_list.append(UserCourse(course=course, user=order.user))

        if order.order_status == 0:
            # 根据订单号到支付宝查询当前订单的支付状态
            result = alipay.query(order_number)
            if result.get("trade_status", None) in ["TRADE_FINISHED", "TRADE_SUCCESS"]:
                """支付成功"""
                with transaction.atomic():
                    save_id = transaction.savepoint()
                    try:
                        now_time = datetime.now()

                        # 1. 修改订单状态
                        order.order_status = 1
                        order.pay_time = now_time
                        order.save()
                        # 2. 扣除个人积分
                        if order.credit > 0:
                            Credit.objects.create(operation=1, number=order.credit, user=order.user)

                        # 3. 如果有使用了优惠券, 修改优惠券的使用记录
                        coupon_log = CouponLog.objects.filter(order=order).first()
                        if coupon_log:
                            coupon_log.use_time = now_time
                            coupon_log.use_status = 1  # 1 表示已使用
                            coupon_log.save()

                        # 4. 用户和课程的关系绑定
                        UserCourse.objects.bulk_create(courses_list)

                        # todo 4. 取消订单超时

                    except Exception as e:
                        logger.error(f"订单支付处理同步结果发生未知错误：{e}")
                        transaction.savepoint_rollback(save_id)
                        return Response({"errmsg": "当前订单支付未完成！请联系客服工作人员！"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
        # 返回客户端结果
        serializer = CourseInfoModelSerializer(course_list, many=True)
        return Response({
            "pay_time": order.pay_time.strftime("%Y-%m-%d %H:%M:%S"),
            "real_price": float(order.real_price),
            "course_list": serializer.data
        })

    def notify_result(self, request):
        """支付宝支付结果的异步通知处理"""
        data = request.data  # 接受来自支付宝平台的异步通知结果
        alipay = AliPaySDK()
        success = alipay.check_sign(data)
        if not success:
            # 因为是属于异步处理，这个过程无法通过终端调试，因此，需要把支付发送过来的结果，记录到日志中。
            logger.error(f"[支付宝]>> 异步通知结果验证失败：{data}")
            return HttpResponse("fail")

        if data["trade_status"] not in ["TRADE_FINISHED", "TRADE_SUCCESS"]:
            return HttpResponse("fail")

        order_number = data.get("out_trade_no")
        try:
            order = Order.objects.get(order_number=order_number)
            if order.order_status > 1:
                return HttpResponse("fail")
        except Order.DoesNotExist:
            return HttpResponse("fail")

        # 如果已经支付完成，则不需要继续往下处理
        if order.order_status == 1:
            return HttpResponse("success")

        # 获取当前订单相关的课程信息
        order_courses = order.order_courses.all()
        course_list = [item.course for item in order_courses]
        courses_list = []
        for course in course_list:
            courses_list.append(UserCourse(course=course, user=order.user))

        """支付成功"""
        with transaction.atomic():
            save_id = transaction.savepoint()
            try:
                now_time = datetime.now()

                # 1. 修改订单状态
                order.order_status = 1
                order.pay_time = now_time
                order.save()
                # 2. 扣除个人积分
                if order.credit > 0:
                    Credit.objects.create(operation=1, number=order.credit, user=order.user)

                # 3. 如果有使用了优惠券, 修改优惠券的使用记录
                coupon_log = CouponLog.objects.filter(order=order).first()
                if coupon_log:
                    coupon_log.use_time = now_time
                    coupon_log.use_status = 1  # 1 表示已使用
                    coupon_log.save()

                # 4. 用户和课程的关系绑定
                UserCourse.objects.bulk_create(courses_list)

                # todo 4. 取消订单超时

                return HttpResponse("success")

            except Exception as e:
                logger.error(f"订单支付处理同步结果发生未知错误：{e}")
                transaction.savepoint_rollback(save_id)
                return HttpResponse("fail")

    def query(self, request, order_number):
        """主动查询订单支付的支付结果"""
        try:
            order = Order.objects.get(order_number=order_number)
            if order.order_status > 1:
                return Response({"errmsg": "订单超时或已取消！"}, status=status.HTTP_400_BAD_REQUEST)
        except Order.DoesNotExist:
            return Response({"errmsg": "订单不存在！"}, status=status.HTTP_400_BAD_REQUEST)

        # 获取当前订单相关的课程信息，用于返回给客户端
        order_courses = order.order_courses.all()
        course_list = [item.course for item in order_courses]
        courses_list = []
        for course in course_list:
            courses_list.append(UserCourse(course=course, user=order.user))

        if order.order_status == 0:
            alipay = AliPaySDK()
            # 根据订单号到支付宝查询当前订单的支付状态
            result = alipay.query(order_number)
            if result.get("trade_status", None) in ["TRADE_FINISHED", "TRADE_SUCCESS"]:
                """支付成功"""
                with transaction.atomic():
                    save_id = transaction.savepoint()
                    try:
                        now_time = datetime.now()

                        # 1. 修改订单状态
                        order.order_status = 1
                        order.pay_time = now_time
                        order.save()
                        # 2. 扣除个人积分
                        if order.credit > 0:
                            Credit.objects.create(operation=1, number=order.credit, user=order.user)

                        # 3. 如果有使用了优惠券, 修改优惠券的使用记录
                        coupon_log = CouponLog.objects.filter(order=order).first()
                        if coupon_log:
                            coupon_log.use_time = now_time
                            coupon_log.use_status = 1  # 1 表示已使用
                            coupon_log.save()

                        # 4. 用户和课程的关系绑定
                        UserCourse.objects.bulk_create(courses_list)

                        # todo 4. 取消订单超时

                    except Exception as e:
                        logger.error(f"订单支付处理同步结果发生未知错误：{e}")
                        transaction.savepoint_rollback(save_id)
                        return Response({"errmsg": "当前订单支付未完成！请联系客服工作人员！"},
                                        status=status.HTTP_500_INTERNAL_SERVER_ERROR)
            else:
                """当前订单未支付"""
                return Response({"errmsg": "当前订单未支付！"}, status=status.HTTP_400_BAD_REQUEST)

        return Response({"errmsg":"当前订单已支付！"})
```

`payments/urls.py`，路由，代码：

```python
from django.urls import path,re_path
from . import views
urlpatterns = [
    re_path("^alipay/(?P<order_number>[0-9]+)/$", views.AlipayAPIViewSet.as_view({"get": "link"})),
    path("alipay/result/", views.AlipayAPIViewSet.as_view({"get": "return_result"})),
    re_path("^alipay/query/(?P<order_number>[0-9]+)/$", views.AlipayAPIViewSet.as_view({"get":"query"})),
    path("alipay/notify", views.AlipayAPIViewSet.as_view({"post": "notify_result"})),
]
```

