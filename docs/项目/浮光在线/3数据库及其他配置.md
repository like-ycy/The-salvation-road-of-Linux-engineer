# 数据库及其他配置

## 1、日志配置

https://docs.djangoproject.com/zh-hans/3.2/topics/logging/

ELK日志分析系统（ E=Elasticsearch搜索引擎,L=Logstash日志分析器,K=Kibana 消息中间件）。



这里我们基于django开发，我们先使用logging日志。 Django 使用 Python 内置的logging 模块处理系统日志。 

日志级别，从严重程度从高往低，一共分了5个等级。

由loging模块默认提供了5个操作方法，分别可以记录以下5个等级日志的。

 ```bash
CRITICAL（fatal）：  致命错误，程序根本跑不起来。
ERROR：              运行错误，程序运行发生错误的地方时就会退出程序。
WARNING：            运行警告，程序运行发生警告的方法时会显示警告提示，但是程序会继续往下执行。
INFO：               运行提示，一般的系统信息
DEBUG：              调试信息，排查故障时使用的低级别系统信息
 ```



在settings/dev.py文件中追加如下配置：

```python
# 日志配置
# https://docs.djangoproject.com/zh-hans/3.2/topics/logging/
LOGGING = {
    'version': 1,  # 使用的日志模块的版本，目前官方提供的只有版本1，但是官方有可能会升级，为了避免升级出现的版本问题，所以这里固定为1
    'disable_existing_loggers': False,  # 是否禁用其他的已经存在的日志功能？肯定不能，有可能有些第三方模块在调用，所以禁用了以后，第三方模块无法捕获自身出现的异常了。
    'formatters': {  # 日志格式设置，verbose或者simple都是自定义的
        'verbose': {  # 详细格式，适合用于开发人员不在场的情况下的日志记录。
            # 格式定义：https://docs.python.org/3/library/logging.html#logrecord-attributes
            # levelname 日志等级
            # asctime   发生时间
            # module    文件名
            # process   进程ID
            # thread    线程ID
            # message   异常信息
            'format': '{levelname} {asctime} {module} {funcName} {process:d} {thread:d} {message}',
            'style': '{',  # 变量格式分隔符
        },
        'simple': {  # 简单格式，适合用于开发人员在场的情况下的终端输出
            'format': '{levelname} {module} {funcName} {message}',
            'style': '{',
        },
    },
    'filters': {  # 过滤器
        'require_debug_true': {
            '()': 'django.utils.log.RequireDebugTrue',
        },
    },
    'handlers': { # 日志处理流程，console或者mail_admins都是自定义的。
        'console': {
            'level': 'DEBUG', # 设置当前日志处理流程中的日志最低等级
            'filters': ['require_debug_true'], # 当前日志处理流程的日志过滤
            'class': 'logging.StreamHandler',  # 当前日志处理流程的核心类，StreamHandler可以帮我们把日志信息输出到终端下
            'formatter': 'simple'              # 当前日志处理流程的日志格式
        },
        # 'mail_admins': {
        #     'level': 'ERROR',                  # 设置当前日志处理流程中的日志最低等级
        #     'class': 'django.utils.log.AdminEmailHandler',  # AdminEmailHandler可以帮我们把日志信息输出到管理员邮箱中。
        #     'filters': ['special']             # 当前日志处理流程的日志过滤
        # }
        # 按文件大小来分割日志
        'file': {
            'level': 'DEBUG',
            'class': 'logging.handlers.RotatingFileHandler',
            # 日志位置,日志文件名，日志保存目录logs必须手动创建
            'filename': BASE_DIR.parent / "logs/fuguang.log",
            # 单个日志文件的最大值，这里我们设置300M
            'maxBytes': 300 * 1024 * 1024,
            # 备份日志文件的数量，设置最大日志数量为10
            'backupCount': 20,
            # 日志格式: 详细格式
            'formatter': 'verbose'
        },
    },
    'loggers': {  # 日志处理的命名空间
        'django': {  # 要在django中调用当前配置项的loging写入日志到文件中，名字必须叫"django"
            'handlers': ['console','file'],  # 当基于django命名空间写入日志时，调用那几个日志处理流程
            'propagate': True,   # 是否在django命名空间对应的日志处理流程结束以后，冒泡通知其他的日志功能。True表示允许
        },
    }
}
```

提交一个git版本。

```bash
cd ~/Desktop/fuguang
git add .
git commit -m "日志初始化"
git push origin master
```



## 2、异常处理

新建utils/exceptions.py

```python
from rest_framework.views import exception_handler

from django.db import DatabaseError
from rest_framework.response import Response
from rest_framework import status

import logging
logger = logging.getLogger('django')


def custom_exception_handler(exc, context):
    """
    自定义异常处理
    :param exc: 异常类
    :param context: 抛出异常的上下文
    :return: Response响应对象
    """
    # 调用drf框架原生的异常处理方法
    response = exception_handler(exc, context)

    if response is None:
        view = context['view']
        if isinstance(exc, DatabaseError):
            # 数据库异常
            logger.error('[%s] %s' % (view, exc))
            response = Response({'message': '服务器内部错误'}, status=status.HTTP_507_INSUFFICIENT_STORAGE)

    return response
```



settings/dev.py配置文件中添加

```python
# drf配置
REST_FRAMEWORK = {
    # 自定义异常处理
    'EXCEPTION_HANDLER': 'fuguangapi.utils.exceptions.exception_handler',
}
```



## 3、创建数据库

```mysql
mysql -uroot -p123
create database fuguang;

# 如果使用的数据库是低于8.0，使用下面的语句
# create database fuguang default charset=utf8mb4;
```



为当前项目创建数据库用户[这个用户只能看到这个数据库]

```mysql
# 8.0版本以上的mysql/MariaDB10.3
# 创建用户：create user '用户名'@'主机地址' identified by '密码';
create user 'fuguang_user'@'%' identified by 'fuguang';  # %表示任意主机都可以通过当前账户登录到mysql
# 分配权限：grant 权限选项 on 数据库名.数据表 to 'fuguang_user'@'%' with grant option;
grant all privileges on fuguang.* to 'fuguang_user'@'%' with grant option;

# 也可以分配其他账户，其他权限
# create user 'xiaoming'@'%' identified by 'xiaoming';
# grant select,insert on fuguang.* to 'xiaoming'@'%' with grant option;




# mysql8.0/MariaDB10.3版本以下，创建数据库用户并设置数据库权限给当前新用户，并刷新内存中的权限记录
create user fuguang_user identified by 'fuguang';
grant all privileges on fuguang.* to 'fuguang_user'@'%';
flush privileges;
```

使用pycharm连接mysql数据库。

![image-20210709114342742](3%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8A%E5%85%B6%E4%BB%96%E9%85%8D%E7%BD%AE.assets/image-20210709114342742.png)

![image-20210709114311665](3%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8A%E5%85%B6%E4%BB%96%E9%85%8D%E7%BD%AE.assets/image-20210709114311665.png)



## 4、配置数据库连接

### MySQL

连接池

```bash
pip install django-db-connection-pool -i https://pypi.douban.com/simple
pip install cryptography -i https://pypi.douban.com/simple
```

打开settings/dev.py文件，并配置

```python
DATABASES = {
    # 'default': {
    #     'ENGINE': 'django.db.backends.sqlite3',
    #     'NAME': BASE_DIR / 'db.sqlite3',
    # }
    'default': {
        # 'ENGINE': 'django.db.backends.mysql',
        'ENGINE': 'dj_db_conn_pool.backends.mysql',
        'NAME': 'fuguang',
        'PORT': 3306,
        'HOST': '127.0.0.1',
        'USER': 'fuguang_user',
        'PASSWORD': 'fuguang',
        'OPTIONS': {
            'charset': 'utf8mb4', # 连接选项配置,mysql8.0以上无需配置
        },
        'POOL_OPTIONS' : {      # 连接池的配置信息
            'POOL_SIZE': 10,    # 连接池默认创建的链接对象的数量
            'MAX_OVERFLOW': 10  # 连接池默认创建的链接对象的最大数量
        }
    }
}
```

在项目主应用下的 `fuguangapi.__init__.py`中导入pymysql

```python
import pymysql

pymysql.install_as_MySQLdb()
```

使用git记录代码版本

```bash
cd ~/Desktop/fuguang
git add .
git commit -m "mysql数据库初始化"
git push origin master
```



## 5、缓存配置

### Redis

文档：

安装django-redis。

```python
pip install django-redis
```

在settings/dev.py配置中添加一下代码：

```python
# redis configration
# https://django-redis-chs.readthedocs.io/zh_CN/latest/#
# 设置redis缓存
CACHES = {
    # 默认缓存
    "default": {
        "BACKEND": "django_redis.cache.RedisCache",
        # 项目上线时,需要调整这里的路径
        "LOCATION": "redis://:123456@127.0.0.1:6379/0",
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        }
    },
    # 提供给admin站点的session存储
    "session": {
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": "redis://:123456@127.0.0.1:6379/1",
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        }
    },
    # 提供存储短信验证码
    "sms_code":{
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": "redis://:123456@127.0.0.1:6379/2",
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        }
    }
}

# 设置用户登录admin站点时,记录登录状态的session保存到redis缓存中
SESSION_ENGINE = "django.contrib.sessions.backends.cache"
# 设置session保存的位置对应的缓存配置项
SESSION_CACHE_ALIAS = "session"
```

关于django-redis 的使用，说明文档可见：http://django-redis-chs.readthedocs.io/zh_CN/latest/

django-redis提供了get_redis_connection的方法，通过调用get_redis_connection方法传递redis的配置名称可获取到redis的连接对象，通过redis连接对象可以执行redis命令

https://redis-py.readthedocs.io/en/latest/

使用范例：

```python
from django_redis import get_redis_connection
// 链接redis数据库
redis_conn = get_redis_connection("default")
```



## 6、接口测试例子

如果没有创建子应用home，可以根据以下步骤创建，终端操作

```bash
cd fuguangapi/apps
python ../../manage.py startapp home
```

注册home子应用分2步：

在settings/dev.py中的INSTALLED_APPS配置项里面新增home

因为项目目录的结构有所调整，所以我们在apps下保存了home子应用，因此需要让python能直接对home记性导包识别。

`settings/dev.py`，代码：

```bash
# 当前项目的主应用开发目录
BASE_DIR = Path(__file__).resolve().parent.parent
# 新增apps作为导包路径，导包路径默认保存sys.path属性中，所有的python的import或者from导包语句默认都是从sys.path中记录的路径下查找模块
sys.path.insert(0, str( BASE_DIR / "apps") )
# print(sys.path)

# django3.2.9版本中，默认关闭DEBUG模式的，我们自己手动开启下，方便开发
DEBUG = True

ALLOWED_HOSTS = ["*"]


INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',
    'home',
]
```

home子应用下创建路由文件，home/urls.py，代码：

```python
from django.urls import path
from . import views
urlpatterns = [
    
]
```

把子路由文件注册到总路由，`fuguangapi/urls.py`，代码：

```python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('home/', include("home.urls")),
]
```

home/views.py，编写视图，代码：

```python
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status

from django_redis import get_redis_connection

# Create your views here.
class HomeAPIView(APIView):
    def get(self,request):
        """测试接口"""
        print("hello")

        # 直接操作redis
        redis = get_redis_connection("session")
        # lrange brother 0 -1
        brother = redis.lrange("brother", 0, -1)
        print(brother)

        return Response(brother, status.HTTP_200_OK)
```

home/urls.py，代码：

```python
from django.urls import path
from . import views
urlpatterns = [
    path("demo/", views.HomeAPIView.as_view()),
]
```
