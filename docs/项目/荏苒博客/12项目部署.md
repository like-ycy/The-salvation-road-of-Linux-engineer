# 项目部署的相关概念

关于部署流程，主要包含以下两个方面：部署方案、部署环境：

## 部署方案

```
1. 分析项目的产品需求文档，定好部署方案的方向
2. 分析项目开发文档，按照功能边界，设计部署的结点
3. 分析项目功能软件，合理的取舍，选符合当前业务场景的
4. 梳理项目部署涉及到的部署软件实现方案，根据上面第2点确定的结点，确定初版部署方案
5. 根据项目实际情况，调整优化并确定项目部署方案
```



## 部署环境

##### 个人开发环境：

```
工作人员：自己
工作平台：个人笔记本、公司配的电脑
平台特点：环境是自己配的，团队中不同的个人开发环境可以不一样
工作内容：项目的子模块，子功能
完成标准：完成领导安排的内容[项目的功能子模块开发]
```

##### 公司开发环境：

```
工作人员：开发团队
工作平台：公司内部服务器【内网上的服务器】
平台特点：服务器环境和线上的服务器环境完全一致
工作内容：项目子模块间的功能联调
完成标准：项目阶段开发、调试完成
```

##### 项目测试环境：

```
工作人员：测试团队
工作平台：公司内部服务器【内网上的服务器】
平台特点：服务器环境和线上的服务器环境完全一致
工作内容：项目功能/非功能/探索等测试
完成标准：项目阶段功能正常运行
```

##### 项目预发布环境：

```
工作人员：运维团队
工作平台：公司线上服务器组中的一台【公网上的服务器】
平台特点：服务器环境和线上的服务器环境完全一致
工作内容：特殊功能测试(比如支付)、数据压力测试、其他安全测试等
完成标准：项目阶段功能正常运行，最后一道防线
```

##### 项目生产环境：

```
工作人员：运维团队
工作平台：公司线上服务器组
平台特点：标准线上的服务器环境
工作内容：代码部署和维护、记录内部架构文档、项目日志分析
完成标准：项目正常运行
```



![1563422044771](12%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2.assets/1563422044771.png)



## 项目整体架构

用于运行django等web项目的常用的http web服务器：uwsgi，gunicorn，nginx，apache。

当然我们在这里选择的web服务器是uwsgi。

![1596248963185](12%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2.assets/1596248963185.png)



### 服务器部署

QPS  客户端同时发送到服务端的每秒请求数

服务器解决并发的能力：就是看服务器每秒能完成多少个客户端发送过来的QPS

一般估算服务器解决并发的能力：客户端请求数 * 客户端数量，并发瓶颈：

```python
1. 带宽：200M/10K
2. 处理并发的能力[web服务器]
3. 数据库查询能力：mysql 1000次/s
4. 服务器配置[服务器类型：物理服务器，云服务器]
```

可以使用apache ab工具进行压测

```
购买云服务器：2核2M,2M带宽
     47.96.95.61
域名：3w.lxh1.com   客户端
     api.lxh1.com  api端
```

### 关于域名的购买

```bash
# 域名有国际域名和区域域名之分
# 国际域名  .com企业  .net互联网  .org教科文组织   .info资讯相关
# 区域域名  .com.cn   .cn  .... 

# 我们一般购买的都是顶级域名，不能永久，一般按年购买
jd.com   # 格式：域名名称.域名商

# 二级域名
www.jd.com
goods.jd.com
# 三级域名[有几个点，就是几级域名]
home.goods.jd.com


# 域名一定要进行ICP备案和公安部备案。ICP备案必须有一个服务器，通过服务器获取备案服务号。
# 域名的使用是通过域名解析[把域名和服务器的IP地址进行绑定]
```



## 前端项目部署

#### 使用docker进行容器化管理进行持续集成部署

>   实际工作中， 关于mysql和redis，我们都是力求发挥最大性能，所以不会把mysql和redis放在docker作为容器运行，这里的演示仅仅是条件所限制。

##### 修改源

因为接下来需要在公网服务器中安装部署相关的节点软件，所以我们配置下Linux的源【如果阿里云购买的服务器器默认已经配置了阿里云的源，可以跳过当前步骤】

1、输入命令修改sources.list文件，当然需要超级权限，所以要加sudo。

```bash
sudo vim /etc/apt/sources.list
```

编辑/etc/apt/sources.list文件

2、在文件最前面添加以下条目(操作前请做好相应备份)：

```bash
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse
deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse
deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse
deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse
deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse
deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse
```

3、修改完成后，保存文件，警告什么的都不理，然后运行下面的命令。

```bash
sudo apt-get update
sudo apt-get upgrade
```



##### 安装docker

更新ubuntu的apt源索引

```shell
sudo apt-get update
```



安装包允许apt通过HTTPS使用仓库

```shell
sudo dpkg --configure -a
sudo apt-get install apt-transport-https ca-certificates curl software-properties-common
```



添加Docker官方GPG key【这个是国外服务器地址，所以网路不好的时候，会失败！在网路好的情况下，多执行几次就没问题了，如果下一行结果不是OK，则执行多几遍】

```shell
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
```



设置Docker稳定版仓库【添加docker源到系统中】

```shell
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
```

添加源后，更新apt源索引

```shell
sudo apt-get update
```

前面的准备工作完成以后，接下来安装最新版Docker CE（社区版）

```shell
sudo apt-get install docker-ce
```

检查Docker CE是否安装正确

```shell
sudo docker version
```

出现了`版本信息`则表示上面的安装成功！

![1596255525352](12%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2.assets/1596255525352.png)



如果我们之前开发并没有把项目上传到码云上面，那么接下来先提交一个最终版本。

```python
git add .
git commit -m "项目完成"
git push

如果有使用分支，一定要设置分支。
```

在部署架构中，我们决定了使用nginx代理客户端项目，提供网页服务，所以我们不需要在线上安装vue-cli了。所以只需要对vue项目进行编译，因为不使用vue-cli的话，则服务器不支持vue组件的，所以要编译成普通html/js/css代码。

编译之前，先修改配置的文件的信息，例如，当前客户端的域名和api服务端的域名。

src/settings.js，代码：

```
export default {
    "HOST": "http://api.lxh1.com",
}
```

终端执行命令：

```bash
cd renran_pc
# 如果本地没有node_modules的，则执行 npm install 还原依赖
npm run build
```

效果：

![1563499586930](12%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2.assets/1563499586930.png)

编译完成的内容会被保存在dist目录下，并且编译出来的项目，不能直接通过file://来访问，只能通过http服务器的运行这个项目。

![1563499650947](12%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2.assets/1563499650947.png)

接下来，把当前这个编译好的内容直接通过git记录版本。

dist默认会被git忽略掉，所以需要在项目根目录下找到.gitignore文件，并把里面的`/dist/`去掉。

![1596011267737](12%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2.assets/1596011267737.png)

接下来在终端下直接提交代码版本。

```bash
cd renran
git add .
git commit -m "前端项目编译完成"
# 此时可以通过tag标签命令创建一个版本。
git tag -a v1.0.0 -m "前端项目编译完成"
git push origin --tags # 可以在线上针对当前标签版本进行指定发布
```



#### 把前端项目通过nginx web服务器运行

##### Nginx

Nginx是一款基于异步框架的轻量级/高性能的Web 服务器/反向代理服务器/缓存服务器/电子邮件(IMAP/POP3)/代理服务器，并在一个BSD-like协议下发行。由俄罗斯的程序设计师Igor Sysoev(伊戈尔·赛索耶夫)所开发，最初供俄国大型网站Rambler.ru及搜寻引擎Rambler使用。

使用docker拉去镜像之前，可以给线上的docker配置国内源，保证安装速度。

https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors

```python
sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json <<-'EOF'
{
  "registry-mirrors": ["https://2xdmrl8d.mirror.aliyuncs.com"]
}
EOF
# 重启docker，让加速配置生效
sudo service docker restart
```



#### 下载安装 nginx镜像

```python
# 在docker中下载nginx镜像
docker image pull nginx

# 使用git把码云上面的编译过的vue项目克隆到服务器/home
cd /home
# 阿里云服务器中，已经内置了git，所以可以直接从码云克隆项目下来。
# git clone 项目git地址
git clone https://gitee.com/mooluo/renranzixun.git
# 为了方便演示，我这里修改下项目目录，为/home/renran
mv renranzixun renran

# 因为前面我们已经发布了1.0.0版本，所以在此，我们直接可以检出标签版本
cd renran
git checkout v1.0.0

# 创建nginx容器，并以80端口对外提供服务
# /usr/share/nginx/html 是nginx在安装时，系统默认分配的网站项目的根目录
docker run -itd -p 80:80 -v /home/renran/renran_pc/dist:/usr/share/nginx/html --name=renran_pc nginx
# 执行上面的命令，理论上来说，就可以让前端项目，可以阿里云的IP地址访问到了。

"""
/etc/nginx              # nginx容器中nginx的配置目录
/etc/nginx/conf.d/default.conf  # 默认站点的配置文件
/usr/share/nginx/html   # nginx容器中网站根目录
"""
```

上面部署命令之后，我们就可以通过IP来访问项目了，但是我们项目一般通过域名提供给用户来进行访问的

把IP和域名的映射关联到阿里云服务器上面来。

```python
前端域名：http://3w.lxh1.com
服务器的公网IP： 47.96.95.61
```

![1563520627377](12%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2.assets/1563520627377.png)

我们现在可以解析域名到服务器了，但是如果有多个域名同时都指向这个服务器，则所有的域名都会访问到同一个项目中，所有我们把不同的域名和不同的项目目录进行配置绑定。

这里就需要手动修改nginx的配置。通过`docker cp`复制renran_pc容器中的nginx文件出来，并在修改完成以后赋值到renran_pc容器中，接着重启renran_pc容器。

```bash
cd /home/renran
docker cp renran_pc:/etc/nginx/conf.d/default.conf  /home/renran/nginx.conf
vim nginx.conf
```

nginx.conf配置信息修改如下：

```bash
# 修改 server_name 对应的路径
server{
  listen   80;
  server_name  3w.lxh1.com;
  
  # ...
}

# 按Esc键
# 输入 :wq 保存文件
```

接下来把nginx.conf复制到renran_pc容器中，并重启项目

```pytbashhon
docker cp /home/renran/nginx.conf renran_pc:/etc/nginx/conf.d/default.conf
docker container stop renran_pc
docker container start renran_pc
```



## 后端项目部署

根据我们之前分析的项目部署架构，后端需要需要mysql和redis，FastDFS。所有在此我们需要先把这些外部工具先预装。

#### 安装mysql镜像

>   在实际工作中，mysql一般不会安装到docker中作为容器运行，这样很影响mysql的效率和性能。我们这里仅仅是为了学习，方便在一台服务器中完成整个架构的部署。

检查下原来的mysql版本，5.7版本的。

```python
# 如果之前的mysql已经镜像没有下载，则下载命令如下：
docker image pull mysql:5.7
# -e 设置容器内部的环境变量,一个容器在创建的时候,可以多个不同的环境
# 启动mysql容器，MYSQL_ROOT_PASSWORD 指代的就是mysql的root用户的登录密码
docker run -itd -p3306:3306 -e MYSQL_ROOT_PASSWORD=123456 --name=mysql mysql:5.7
# 如果需要多台mysql容器安装在一台服务器中，那么容器内部的端口可以不用设置，但是真实物理系统的端口必须要修改，保证端口唯一！
# docker run -itd -p3307:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7
# docker run -itd -p3308:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7


# 我们可以在任意一个外部网路中，远程链接到数据库中
# 注意使用命令远程链接mysql，必须使用的地方有mysql
mysql -hIP -P端口 -uroot -p密码
# mysql -h47.96.95.61 -P3306 -uroot -p123456
```

docker container run的选项：

-e 就是设置容器内部的环境变量， 在docker容器的使用过程中， 有部分容器需要配置环境的，这些环境变量都是有下载镜像时官方指定的。



#### 把本地的数据导入到mysql容器数据库中

```python
# 在本地的ubuntu下远程链接数据库
mysql -uroot -p123456 -h47.96.95.61
# 创建数据库
create database renran charset=utf8mb4;
exit
# 把本地的数据库导出到桌面
mysqldump -uroot -p123 renran > ~/Desktop/renran/renranapi/renran_2020_08_01.sql

# 把桌面下导出的数据库文件导入到docker容器中的mysql数据库
mysql -uroot -p123456 -h47.96.95.61 renran <  ~/Desktop/renran/renranapi/renran_2020_08_01.sql
```



#### 安装redis容器

>   实际工作中，redis常用于保存数据到内存中， 所以要求效率高，对性能的要求也高，所以不会把redis作为容器运行。同时，实际工作中，redis需要调整配置，限制只能通过指定服务器才能连接到redis

```python
# 因此我们需要在docker中下载redis和mysql的容器
docker pull redis

# 创建redis容器并运行redis
docker run -itd -p6379:6379 --name=redis redis
    
# 可以进入到redis中，进行测试redis是否已经成功启动
docker container exec -it redis redis-cli
```

#### 安装FastDFS容器

##### 拉取镜像

```bash
sudo docker pull season/fastdfs
```

##### 创建调度服务器

在家目录下创建tracker调度服务器器的运行目录tracker_data

```bash
mkdir ~/tracker_data
# 创建容器开启tracker服务
sudo docker run -itd --name tracker --restart=always --net=host -v ~/tracker_data:/fastdfs/tracker/data season/fastdfs tracker
```



##### 创建存储服务器

这里我们使用的是云服务器，IP地址就是使用公网地址。

创建运行目录和文件存储目录

```bash
mkdir ~/storage_data
mkdir ~/store_path
```

创建容器并启动服务

```bash
sudo docker run -itd --restart=always --net=host --name storage -v ~/storage_data:/fastdfs/storage/data -v ~/store_path:/fastdfs/store_path -e TRACKER_SERVER:47.96.95.61:22122 season/fastdfs storage
```

调整存储服务器的配置文件

```bash
sudo docker cp storage:/fdfs_conf/storage.conf /home/renran/storage.conf
```

storage.conf，代码：

```bash
vim /home/renran/storage.conf
:set nu          # 显示行号
:114             # 跳转到111行
tracker_server=47.96.95.61:22122
```

编辑好的配置文件再从容器外复制到容器内部，并重启存储服务器

```bash
sudo docker cp /home/renran/storage.conf  storage:/fdfs_conf/
sudo docker cp /home/renran/storage.conf  tracker:/fdfs_conf/
# 重启存储服务器，也可以连调度服务器也重启下。
sudo docker container stop storage
sudo docker container start storage

# 可以以下操作验证存储服务器和调度服务器是搭配运作了。
sudo docker exec -it tracker bash
cd /fdfs_conf/
fdfs_monitor storage.conf
```

使用fastdfs_nginx容器代理访问Fastdfs目录下的图片。

因为这个容器是本地封装的，所以需要通过linux的远传文件传输命令进行上传。

```bash
# scp 本地文件地址 登录帐号@服务器IP或域名:服务器地址
# 注意，先把fastdfs_nginx放到本地ubuntu的桌面上，然后打开本地终端， 一定是本地的终端！！！
scp /home/moluo/Desktop/fastdfs_nginx_0.0.1.tar.gz root@47.96.95.61:/home/renran

1. 把镜像加载到docker中
sudo docker load -i /home/renran/fastdfs_nginx_0.0.1.tar.gz
2. 创建nginx容器
sudo docker run -itd --restart=always --network=host --name=fdfs_nginx -v /home/moluo/store_path/:/home/store_path fastdfs_nginx:0.0.1
3. 执行以下命令，启动nginx
sudo docker container exec -it fdfs_nginx /usr/local/nginx/sbin/nginx
```

因为上面我们配置的调度器和存储服务器对应的fdfs_nginx都需要指定开发端口，所以需要到阿里云配置安全组。

##### 配置安全组

开放端口：8888和22122以及23000

![1596267111514](12%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2.assets/1596267111514.png)

接下来，访问`http://47.96.95.61:8888`查看nginx是否在工作。

![1596267194033](12%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2.assets/1596267194033.png)

### 服务端部署到docker容器中

#### 把后端项目进行部署前的处理

```python
1. 现在的配置都保存在dev.py中，不管数据库密码或者redis的地址或者配置信息都是属于开发阶段，
   项目上线以后，肯定换成公司的。所以一定会修改，我们需要把dev.py的内容复制到prod.py中，
   并修改对应的配置信息

2. 在本地开发时，我们使用的drf框架运行在debug模式下的，但是项目上线时，肯定要关闭debug模式，
   但是一旦关闭了debug模式，则drf框架就不再提供静态文件的浏览服务，也就是之前xadmin，admin,drf的
   接口页面的图片，样式或者js文件都不能访问到了。我们需要使用django提供的命令收集这些静态文件
   到一个目录下，后面通过nginx来对外提供浏览服务

3. 原来的drf项目是运行在python内置的提供的web服务器中，是python内置的测试服务器模块wsgiref提供。
   在项目上线的时候，我们不能使用这个模块来提供对外服务!
   不支持多线程，性能不好，本身在安全性上并不完善，python提供这个模块仅供学习和开发测试使用。
   runserver 不能用于生产,改成uwsgi/gunicorn这类型的。

4. 原来drf项目在本地开发时运行项目是安装了很多的第三方依赖模块。
   将来项目上线了，我们也肯定需要把本地的模块列表到线上服务器中还原！否则项目跑不起来
```



#### 修改现有的配置文件

复制开发配置文件dev.py 到生产配置prod.py

```python
"""
Django settings for renranapi project.

Generated by 'django-admin startproject' using Django 2.2.

For more information on this file, see
https://docs.djangoproject.com/en/2.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/2.2/ref/settings/
"""

import os

# Build paths inside the project like this: os.path.join(BASE_DIR, ...)
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
# BASE_DIR 因为我们的项目目录结构已经发生改变，所以此时BASE_DIR代表的就是项目主应用目录，不是项目根目录

# 在django中导包，其实系统会自动找到sys.path路径列表中查找内容。
import sys
# 如果希望某个目录里面的模块或者包，能直接被导入使用，只需要把路径添加到sys.path里面即可.
sys.path.insert(0, os.path.join(BASE_DIR,"apps"))
# print(sys.path) # 系统导包路径，没有注册到这的路径的所有包和模块，都不能直接导包

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/2.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'iyd$05@kw&hi#@av_35=1q%&&07lwgtjd*68&)h5#+ulgu^pm@'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = False

ALLOWED_HOSTS = ["api.lxh1.com"] # 自己打开ubuntu终端输入命令 ip a 查看ens33对应的ip地址
# ALLOWED_HOSTS = ["*"] # 自己打开ubuntu终端输入命令 ip a 查看ens33对应的ip地址


# Application definition
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',

    'corsheaders',
    'rest_framework',
    'xadmin',
    'crispy_forms',
    'reversion',

    'users',
    'oauth',
    'home',
    'article',
    'payments',
    'store', # 用于演示tableStore，后续删除掉即可
]

# CORS组的配置信息
CORS_ORIGIN_WHITELIST = (
    'http://3w.lxh1.com',
)
CORS_ALLOW_CREDENTIALS = False  # 不允许ajax跨域请求时携带cookie

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    # 'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'renranapi.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'renranapi.wsgi.application'


# Database
# https://docs.djangoproject.com/en/2.2/ref/settings/#databases

DATABASES = {
    # 'default': {
    #     'ENGINE': 'django.db.backends.sqlite3',
    #     'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    # },
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        "HOST": "47.96.95.61",   # 数据库所在地址【公网地址】
        "PORT": 3306,
        "USER": "root",        # 登录账号
        "PASSWORD": "123456",  # 登录密码
        "NAME": "renran",      # 数据库名称
    },
}

# 设置redis缓存【地址改成公网地址】
CACHES = {
    # 默认缓存
    "default": {
        "BACKEND": "django_redis.cache.RedisCache",
        # 项目上线时,需要调整这里的路径
        "LOCATION": "redis://47.96.95.61:6379/0",
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        }
    },
    # 提供给xadmin或者admin的session存储
    "session": {
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": "redis://47.96.95.61:6379/1",
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        }
    },
    # 提供存储短信验证码
    "sms_code":{
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": "redis://47.96.95.61:6379/2",
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        }
    },
}

# 设置xadmin/admin用户登录时,登录信息session保存到redis
SESSION_ENGINE = "django.contrib.sessions.backends.cache"
SESSION_CACHE_ALIAS = "session"


# Password validation
# https://docs.djangoproject.com/en/2.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/2.2/topics/i18n/

# 修改使用中文界面
LANGUAGE_CODE = 'zh-Hans'

# 修改时区
TIME_ZONE = 'Asia/Shanghai'

USE_I18N = True

USE_L10N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/2.2/howto/static-files/

# 访问静态文件的url地址前缀
STATIC_URL = '/static/'
# 设置django的静态文件目录
STATICFILES_DIRS = [
    os.path.join(BASE_DIR,"static")
]

# 项目中存储上传文件的根目录[暂时配置]，注意，uploads目录需要手动创建否则上传文件时报错
MEDIA_ROOT=os.path.join(BASE_DIR,"uploads")
# 访问上传文件的url地址前缀
MEDIA_URL ="/media/"

# 日志配置
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': { # 日志的处理格式
        'verbose': {
            'format': '%(levelname)s %(asctime)s %(module)s %(lineno)d %(message)s'
        },
        'simple': {
            'format': '%(levelname)s %(module)s %(lineno)d %(message)s'
        },
    },
    'filters': {
        'require_debug_true': {
            '()': 'django.utils.log.RequireDebugTrue',
        },
    },
    'handlers': {
        'console': {
            'level': 'DEBUG',
            'filters': ['require_debug_true'],
            'class': 'logging.StreamHandler',
            'formatter': 'simple'
        },
        'file': {
            'level': 'INFO',
            'class': 'logging.handlers.RotatingFileHandler',
            # 日志位置,日志文件名,日志保存目录logs必须手动创建
            'filename': os.path.join(os.path.dirname(BASE_DIR), "logs/renran.log"),
            # 单个日志文件的最大值,这里我们设置300M
            'maxBytes': 300 * 1024 * 1024,
            # 备份日志文件的数量,设置最大日志数量为10
            'backupCount': 10,
            # 日志格式:详细格式
            'formatter': 'verbose'
        },
    },
    # 日志对象
    'loggers': {
        'django': { # 固定必须叫django，将来django内部也会有异常的处理，只会调用django下标的日志对象
            'handlers': ['console', 'file'],
            'propagate': True, # 是否让日志信息继续冒泡给其他的日志处理系统
        },
    }
}

REST_FRAMEWORK = {
    # 异常处理
    'EXCEPTION_HANDLER': 'renranapi.utils.exceptions.custom_exception_handler',
    # 认证方式
    'DEFAULT_AUTHENTICATION_CLASSES': (
        # 新增jwt认证，注意不能删除session认证，因我们后面的admin运营站点还是使用的session认证
        'rest_framework_jwt.authentication.JSONWebTokenAuthentication',
        'rest_framework.authentication.SessionAuthentication',
        'rest_framework.authentication.BasicAuthentication',
    ),
}

# jwt的配置选项
from django.utils import timezone as datetime
JWT_AUTH = {
    # jwt token的有效期，默认是5分钟
    'JWT_EXPIRATION_DELTA': datetime.timedelta(days=7),
    # 登录成功以后的自定义相应内容
    'JWT_RESPONSE_PAYLOAD_HANDLER': 'users.utils.jwt_response_payload_handler',
}

# 告诉django，调用自定义用户模型替换原来内置的用户模型
# 配置项的值格式有要求，必须严格按照以下格式编写，多一个符号都会报错
# AUTH_USER_MODEL = "子应用.模型类名"
AUTH_USER_MODEL = 'users.User'

AUTHENTICATION_BACKENDS = [
    'users.utils.CustomAuthUserModelBackend',
]

# 腾讯防水墙验证码相关配置【换成公司的秘钥信息】
TENCENT_CAPTCHA = {
    "GATEWAY": "https://ssl.captcha.qq.com/ticket/verify",
    "APPID": "2044977606",
    "App_Secret_Key": "0Ns8dOGHAAFiaDwPhdo2HBg**",
}

# 短信配置【换成公司的秘钥信息】
SMS = {
    # 容联云通讯分配的主账号ID
    "accId": '8a216da863f8e6c20164139687e80c1b',
    # 容联云通讯分配的主账号TOKEN
    "accToken": '6dd01b2b60104b3dbc88b2b74158bac6',
    # 容联云通讯分配的应用ID
    "appId": '8a216da863f8e6c20164139688400c21',
    # 容联云通讯创建的模板,1表示使用测试模板
    "tid":1
}

# QQ登录配置参数【换成公司的秘钥信息】
QQ_CONNECT = {
    "app_id": "101403367",
    "app_key": "93112df14c10d6fde74baa62f5de95ab",
    "redirect_uri": "http://3w.lxh1.com/oauth_callback.html",
    "state": "/", # 用于保存登录成功后的跳转页面路径,查询字符串的参数信息,
}


# 邮件相关配置【换成公司的秘钥信息】
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'smtp.163.com'
EMAIL_PORT = 25
#发送邮件的邮箱
EMAIL_HOST_USER = 'mooluoo@163.com'
#在邮箱中设置的客户端授权密码
EMAIL_HOST_PASSWORD = 'renranwang2020'
#收件人看到的发件人
EMAIL_FROM = '荏苒网<mooluoo@163.com>'

# 客户端相关配置
CLIENT_HOST = "http://3w.lxh1.com"


# django文件存储
DEFAULT_FILE_STORAGE = 'renranapi.utils.fastdfs.fdfs_storage.FastDFSStorage'

# FastDFS【换成公网IP，端口还是8888】
FDFS_URL = 'http://47.96.95.61:8888/'  # 访问图片的路径域名 ip地址修改为自己机器的ip地址
FDFS_CLIENT_CONF = os.path.join(BASE_DIR, 'utils/fastdfs/client.conf')


# 支付宝配置【换成公司的配置信息】
ALIPAY = {
    # "gateway_url": "https://openapi.alipay.com/gateway.do?", # 真实支付宝网关地址
    "gateway_url": "https://openapi.alipaydev.com/gateway.do?", # 沙箱支付宝网关地址
    "appid": "2016091600523592", # 应用ID
    "app_notify_url": None, # 支付成功以后的回调地址[这里是全部接口的回调地址，不需要配置]
    "app_private_key_path": os.path.join(BASE_DIR, "apps/payments/keys/app_private_key.pem"),
    "alipay_public_key_path": os.path.join(BASE_DIR, "apps/payments/keys/alipay_public_key.pem"),
    "sign_type": "RSA2", # 秘钥类型
    "debug": False,
    "return_url": "http://3w.lxh1.com/payments/alipay", # 同步回调地址
    "notify_url": "http://api.lxh1.com/payments/alipay", # 异步结果通知
}


# tablestore【换成公司的配置信息】
# 应用ID
OTS_ID = "LTAI4G9ja6BxsF6yLCKJPzv9"
# 应用密钥
OTS_SECRET = "HJzpNpQ8dgdamS7j3844eNvvBJpKNT"
# 实例名称
OTS_INSTANCE = "renranpy29"
# 访问实例的公网地址
OTS_ENDPOINT = "https://renranpy29.cn-hangzhou.ots.aliyuncs.com"
```

服务端上面的项目调用prod配置时，使用的是uwsgi服务器，所以我们需要在主应用修改wsgi.py里面的配置文件地址。renranapi/wsgi.py代码：

```python
"""
WSGI config for renranapi project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/2.2/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'renranapi.settings.prod')

application = get_wsgi_application()

```



#### 从服务端项目中收集静态文件

当Django运行在生产环境中，我们会关闭debug调试，那么项目将不再提供静态文件的支持，需要将静态文件交给静态文件的nginx服务器来提供访问。

我们先收集所有静态文件。项目中的静态文件除了我们使用的上传文件之外，django本身还有自己的静态文件，如rest_framework、xadmin、admin、ckeditor等。我们需要收集这些静态文件，集中一起放到静态文件服务器中。

**我们要将收集的静态文件放到项目的static目录中，所以先创建目录static。**

Django提供了收集静态文件的方法。先在配置文件中配置收集之后存放的目录

settings/dev.py 和prod.py，代码：

```python
# 访问静态文件的url地址前缀
STATIC_URL = '/static/'
# 设置django的静态文件目录
STATICFILES_DIRS = [
    os.path.join(os.path.dirname(BASE_DIR), 'static')
]

# 静态文件存储目录[将来收集命令执行了以后，在下面保存]
STATIC_ROOT = os.path.join(os.path.dirname(BASE_DIR), 'static')

# 注意需要手动创建static目录
```

因为目前在本地我们依然使用了dev.py文件运行项目，所以我们在本地项目收集静态文件就需要把配置信息同步到dev.py



在终端下执行django收集静态文件的命令

```shell
python manage.py collectstatic
```

执行收集命令以后，效果如下：

![1596269844171](12%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2.assets/1596269844171.png)



收集完成静态资源以后,我们就使用git提交并上传到码云,回头可以通过到真实服务器上面,

```bash
# 本地电脑
cd ~/Desktop/renran
git add .
git commit -m "调整服务端的配置和收集静态资源"
git push

# 公网服务器拉去静态资源
git pull
# 如果无法拉取静态文件，则可以在本地创建一个分支保存现有内容，接着提交分支，最后到线上拉取。
# 本地终端执行
# git checkout -b dev  # git branch dev 和 git checkout dev 的合并命令
# git push origin dev
# 线上终端执行
# git pull
# git checkout dev
```



#### 使用uwsgi服务器来运行服务端项目

我们可以在本地环境中先安装uwsgi模块进行使用，然后成功使用uwsgi启动项目，后面再一并上传到服务器即可。

```python
pip install uwsgi -i https://pypi.douban.com/simple/
uwsgi --version    # 查看 uwsgi 版本
```



在本地项目根目录下创建uwsgi配置文件uwsgi.ini

```ini
[uwsgi]
#使用nginx连接时使用，Django程序所在服务器地址
# socket=0.0.0.0:8000
#直接做web服务器使用，Django程序所在服务器地址
http=0.0.0.0:8000
#项目目录[uwsgi所在目录，是绝对目录]
chdir=/home/moluo/Desktop/renran/renranapi
#项目中wsgi.py文件的目录，相对于项目目录
wsgi-file=renranapi/wsgi.py
# 进程数
processes=4
# 线程数
threads=2
# uwsgi服务器启动多进程是否启动主进程进行监控
master=True
# 存放进程编号的文件
pidfile=uwsgi.pid
# 日志文件，因为uwsgi可以脱离终端在后台运行，日志看不见。我们以前的runserver是依赖终端的
daemonize=uwsgi.log
# 指定依赖的虚拟环境
virtualenv=/home/moluo/.virtualenvs/renran
```

启动uwsgi服务器，必须在uwsgi.ini配置文件所在的目录中运行下面的命令

注意，在本地环境中必须先把runserver关闭

```shell
workon renran
uwsgi --ini uwsgi.ini
```

停止uwsgi服务器，还可以通过使用kill命令停止

```
workon renran
uwsgi --stop uwsgi.pid
```

本地访问项目出现`Bad Request (400)`，主要因为我们在配置文件prod.py中的ALLOWED_HOSTS中把本地余名移除了，所以无法访问，这是正常的。所以如果要通过本地域名api.renran.cn访问到项目，则在ALLOWED_HOSTS中添加域名进行测试即可。效果如下：

![1596271242457](12%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2.assets/1596271242457.png)



#### 把django项目上传部署到服务器并使用uwsgi服务器运行

1. 在本地电脑中导出当前虚拟环境中的模块包列表

   ```
   cd ~/Desktop/renran/renranapi
   pip freeze > requirements.txt
   ```

2. 把本地更改的内容通过git提交到码云

   ```bash
   git add .
   git commit -m "导出服务端项目模块依赖列表"
   git push       # 如果要提交代码到分支，例如：dev ，则提交命令为：git push origin dev
   ```

   

3. 在阿里云服务器中使用git拉取最新的项目内容。

   ```bash
   cd /home/renran/
   git pull
   # 如果上面提交代码到分支中，则需要切换分支才能看到最新记录。例如：dev
   # git checkout dev
   ```



##### 创建服务端容器，使用ubuntu镜像，还原项目依赖

```python
# 创建接下来运行django项目的容器
docker image pull ubuntu:18.04

# 因为我们的api项目已经上传到了真实服务器中,所以我们执行映射api项目的文件到容器中/home/renrancity目录下
docker container run -itd -p 8000:8000 --name=uwsgi -v /home/renran/renranapi:/home/renran ubuntu:18.04
# docker container run -itd -p 8001:8000 --name=uwsgi -v /home/renran/renranapi:/home/renran ubuntu:18.04
# 进入容器
docker container exec -it uwsgi bash
# 更新镜像源[如果有时间，可以修改这个容器的镜像源]
apt-get update
# 也可以安装一些基本的软件和命令，也可以不安装
apt-get install vim
# 检车当前容器中的python版本,如果没有python3则安装python3
```



5. 在uwsgi容器安装python的虚拟环境

```python
# 虽然云服务器上面内置了python3,但是没有内置pip工具，所以要安装python3的pip工具
apt install python3-pip

# 使用pip安装虚拟环境
pip3 install virtualenv -i https://pypi.douban.com/simple/
pip3 install virtualenvwrapper  -i https://pypi.douban.com/simple/

# 配置虚拟环境的环境变量
# 执行命令
mkdir $HOME/.virtualenvs

# 执行命令，打开并编辑 ~/.bashrc  # 如果上面没有安装vim，则把这个文件复制到容器外界编辑
vim  ~/.bashrc

# shift键+GG来到文件末尾添加以下几行代码，:wq 保存退出。
export WORKON_HOME=$HOME/.virtualenvs
export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3
source /usr/local/bin/virtualenvwrapper.sh

# 刷新环境变量的配置文件
source ~/.bashrc

# 创建虚拟环境
mkvirtualenv renran -p python3
```



1. 把本地虚拟环境中导出模块包列表，在线上服务器重新安装

```bash
# 在容器中同步之前的个人开发环境中安装包列表到当前虚拟环境中 requirements.txt
cd /home/renran
pip install -r requirements.txt -i https://pypi.douban.com/simple/
# 上面命令执行过程会出现错误，其中有fdfs_client_py。
# 解决方案:
# 1. 在本地ubuntu防止fdfs_client_py模块的压缩包，然后执行以下命令：
scp /home/moluo/Desktop/fdfs_client-py-master.zip root@47.96.95.61:/home/renran/renranapi
# 2. 在服务器上，进入uwsgi容器，安装fdfs_client_py
docker container exec -it uwsgi bash
workon renran
cd /home/renran
pip install fdfs_client-py-master.zip
# 执行执行pip安装requirements.txt中的包列表
pip install -r requirements.txt -i https://pypi.douban.com/simple/
```



6. 在容器中启动uwsgi，通过使用uwsgi作为http服务器先测试项目是否正常运行，后面在使用nginx来代理。

   直接在容器外面使用vim修改一下uwsgi.ini配置文件，修改完成以后，容器内部的uwsgi.ini也会被改变

   ```python
   # 退出容器
   exit
   # 切换到服务端目录下
   cd /home/renran/renranapi
   vim uwsgi.ini
   ```

   

   ```python
   [uwsgi]
   #使用nginx连接时使用，Django程序所在服务器地址
   # socket=0.0.0.0:8000
   #直接做web服务器使用，Django程序所在服务器地址
   http=0.0.0.0:8000
   #项目目录
   chdir=/home/renran
   #项目中wsgi.py文件的目录，相对于项目目录
   wsgi-file=renranapi/wsgi.py
   # 进程数
   processes=4
   # 线程数
   threads=2
   # uwsgi服务器的角色
   master=True
   # 存放进程编号的文件
   pidfile=uwsgi.pid
   # 日志文件，因为uwsgi可以脱离终端在后台运行，日志看不见。我们以前的runserver是依赖终端的
   daemonize=uwsgi.log
   # 指定依赖的虚拟环境
   virtualenv=/root/.virtualenvs/renran
   ```

   

   进入容器中的api项目根目录/home/renran，启动uwsgi，命令:

   ```
   docker container exec -it uwsgi bash
   ```

   容器内操作：

   ```python
   cd /home/renran/
   # 经过上面的步骤，我们直接切到uwsgi.ini所在目录下，运行项目
   # 注意，必须先进入虚拟环境中， workon renran，才能运行
   workon renran
   uwsgi --ini uwsgi.ini
   # 运行过程中， 如果报错了，则直接查看uwsgi.log
   ```

   运行命令查看uwsgi是否启动了。

   ```
   ps aux | grep uwsgi
   ```

   效果：

![1563528761684](12%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2.assets/1563528761684.png)

可以看到uwsgi已经启动了，但是我们通过浏览器`http://api.lxh1.com:8000`访问发现，访问不了。

![1596019707593](12%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2.assets/1596019707593.png)

很明显uwsgi已经启动了，为什么不能访问？我们可以uwsgi的运行日志uwsgi.log来查看！

```bash
cat /home/renran/uwsgi.log
# 根据错误提示，进行配置修改或者代码调整
# 关于查看uwsgi的错误信息，主要看一个***
# ***上面的才是真正的错误信息。
```

![1563528911397](12%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2.assets/1563528911397.png)

上面错误日志显示，pymysql的mysql-client版本监测，所以我们根据提示修改！

```
解决：
注释掉，报错文件的36行客户端版本监测功能！

vim /root/.virtualenvs/renran/lib/python3.6/site-packages/django/db/backends/mysql/base.py
```



![1563529004653](12%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2.assets/1563529004653.png)

```python
注意：
1. vim中编辑保存如果不成功！，则在调用vim前面加上sudo
2. vim中如果要显示文件行号，使用 :set nu
```



修改完成以后，uwsgi容器里面，重启uwsgi。

```
cd /home/renran
uwsgi --stop uwsgi.pid
uwsgi --ini uwsgi.ini
```



如果还是访问不了。继续查看uwsgi的日志最底部，发现没有错误显示[***上方没有错误信息提示]，那么我们只能接着去查看django的错误日志【以下错误是部分服务器才出现的错误】

```
cat /home/renran/logs/renran.log
```

可以发现：

![1563530064696](12%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2.assets/1563530064696.png)

修改报错位置，保存文件：

```bash
vim /root/.virtualenvs/renran/lib/python3.6/site-packages/django/db/backends/mysql/operations.py
# 跳到146行
:146
# 代码调整如下：
query = query.encode(errors=>'replace')
```



经过上面的错误u修改以后，修改就可以访问到了。

```python
如果再次启动uwsgi成功，但是还是无法访问页面，而是出现服务器内部错误的信息，则在logs/renran.log或者uwsgi.log中查看错误信息。
```



## 使用nginx对uwsgi进行反向代理

因为前面已经安装和运行了前端项目容器就有了nginx，所以我们接下来只需要在nginx中配置即可。

当然这就需要我们调整前端的renran_pc容器。

因为前面我们是在容器外修改的nginx，所以直接改动外接的nginx配置文件，并复制到项目中，重启容器。

```bash
cd /home/renran
vim nginx.conf
```

nginx.conf原有内容不要删减，在文件顶部增加如下配置代码：

```python
     upstream renran {
         server 47.96.95.61:8000;
         # server 47.96.95.61:8001;
     }

     #gzip  on;
     server {
         listen  80;
         server_name api.lxh1.com;

         location / {
             include uwsgi_params;
             uwsgi_pass renran;
         }
     }
server {
    listen       80;
    listen  [::]:80;
    server_name  3w.lxh1.com;
	.....
```

把nginx.conf复制到renran_pc容器内部，并重启容器。

```bash
docker cp /home/renran/nginx.conf renran_pc:/etc/nginx/conf.d/default.conf
docker container stop renran_pc
docker container start renran_pc
```

因为之前服务端项目的uwsgi是运行在http模式下，是没有办法接收nginx转发的uwsgi请求，所以我们就需要把wusgi容器中api服务端里面的uwsgi的运行模式改成socket模式。

```bash
# 容器外面执行
vim /home/renran/renranapi/uwsgi.ini
```

uwsgi.ini调整如下：

```python
[uwsgi]
#使用nginx连接时使用，Django程序所在服务器地址
socket=0.0.0.0:8000
#直接做web服务器使用，Django程序所在服务器地址
# http=0.0.0.0:8000
#项目目录
chdir=/home/renran
#项目中wsgi.py文件的目录，相对于项目目录
wsgi-file=renranapi/wsgi.py
# 进程数
processes=4
# 线程数
threads=2
# uwsgi服务器的角色
master=True
# 存放进程编号的文件
pidfile=uwsgi.pid
# 日志文件，因为uwsgi可以脱离终端在后台运行，日志看不见。我们以前的runserver是依赖终端的
daemonize=uwsgi.log
# 指定依赖的虚拟环境
virtualenv=/root/.virtualenvs/renran
```

进入容器启动uwsgi项目。

```bash
docker container exec -it uwsgi bash
workon renran
cd /home/renran
uwsgi --stop uwsgi.pid
uwsgi --ini uwsgi.ini
# 直接访问站点后台 `http://api.lxh1.com/xadmin@2020`
```

>    因为我们设置uwsgi开机自启。如果要设置开机自启，需要配置supervisor



## 针对后端服务器的运营站提供静态文件的访问支持

接下来，直接让前端的nginx容器同时提供静态文件的访问支持。

进入前端nginx容器并在nginx的配置文件default.conf里面的server部分中配置提供静态文件的访问！

先删除前端的vue项目的容器，然后再创建一个新的nginx容器，同时在创建的时候，我们进行目录映射。

前端项目要映射到容器，同时还要把api项目的static静态文件目录也要映射到该容器中。

```python
# 先把现有的前端nginx容器打包成镜像
# docker commit  <容器名称/容器ID> front
docker commit  renran_pc front

# 停止并删除前端nginx服务容器
docker container stop renran_pc
docker container rm renran_pc

# 基于上面的front前端镜像重新创建一个前端容器。
# 真实服务器下的客户端vue项目目录     /home/renran/renran_pc/dist 
# 真实服务器下的服务端drf项目目录     /home/renran/renranapi/static
docker run -itd -p 80:80 -v /home/renran/renran_pc/dist:/usr/share/nginx/html -v /home/renran/renranapi/static:/usr/share/nginx/static --name=renran_pc front
```

在容器外部编辑nginx.conf，增加对于静态的访问配置，代码：

```bash
vim /home/renran/nginx.conf
```

nginx.conf，内容：

```python
upstream renran {
    server 47.96.95.61:8000;
    # server 47.96.95.61:8001;
}

server {
    listen  80;
    server_name api.lxh1.com;

    location / {
        include uwsgi_params;
        uwsgi_pass renran;
    }
    
    location /static {
        root /usr/share/nginx;
    }
    
}


server {
    listen       80;
    server_name  3w.lxh1.com;

    #charset koi8-r;

    #access_log  logs/host.access.log  main;

    location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm;
        try_files $uri $uri/ /index.html;
    }

    #error_page  404    /404.html;

    # redirect server error pages to the static page /50x.html
    #
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   html;
    }

    # proxy the PHP scripts to Apache listening on 127.0.0.1:80
    #
    #location ~ \.php$ {
    #    proxy_pass   http://127.0.0.1;
    #}

    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
    #
    #location ~ \.php$ {
    #    root           html;
    #    fastcgi_pass   127.0.0.1:9000;
    #    fastcgi_index  index.php;
    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
    #    include        fastcgi_params;
    #}

    # deny access to .htaccess files, if Apache's document root
    # concurs with nginx's one
    #
    #location ~ /\.ht {
    #    deny  all;
    #}
}

```

把nginx.conf复制到前端容器renran_pc，并重启容器。

```bash
docker cp /home/renran/nginx.conf renran_pc:/etc/nginx/conf.d/default.conf
docker container stop renran_pc
docker container start renran_pc
```



