# 垃圾回收机制



 解释器在执行到定义变量的语法时，会申请内存空间来存放变量的值，而内存的容量是有限的，这就涉及到变量值所占用内存空间的回收问题，当一个变量值没有用了（简称垃圾）就应该将其占用的内存给回收掉，那什么样的变量值是没有用的呢？

 单从逻辑层面分析，我们定义变量将变量值存起来的目的是为了以后取出来使用，而取得变量值需要通过其绑定的直接引用（如x=10，10被x直接引用）或间接引用（如l=[x,]，x=10，10被x直接引用，而被容器类型l间接引用），所以当一个变量值不再绑定任何引用时，我们就无法再访问到该变量值了，该变量值自然就是没有用的，就应该被当成一个垃圾回收。

 毫无疑问，内存空间的申请与回收都是非常耗费精力的事情，而且存在很大的危险性，稍有不慎就有可能引发内存溢出问题，好在Cpython解释器提供了自动的垃圾回收机制来帮我们解决了这件事。



## 一、什么是垃圾回收机制？

垃圾回收机制（简称GC）是Python解释器自带一种机制，专门用来回收不可用的变量值所占用的内存空间



## 二、为什么要用垃圾回收机制？

程序运行过程中会申请大量的内存空间，而对于一些无用的内存空间如果不及时清理的话会导致内存使用殆尽（内存溢出），导致程序崩溃，因此管理内存是一件重要且繁杂的事情，而python解释器自带的垃圾回收机制把程序员从繁杂的内存管理中解放出来。



## 三、理解GC原理需要储备的知识

### 3.1、堆区与栈区

 在定义变量时，变量名与变量值都是需要存储的，分别对应内存中的两块区域：堆区与栈区。

- 变量名与值内存地址的关联关系存放于栈区

- 变量值存放于堆区，内存管理回收的则是堆区的内容，



### 3.2 直接引用与间接引用

 直接引用指的是从栈区出发直接引用到的内存地址。

 间接引用指的是从栈区出发引用到堆区后，再通过进一步引用才能到达的内存地址。

 如

```python
l2 = [20, 30]  # 列表本身被变量名l2直接引用，包含的元素被列表间接引用
x = 10  # 值10被变量名x直接引用
l1 = [x, l2]  # 列表本身被变量名l1直接引用，包含的元素被列表间接引用
```



## 四、垃圾回收机制原理分析

 Python的GC模块主要运用了“引用计数”（reference counting）来跟踪和回收垃圾。在引用计数的基础上，还可以通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用的问题，并且通过“分代回收”（generation collection）以空间换取时间的方式来进一步提高垃圾回收的效率。

### 4.1、引用计数

引用计数就是：变量值被变量名关联的次数

如：age=18

变量值18被关联了一个变量名age，称之为引用计数为1

引用计数增加：

age=18 （此时，变量值18的引用计数为1）

m=age （把age的内存地址给了m，此时，m,age都关联了18，所以变量值18的引用计数为2）

引用计数减少：

age=10（名字age先与值18解除关联，再与10建立了关联，变量值18的引用计数为1）

del m（del的意思是解除变量名x与变量值18的关联关系，此时，变量18的引用计数为0）

值18的引用计数一旦变为0，其占用的内存地址就应该被解释器的垃圾回收机制回收

### 4.2、引用计数的问题与解决方案

#### 4.2.1 问题一：循环引用

 引用计数机制存在着一个致命的弱点，即循环引用（也称交叉引用）

```python
# 如下我们定义了两个列表，简称列表1与列表2，变量名l1指向列表1，变量名l2指向列表2
>>> l1=['xxx']  # 列表1被引用一次，列表1的引用计数变为1   
>>> l2=['yyy']  # 列表2被引用一次，列表2的引用计数变为1   
>>> l1.append(l2)             # 把列表2追加到l1中作为第二个元素，列表2的引用计数变为2
>>> l2.append(l1)             # 把列表1追加到l2中作为第二个元素，列表1的引用计数变为2

# l1与l2之间有相互引用
# l1 = ['xxx'的内存地址,列表2的内存地址]
# l2 = ['yyy'的内存地址,列表1的内存地址]
>>> l1
['xxx', ['yyy', [...]]]
>>> l2
['yyy', ['xxx', [...]]]
>>> l1[1][1][0]
'xxx'
```

循环引用会导致：值不再被任何名字关联，但是值的引用计数并不会为0，应该被回收但不能被回收，什么意思呢？试想一下，请看如下操作

```python
>>> del l1 # 列表1的引用计数减1，列表1的引用计数变为1
>>> del l2 # 列表2的引用计数减1，列表2的引用计数变为1
```
此时，只剩下列表1与列表2之间的相互引用

但此时两个列表的引用计数均不为0，但两个列表不再被任何其他对象关联，没有任何人可以再引用到它们，所以它俩占用内存空间应该被回收，但由于相互引用的存在，每一个对象的引用计数都不为0，因此这些对象所占用的内存永远不会被释放，所以循环引用是致命的，这与手动进行内存管理所产生的内存泄露毫无区别。 所以Python引入了“标记-清除” 与“分代回收”来分别解决引用计数的循环引用与效率低的问题


#### 4.2.2 解决方案：标记-清除

 容器对象（比如：list，set，dict，class，instance）都可以包含对其他对象的引用，所以都可能产生循环引用。而“标记-清除”计数就是为了解决循环引用的问题。

 标记-清除算法的做法是当应用程序可用的内存空间被耗尽的时，就会停止整个程序，然后进行两项工作，第一项则是标记，第二项则是清除

- 标记

  通俗地讲就是：栈区相当于“根”，凡是从根出发可以访达（直接或间接引用）的，都称之为“有根之人”，有根之人当活，无根之人当死。

  具体地：标记的过程其实就是，遍历所有的GC Roots对象(栈区中的所有内容或者线程都可以作为GC Roots对象），然后将所有GC Roots的对象可以直接或间接访问到的对象标记为存活的对象，其余的均为非存活对象，应该被清除。

- 清除

  清除的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。

基于上例的循环引用，当我们同时删除l1与l2时，会清理到栈区中l1与l2的内容以及直接引用关系

这样在启用标记清除算法时，从栈区出发，没有任何一条直接或间接引用可以访达l1与l2，即l1与l2成了“无根之人”，于是l1与l2都没有被标记为存活，二者会被清理掉，这样就解决了循环引用带来的内存泄漏问题。

#### 4.2.3 问题二：效率问题

基于引用计数的回收机制，每次回收内存，都需要把所有对象的引用计数都遍历一遍，这是非常消耗时间的，于是引入了分代回收来提高回收效率，分代回收采用的是用“空间换时间”的策略。

#### 4.2.4 解决方案：分代回收

**分代：**

分代回收的核心思想是：**在历经多次扫描的情况下，都没有被回收的变量，gc机制就会认为，该变量是常用变量，gc对其扫描的频率会降低，**具体实现原理如下：

分代指的是根据存活时间来为变量划分不同等级（也就是不同的代）

新定义的变量，放到新生代这个等级中，假设每隔1分钟扫描新生代一次，如果发现变量依然被引用，那么该对象的权重（权重本质就是个整数）加一，当变量的权重大于某个设定得值（假设为3），会将它移动到更高一级的青春代，青春代的gc扫描的频率低于新生代（扫描时间间隔更长），假设5分钟扫描青春代一次，这样每次gc需要扫描的变量的总个数就变少了，节省了扫描的总时间，接下来，青春代中的对象，也会以同样的方式被移动到老年代中。也就是等级（代）越高，被垃圾回收机制扫描的频率越低

**回收：**

回收依然是使用引用计数作为回收的依据

虽然分代回收可以起到提升效率的效果，但也**存在一定的缺点：**

例如一个变量刚刚从新生代移入青春代，该变量的绑定关系就解除了，该变量应该被回收，但青春代的扫描频率低于新生代，这就到导致了应该被回收的垃圾没有得到及时地清理。

**没有十全十美的方案：**
毫无疑问，如果没有分代回收，即引用计数机制一直不停地对所有变量进行全体扫描，可以更及时地清理掉垃圾占用的内存，但这种一直不停地对所有变量进行全体扫描的方式效率极低，所以我们只能将二者中和。

**综上**

垃圾回收机制是在清理垃圾&释放内存的大背景下，允许分代回收以极小部分垃圾不会被及时释放为代价，以此换取引用计数整体扫描频率的降低，从而提升其性能，这是一种以空间换时间的解决方案。